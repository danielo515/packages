{"version":3,"sources":["../node_modules/nearley/lib/nearley.js","../nearley/grammar.js","../node_modules/sanctuary-type-classes/node_modules/sanctuary-type-identifiers/index.js","../node_modules/sanctuary-type-classes/index.js","../node_modules/sanctuary-type-identifiers/index.js","../node_modules/sanctuary-def/index.js","../node_modules/sanctuary/index.js","../nearley/compiler.js","../util.js","../nearley/index.js","index.js"],"names":["id","x","join","arr","sep","map","fn","nth","pos","head","pipe","fns","reduce","f","filter","predR","regex","test","notnull","log","console","info","toInt","_true","_false","nothing","compact","oBind","Object","assign","base","ext","option","type","push","grammar","Lexer","undefined","ParserRules","arrpush","d","concat","a","b","joiner","name","body","coerceTo","path","defaults","val","operator","_","args","ParserStart","module","exports","window","require","toLower","prop","joinWith","__","runtime","JSON","String","Integer","declare","extract","templateStr","varName","templateExports","names","processString","raw","seen","acc","replace","processDefault","str","def","processDefaults","compile","trees","symbols","compileExpression","tree","logDeep","dir","depth","colors","nearley","compiler","parser","Parser","Grammar","fromCompiled","content","feed","results","example"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtYA;AACA;AACA,CAAC,YAAY;AACb,YAASA,EAAT,CAAYC,CAAZ,EAAe;AAAE,aAAOA,EAAE,CAAF,CAAP;AAAc;;AAE9B,OAAMC,OAAO,SAAPA,IAAO;AAAA,aAAO;AAAA,gBAAOC,IAAID,IAAJ,CAASE,GAAT,CAAP;AAAA,OAAP;AAAA,IAAb;AACA,OAAMC,MAAM,SAANA,GAAM;AAAA,aAAM;AAAA,gBAAOF,IAAIE,GAAJ,CAAQC,EAAR,CAAP;AAAA,OAAN;AAAA,IAAZ;AACA,OAAMC,MAAM,SAANA,GAAM;AAAA,aAAO;AAAA,gBAAOJ,IAAIK,GAAJ,CAAP;AAAA,OAAP;AAAA,IAAZ;AACA,OAAMC,OAAO,SAAPA,IAAO;AAAA,aAAON,IAAI,CAAJ,CAAP;AAAA,IAAb;AACA,OAAMO,OAAO,SAAPA,IAAO;AAAA,wCAAKC,GAAL;AAAKA,YAAL;AAAA;;AAAA,aAAc;AAAA,gBAAKA,IAAIC,MAAJ,CAAW,UAACX,CAAD,EAAGY,CAAH;AAAA,mBAASA,EAAEZ,CAAF,CAAT;AAAA,UAAX,EAA2BA,CAA3B,CAAL;AAAA,OAAd;AAAA,IAAb;AACA,OAAMa,SAAS,SAATA,MAAS;AAAA,aAAM;AAAA,gBAAOX,IAAIW,MAAJ,CAAWR,EAAX,CAAP;AAAA,OAAN;AAAA,IAAf;AACA,OAAMS,QAAQ,SAARA,KAAQ;AAAA,aAAS;AAAA,gBAAKC,MAAMC,IAAN,CAAWhB,CAAX,CAAL;AAAA,OAAT;AAAA,IAAd;AACA,OAAMiB,UAAU,SAAVA,OAAU;AAAA,aAAKjB,KAAK,IAAV;AAAA,IAAhB;AACA,OAAMkB,MAAM,SAANA,GAAM;AAAA,aAAKC,QAAQC,IAAR,CAAapB,CAAb,KAAmBA,CAAxB;AAAA,IAAZ;AACA,OAAMqB,QAAQ,SAARA,KAAQ;AAAA,aAAKrB,IAAI,CAAT;AAAA,IAAd;AACA,OAAMsB,QAAQ,SAARA,KAAQ;AAAA,aAAM,IAAN;AAAA,IAAd;AACA,OAAMC,SAAS,SAATA,MAAS;AAAA,aAAM,KAAN;AAAA,IAAf;AACA,OAAMC,UAAU,SAAVA,OAAU;AAAA,aAAK,IAAL;AAAA,IAAhB;AACA,OAAMC,UAAUZ,OAAOI,OAAP,CAAhB;AACA,OAAMS,QAAQ,SAARA,KAAQ;AAAA,aAAQ;AAAA,gBAAOC,OAAOC,MAAP,CAAc,EAAd,EAAkBC,IAAlB,EAAwBC,GAAxB,CAAP;AAAA,OAAR;AAAA,IAAd;AACA,OAAMC,SAASL,MAAM,EAACM,MAAK,QAAN,EAAN,CAAf;AACA,OAAMC,OAAO,SAAPA,IAAO;AAAA,aAAO;AAAA,gBAAK/B,IAAI+B,IAAJ,CAASjC,CAAT,KAAeE,GAApB;AAAA,OAAP;AAAA,IAAb;AACD,OAAIgC,UAAU;AACVC,aAAOC,SADG;AAEVC,mBAAa,CACb,EAAC,QAAQ,gBAAT,EAA2B,WAAW,EAAtC,EADa,EAEb,EAAC,QAAQ,gCAAT,EAA2C,WAAW,CAAC,IAAD,EAAO,MAAP,CAAtD,EAAsE,eAAe/B,IAAI,CAAJ,CAArF,EAFa,EAGb,EAAC,QAAQ,gBAAT,EAA2B,WAAW,CAAC,gBAAD,EAAmB,gCAAnB,CAAtC,EAA4F,eAAe,SAASgC,OAAT,CAAiBC,CAAjB,EAAoB;AAAC,mBAAOA,EAAE,CAAF,EAAKC,MAAL,CAAY,CAACD,EAAE,CAAF,CAAD,CAAZ,CAAP;AAA4B,UAA5J,EAHa,EAIb,EAAC,QAAQ,SAAT,EAAoB,WAAW,CAAC,MAAD,EAAS,gBAAT,CAA/B,EAA2D,eAAe;AAAA;AAAA,gBAAEE,CAAF;AAAA,gBAAIC,CAAJ;;AAAA,oBAAYD,CAAZ,4BAAiBC,CAAjB;AAAA,UAA1E,EAJa,EAKb,EAAC,QAAQ,eAAT,EAA0B,WAAW,CAAC,EAAC,WAAU,GAAX,EAAD,EAAkB,EAAC,WAAU,GAAX,EAAlB,CAArC,EAAyE,eAAe,SAASC,MAAT,CAAgBJ,CAAhB,EAAmB;AAAC,mBAAOA,EAAEtC,IAAF,CAAO,EAAP,CAAP;AAAmB,UAA/H,EALa,EAMb,EAAC,QAAQ,MAAT,EAAiB,WAAW,CAAC,MAAD,EAAS,GAAT,EAAc,EAAC,WAAU,GAAX,EAAd,EAA+B,GAA/B,EAAoC,aAApC,EAAmD,GAAnD,EAAwD,eAAxD,EAAyE,GAAzE,EAA8E,MAA9E,EAAsF,IAAtF,CAA5B,EAAyH,eAAe;AAAA;AAAA;AAAA,gBAAG2C,IAAH;AAAA,gBAAaC,IAAb;AAAA;AAAA,gBAAsBC,QAAtB;;AAAA,mBAAuC,EAACd,MAAK,aAAN,EAAqBY,UAArB,EAA2BC,UAA3B,EAAiCC,kBAAjC,EAAvC;AAAA,UAAxI,EANa,EAOb,EAAC,QAAQ,MAAT,EAAiB,WAAW,CAAC,MAAD,CAA5B,EAPa,EAQb,EAAC,QAAQ,oBAAT,EAA+B,WAAW,EAA1C,EARa,EASb,EAAC,QAAQ,oBAAT,EAA+B,WAAW,CAAC,oBAAD,EAAuB,SAAvB,CAA1C,EAA6E,eAAe,SAASR,OAAT,CAAiBC,CAAjB,EAAoB;AAAC,mBAAOA,EAAE,CAAF,EAAKC,MAAL,CAAY,CAACD,EAAE,CAAF,CAAD,CAAZ,CAAP;AAA4B,UAA7I,EATa,EAUb,EAAC,QAAQ,aAAT,EAAwB,WAAW,CAAC,MAAD,EAAS,oBAAT,CAAnC,EAAmE,eAAe;AAAA;AAAA,gBAAEQ,IAAF;AAAA,gBAAQC,QAAR;;AAAA,mBAAuB,EAAED,UAAF,EAAQC,kBAAR,EAAvB;AAAA,UAAlF,EAVa,EAWb,EAAC,QAAQ,SAAT,EAAoB,WAAW,CAAC,GAAD,EAAM,EAAC,WAAU,GAAX,EAAN,EAAuB,GAAvB,EAA4B,OAA5B,CAA/B,EAAqE,eAAevC,KAAKH,IAAI,CAAJ,CAAL,EAAY;AAAA;AAAA,gBAAE2C,GAAF;;AAAA,mBAAWlB,OAAO,EAACkB,QAAD,EAAP,CAAX;AAAA,UAAZ,CAApF,EAXa,EAYb,EAAC,QAAQ,OAAT,EAAkB,WAAW,CAAC,MAAD,CAA7B,EAZa,EAab,EAAC,QAAQ,OAAT,EAAkB,WAAW,CAAC,KAAD,CAA7B,EAba,EAcb,EAAC,QAAQ,OAAT,EAAkB,WAAW,CAAC,KAAD,CAA7B,EAda,EAeb,EAAC,QAAQ,OAAT,EAAkB,WAAW,CAAC,YAAD,CAA7B,EAfa,EAgBb,EAAC,QAAQ,mBAAT,EAA8B,WAAW,CAAC,EAAC,WAAU,GAAX,EAAD,EAAkB,EAAC,WAAU,GAAX,EAAlB,EAAmC,EAAC,WAAU,GAAX,EAAnC,EAAoD,EAAC,WAAU,GAAX,EAApD,CAAzC,EAA+G,eAAe,SAASN,MAAT,CAAgBJ,CAAhB,EAAmB;AAAC,mBAAOA,EAAEtC,IAAF,CAAO,EAAP,CAAP;AAAmB,UAArK,EAhBa,EAiBb,EAAC,QAAQ,UAAT,EAAqB,WAAW,CAAC,mBAAD,CAAhC,EAAuD,eAAeF,EAAtE,EAjBa,EAkBb,EAAC,QAAQ,4BAAT,EAAuC,WAAW,CAAC,KAAD,CAAlD,EAlBa,EAmBb,EAAC,QAAQ,4BAAT,EAAuC,WAAW,CAAC,MAAD,CAAlD,EAnBa,EAoBb,EAAC,QAAQ,YAAT,EAAuB,WAAW,CAAC,UAAD,EAAa,GAAb,EAAkB,4BAAlB,CAAlC,EAAmF,eAAe;AAAA;AAAA,gBAAEmD,QAAF;AAAA,gBAAWC,CAAX;AAAA,gBAAaC,IAAb;;AAAA,mBAAsB,EAACpB,MAAK,YAAN,EAAoBkB,kBAApB,EAA8BE,UAA9B,EAAtB;AAAA,UAAlG,EApBa,EAqBb,EAAC,QAAQ,MAAT,EAAiB,WAAW,CAAC,MAAD,EAAS,MAAT,EAAiB,MAAjB,CAA5B,EAAsD,eAAe9B,KAArE,EArBa,EAsBb,EAAC,QAAQ,MAAT,EAAiB,WAAW,CAAC,MAAD,EAAS,MAAT,CAA5B,EAA8C,eAAeC,MAA7D,EAtBa,EAuBb,EAAC,QAAQ,eAAT,EAA0B,WAAW,CAAC,EAAC,WAAU,GAAX,EAAD,EAAkB,EAAC,WAAU,GAAX,EAAlB,EAAmC,EAAC,WAAU,GAAX,EAAnC,EAAoD,EAAC,WAAU,GAAX,EAApD,CAArC,EAA2G,eAAe,SAASoB,MAAT,CAAgBJ,CAAhB,EAAmB;AAAC,mBAAOA,EAAEtC,IAAF,CAAO,EAAP,CAAP;AAAmB,UAAjK,EAvBa,EAwBb,EAAC,QAAQ,MAAT,EAAiB,WAAW,CAAC,eAAD,CAA5B,EAA+C,eAAeqB,KAA9D,EAxBa,EAyBb,EAAC,QAAQ,eAAT,EAA0B,WAAW,CAAC,EAAC,WAAU,GAAX,EAAD,EAAkB,EAAC,WAAU,GAAX,EAAlB,EAAmC,EAAC,WAAU,GAAX,EAAnC,EAAoD,EAAC,WAAU,GAAX,EAApD,EAAqE,EAAC,WAAU,GAAX,EAArE,CAArC,EAA4H,eAAe,SAASqB,MAAT,CAAgBJ,CAAhB,EAAmB;AAAC,mBAAOA,EAAEtC,IAAF,CAAO,EAAP,CAAP;AAAmB,UAAlL,EAzBa,EA0Bb,EAAC,QAAQ,MAAT,EAAiB,WAAW,CAAC,eAAD,CAA5B,EAA+C,eAAesB,MAA9D,EA1Ba,EA2Bb,EAAC,QAAQ,aAAT,EAAwB,WAAW,CAAC,WAAD,CAAnC,EA3Ba,EA4Bb,EAAC,QAAQ,aAAT,EAAwB,WAAW,CAAC,aAAD,EAAgB,WAAhB,CAAnC,EAAiE,eAAe,SAASe,OAAT,CAAiBC,CAAjB,EAAoB;AAAC,mBAAOA,EAAE,CAAF,EAAKC,MAAL,CAAY,CAACD,EAAE,CAAF,CAAD,CAAZ,CAAP;AAA4B,UAAjI,EA5Ba,EA6Bb,EAAC,QAAQ,MAAT,EAAiB,WAAW,CAAC,aAAD,CAA5B,EAA6C,eAAe9B,KAAML,IAAIH,KAAK,EAAL,CAAJ,CAAN,EAAoBO,IAApB,CAA5D,EA7Ba,EA8Bb,EAAC,QAAQ,YAAT,EAAuB,WAAW,CAAC,QAAD,CAAlC,EA9Ba,EA+Bb,EAAC,QAAQ,YAAT,EAAuB,WAAW,CAAC,YAAD,EAAe,QAAf,CAAlC,EAA4D,eAAe,SAAS8B,OAAT,CAAiBC,CAAjB,EAAoB;AAAC,mBAAOA,EAAE,CAAF,EAAKC,MAAL,CAAY,CAACD,EAAE,CAAF,CAAD,CAAZ,CAAP;AAA4B,UAA5H,EA/Ba,EAgCb,EAAC,QAAQ,KAAT,EAAgB,WAAW,CAAC,YAAD,EAAe,MAAf,CAA3B,EAAmD,eAAe9B,KAAMD,IAAN,EAAWK,OAAOC,MAAM,MAAN,CAAP,CAAX,EAAiCb,KAAK,EAAL,CAAjC,EAA0CoB,KAA1C,CAAlE,EAhCa,EAiCb,EAAC,QAAQ,YAAT,EAAuB,WAAW,EAAlC,EAjCa,EAkCb,EAAC,QAAQ,YAAT,EAAuB,WAAW,CAAC,YAAD,EAAe,MAAf,CAAlC,EAA0D,eAAe,SAASiB,OAAT,CAAiBC,CAAjB,EAAoB;AAAC,mBAAOA,EAAE,CAAF,EAAKC,MAAL,CAAY,CAACD,EAAE,CAAF,CAAD,CAAZ,CAAP;AAA4B,UAA1H,EAlCa,EAmCb,EAAC,QAAQ,KAAT,EAAgB,WAAW,CAAC,EAAC,WAAU,GAAX,EAAD,EAAkB,YAAlB,EAAgC,EAAC,WAAU,GAAX,EAAhC,CAA3B,EAA6E,eAAe9B,KAAMH,IAAI,CAAJ,CAAN,EAAaL,KAAK,EAAL,CAAb,CAA5F,EAnCa,EAoCb,EAAC,QAAQ,aAAT,EAAwB,WAAW,EAAnC,EApCa,EAqCb,EAAC,QAAQ,aAAT,EAAwB,WAAW,CAAC,aAAD,EAAgB,OAAhB,CAAnC,EAA6D,eAAe,SAASqC,OAAT,CAAiBC,CAAjB,EAAoB;AAAC,mBAAOA,EAAE,CAAF,EAAKC,MAAL,CAAY,CAACD,EAAE,CAAF,CAAD,CAAZ,CAAP;AAA4B,UAA7H,EArCa,EAsCb,EAAC,QAAQ,MAAT,EAAiB,WAAW,CAAC,aAAD,CAA5B,EAtCa,EAuCb,EAAC,QAAQ,eAAT,EAA0B,WAAW,CAAC,EAAC,WAAU,GAAX,EAAD,EAAkB,EAAC,WAAU,GAAX,EAAlB,EAAmC,EAAC,WAAU,GAAX,EAAnC,CAArC,EAA0F,eAAe,SAASI,MAAT,CAAgBJ,CAAhB,EAAmB;AAAC,mBAAOA,EAAEtC,IAAF,CAAO,EAAP,CAAP;AAAmB,UAAhJ,EAvCa,EAwCb,EAAC,QAAQ,MAAT,EAAiB,WAAW,CAAC,eAAD,CAA5B,EAxCa,EAyCb,EAAC,QAAQ,eAAT,EAA0B,WAAW,CAAC,EAAC,WAAU,GAAX,EAAD,EAAkB,EAAC,WAAU,GAAX,EAAlB,EAAmC,EAAC,WAAU,GAAX,EAAnC,EAAoD,EAAC,WAAU,GAAX,EAApD,EAAqE,EAAC,WAAU,GAAX,EAArE,EAAsF,EAAC,WAAU,GAAX,EAAtF,EAAuG,EAAC,WAAU,GAAX,EAAvG,CAArC,EAA8J,eAAe,SAAS0C,MAAT,CAAgBJ,CAAhB,EAAmB;AAAC,mBAAOA,EAAEtC,IAAF,CAAO,EAAP,CAAP;AAAmB,UAApN,EAzCa,EA0Cb,EAAC,QAAQ,MAAT,EAAiB,WAAW,CAAC,eAAD,CAA5B,EA1Ca,EA2Cb,EAAC,QAAQ,eAAT,EAA0B,WAAW,CAAC,EAAC,WAAU,GAAX,EAAD,EAAkB,EAAC,WAAU,GAAX,EAAlB,EAAmC,EAAC,WAAU,GAAX,EAAnC,EAAoD,EAAC,WAAU,GAAX,EAApD,EAAqE,EAAC,WAAU,GAAX,EAArE,EAAsF,EAAC,WAAU,GAAX,EAAtF,CAArC,EAA6I,eAAe,SAAS0C,MAAT,CAAgBJ,CAAhB,EAAmB;AAAC,mBAAOA,EAAEtC,IAAF,CAAO,EAAP,CAAP;AAAmB,UAAnM,EA3Ca,EA4Cb,EAAC,QAAQ,MAAT,EAAiB,WAAW,CAAC,eAAD,CAA5B,EA5Ca,EA6Cb,EAAC,QAAQ,eAAT,EAA0B,WAAW,CAAC,EAAC,WAAU,GAAX,EAAD,EAAkB,EAAC,WAAU,GAAX,EAAlB,EAAmC,EAAC,WAAU,GAAX,EAAnC,EAAoD,EAAC,WAAU,GAAX,EAApD,CAArC,EAA2G,eAAe,SAAS0C,MAAT,CAAgBJ,CAAhB,EAAmB;AAAC,mBAAOA,EAAEtC,IAAF,CAAO,EAAP,CAAP;AAAmB,UAAjK,EA7Ca,EA8Cb,EAAC,QAAQ,MAAT,EAAiB,WAAW,CAAC,eAAD,CAA5B,EA9Ca,EA+Cb,EAAC,QAAQ,UAAT,EAAqB,WAAW,CAAC,KAAD,CAAhC,EA/Ca,EAgDb,EAAC,QAAQ,UAAT,EAAqB,WAAW,CAAC,UAAD,EAAa,KAAb,CAAhC,EAAqD,eAAe,SAASqC,OAAT,CAAiBC,CAAjB,EAAoB;AAAC,mBAAOA,EAAE,CAAF,EAAKC,MAAL,CAAY,CAACD,EAAE,CAAF,CAAD,CAAZ,CAAP;AAA4B,UAArH,EAhDa,EAiDb,EAAC,QAAQ,GAAT,EAAc,WAAW,CAAC,UAAD,CAAzB,EAAuC,eAAef,OAAtD,EAjDa,EAkDb,EAAC,QAAQ,WAAT,EAAsB,WAAW,EAAjC,EAlDa,EAmDb,EAAC,QAAQ,WAAT,EAAsB,WAAW,CAAC,WAAD,EAAc,MAAd,CAAjC,EAAwD,eAAe,SAASc,OAAT,CAAiBC,CAAjB,EAAoB;AAAC,mBAAOA,EAAE,CAAF,EAAKC,MAAL,CAAY,CAACD,EAAE,CAAF,CAAD,CAAZ,CAAP;AAA4B,UAAxH,EAnDa,EAoDb,EAAC,QAAQ,IAAT,EAAe,WAAW,CAAC,WAAD,CAA1B,EAAyC,eAAef,OAAxD,EApDa,EAqDb,EAAC,QAAQ,WAAT,EAAsB,WAAW,CAAC,EAAC,WAAU,IAAX,EAAD,CAAjC,EAAqD,eAAezB,EAApE,EArDa,EAsDb,EAAC,QAAQ,WAAT,EAAsB,WAAW,EAAjC,EAAqC,eAAe,qBAASwC,CAAT,EAAY;AAAC,mBAAO,IAAP;AAAa,UAA9E,EAtDa,EAuDb,EAAC,QAAQ,IAAT,EAAe,WAAW,CAAC,WAAD,EAAc,EAAC,WAAU,IAAX,EAAd,CAA1B,EAA2D,eAAef,OAA1E,EAvDa,CAFH;AA2DV6B,mBAAa;AA3DH,IAAd;AA6DA,OAAI,OAAOC,MAAP,KAAkB,WAAlB,IAAgC,OAAOA,OAAOC,OAAd,KAA0B,WAA9D,EAA2E;AACxED,aAAOC,OAAP,GAAiBrB,OAAjB;AACF,IAFD,MAEO;AACJsB,aAAOtB,OAAP,GAAiBA,OAAjB;AACF;AACA,CAtFD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACluEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKtmFA;AACA;;;;AAIA,IAAM+C,UAAUxB,QAAQ,kBAAR,CAAhB;AACA,IAAM0C,oOAAN;AAIAhF,QAAQD,GAAR,CAAY+D,QAAQkB,OAAR,CAAZ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3lJA;;eAE2D1C,QAAQ,WAAR;IAAnDrD,eAAAA;IAAKsD,mBAAAA;IAASC,gBAAAA;IAAMC,oBAAAA;IAAUnD,gBAAAA;IAAM+B,kBAAAA;IAAQqB,cAAAA;;AAEpD,IAAMC,UAAU;AACZC,UAAM,EADM;AAEVC,YAAQ,EAFE;AAGVC,aAAS;AAHC,CAAhB;;AAMA,IAAMC,UAAU,SAAVA,OAAU;AAAA,QAAGtB,IAAH,QAAGA,IAAH;AAAA,sBAAuBA,IAAvB;AAAA,CAAhB;AACA,IAAMuB,UAAU,SAAVA,OAAU;AAAA,QAAGpB,IAAH,SAAGA,IAAH;AAAA,+BAA+BA,IAA/B;AAAA,CAAhB;AACA,IAAMqB,cAAc,SAAdA,WAAc;AAAA,kBAAiBC,OAAjB;AAAA,CAApB;AACA;AACA;AACA,IAAMC,kBAAkB,SAAlBA,eAAkB,CAACC,KAAD;AAAA,mCAAkCA,MAAMtE,IAAN,CAAW,IAAX,CAAlC;AAAA,CAAxB;AACA,IAAMuE,gBAAgB,SAAhBA,aAAgB;AAAA,WAAQ,iBAAkB;AAAA,YAAfC,GAAe,SAAfA,GAAe;AAAA,YAAVxB,GAAU,SAAVA,GAAU;;AAC5C,YAAIwB,GAAJ,EAAS;AACL,0BAAWxB,GAAX;AACH;AACD,eAAO,MAAMyB,KAAK/D,MAAL,CAAY,UAACgE,GAAD,EAAM3E,CAAN;AAAA,mBAAY2E,IAAIC,OAAJ,CAAY5E,CAAZ,EAAeoE,YAAYpE,CAAZ,CAAf,CAAZ;AAAA,SAAZ,EAAwDiD,GAAxD,CAAN,GAAqE,GAA5E;AAGH,KAPqB;AAAA,CAAtB;AAQA,IAAM4B,iBAAiB,SAAjBA,cAAiB,OAAQ;AAC3B,QAAMC,MAAMN,cAAcE,IAAd,CAAZ;AACA,WAAO,eAAO;AACV,gBAAQK,IAAI/C,IAAZ;AACI,iBAAK,QAAL;AACI,uBAAO8C,IAAIC,GAAJ,CAAP;AACJ,iBAAK,SAAL;AACA,iBAAK,SAAL;AACA;AACI,uBAAOA,IAAI9B,GAAX;AANR;AAQH,KATD;AAUH,CAZD;AAaA,IAAM+B,kBAAkB,SAAlBA,eAAkB;AAAA,WAAQ;AAAA,eAAK,QAAQ5E,IAAIyE,eAAeH,IAAf,CAAJ,EAA0B1E,CAA1B,EAA6BC,IAA7B,CAAkC,KAAlC,CAAb;AAAA,KAAR;AAAA,CAAxB;;AAEA,IAAMgF,UAAU,SAAVA,OAAU,CAACC,KAAD,EAAW;;AAEvB,QAAMC,UAAW/E,IAAIuD,KAAK,MAAL,CAAJ,EAAkBuB,KAAlB,CAAjB,CAFuB,CAEqB;;AAE5C,QAAME,oBACF,SADEA,iBACF,OAAQ;AAAA,YAEIvC,IAFJ,GAEuBwC,IAFvB,CAEIxC,IAFJ;AAAA,YAEUC,QAFV,GAEuBuC,IAFvB,CAEUvC,QAFV;;AAGJ,YAAMd,OAAO0B,QAAQZ,QAAR,CAAb;AACA,YAAME,WAAW5C,IAAI;AAAA,gBAAG6C,GAAH,SAAGA,GAAH;AAAA,mBAAc,EAAEjB,UAAF,EAAQiB,QAAR,EAAd;AAAA,SAAJ,EAAkCJ,KAAKG,QAAvC,CAAjB;AACA7B,gBAAQD,GAAR,CAAY8B,QAAZ;AACA,eAAO,CACHkB,QAAQmB,IAAR,CADG,EAEDlB,QAAQtB,IAAR,CAFC,EAGDmC,gBAAgBG,OAAhB,EAAyBnC,QAAzB,CAHC,CAAP;AAKH,KAZL;;AAeA,WAAOvC,KACN,CACKL,IAAIgF,iBAAJ,CADL,EAEOhF,IAAIwD,SAAS,EAAT,CAAJ,CAFP,EAGOA,SAAS,KAAT,CAHP,EAIOpB,OAAOqB,EAAP,SAAgBS,gBAAgBa,OAAhB,CAAhB,SAJP,EAKO3C,2BALP,CADM,EAOJ0C,KAPI,CAAP;AAQH,CA3BD;;AA8BA5B,OAAOC,OAAP,GAAiB0B,OAAjB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrEA,IAAMK,UAAU,SAAVA,OAAU;AAAA,SAAKnE,QAAQoE,GAAR,CAAYvF,CAAZ,EAAe,EAACwF,OAAO,CAAR,EAAWC,QAAQ,IAAnB,EAAf,CAAL;AAAA,CAAhB;;AAEAnC,OAAOC,OAAP,GAAgB,EAAC+B,gBAAD,EAAhB;;;;;;;;ACFA;;AAEA,IAAMI,UAAUjC,QAAQ,SAAR,CAAhB;AACA,IAAMvB,UAAUuB,QAAQ,cAAR,CAAhB;AACA,IAAMkC,WAAWlC,QAAQ,YAAR,CAAjB;;eACoBA,QAAQ,SAAR;IAAZ6B,mBAAAA;;AAER;;;AACA,IAAMM,SAAS,IAAIF,QAAQG,MAAZ,CAAmBH,QAAQI,OAAR,CAAgBC,YAAhB,CAA6B7D,OAA7B,CAAnB,CAAf;;AAEA;AACAoB,OAAOC,OAAP,GAAiB,UAACyC,OAAD,EAAa;;AAE1BJ,WAAOK,IAAP,CAAYD,OAAZ;AACA;AACAV,YAAQM,OAAOM,OAAf,EAJ0B,CAID;AACzB,WAAOP,SAASC,OAAOM,OAAP,CAAe,CAAf,CAAT,CAAP;AACH,CAND","file":"pages.5d2f2f57.map","sourceRoot":"../pages","sourcesContent":["(function(root, factory) {\n    if (typeof module === 'object' && module.exports) {\n        module.exports = factory();\n    } else {\n        root.nearley = factory();\n    }\n}(this, function() {\n\n    function Rule(name, symbols, postprocess) {\n        this.id = ++Rule.highestId;\n        this.name = name;\n        this.symbols = symbols;        // a list of literal | regex class | nonterminal\n        this.postprocess = postprocess;\n        return this;\n    }\n    Rule.highestId = 0;\n\n    Rule.prototype.toString = function(withCursorAt) {\n        function stringifySymbolSequence (e) {\n            return e.literal ? JSON.stringify(e.literal) :\n                   e.type ? '%' + e.type : e.toString();\n        }\n        var symbolSequence = (typeof withCursorAt === \"undefined\")\n                             ? this.symbols.map(stringifySymbolSequence).join(' ')\n                             : (   this.symbols.slice(0, withCursorAt).map(stringifySymbolSequence).join(' ')\n                                 + \"  \"\n                                 + this.symbols.slice(withCursorAt).map(stringifySymbolSequence).join(' ')     );\n        return this.name + \"  \" + symbolSequence;\n    }\n\n\n    // a State is a rule at a position from a given starting point in the input stream (reference)\n    function State(rule, dot, reference, wantedBy) {\n        this.rule = rule;\n        this.dot = dot;\n        this.reference = reference;\n        this.data = [];\n        this.wantedBy = wantedBy;\n        this.isComplete = this.dot === rule.symbols.length;\n    }\n\n    State.prototype.toString = function() {\n        return \"{\" + this.rule.toString(this.dot) + \"}, from: \" + (this.reference || 0);\n    };\n\n    State.prototype.nextState = function(child) {\n        var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);\n        state.left = this;\n        state.right = child;\n        if (state.isComplete) {\n            state.data = state.build();\n        }\n        return state;\n    };\n\n    State.prototype.build = function() {\n        var children = [];\n        var node = this;\n        do {\n            children.push(node.right.data);\n            node = node.left;\n        } while (node.left);\n        children.reverse();\n        return children;\n    };\n\n    State.prototype.finish = function() {\n        if (this.rule.postprocess) {\n            this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);\n        }\n    };\n\n\n    function Column(grammar, index) {\n        this.grammar = grammar;\n        this.index = index;\n        this.states = [];\n        this.wants = {}; // states indexed by the non-terminal they expect\n        this.scannable = []; // list of states that expect a token\n        this.completed = {}; // states that are nullable\n    }\n\n\n    Column.prototype.process = function(nextColumn) {\n        var states = this.states;\n        var wants = this.wants;\n        var completed = this.completed;\n\n        for (var w = 0; w < states.length; w++) { // nb. we push() during iteration\n            var state = states[w];\n\n            if (state.isComplete) {\n                state.finish();\n                if (state.data !== Parser.fail) {\n                    // complete\n                    var wantedBy = state.wantedBy;\n                    for (var i = wantedBy.length; i--; ) { // this line is hot\n                        var left = wantedBy[i];\n                        this.complete(left, state);\n                    }\n\n                    // special-case nullables\n                    if (state.reference === this.index) {\n                        // make sure future predictors of this rule get completed.\n                        var exp = state.rule.name;\n                        (this.completed[exp] = this.completed[exp] || []).push(state);\n                    }\n                }\n\n            } else {\n                // queue scannable states\n                var exp = state.rule.symbols[state.dot];\n                if (typeof exp !== 'string') {\n                    this.scannable.push(state);\n                    continue;\n                }\n\n                // predict\n                if (wants[exp]) {\n                    wants[exp].push(state);\n\n                    if (completed.hasOwnProperty(exp)) {\n                        var nulls = completed[exp];\n                        for (var i = 0; i < nulls.length; i++) {\n                            var right = nulls[i];\n                            this.complete(state, right);\n                        }\n                    }\n                } else {\n                    wants[exp] = [state];\n                    this.predict(exp);\n                }\n            }\n        }\n    }\n\n    Column.prototype.predict = function(exp) {\n        var rules = this.grammar.byName[exp] || [];\n\n        for (var i = 0; i < rules.length; i++) {\n            var r = rules[i];\n            var wantedBy = this.wants[exp];\n            var s = new State(r, 0, this.index, wantedBy);\n            this.states.push(s);\n        }\n    }\n\n    Column.prototype.complete = function(left, right) {\n        var copy = left.nextState(right);\n        this.states.push(copy);\n    }\n\n\n    function Grammar(rules, start) {\n        this.rules = rules;\n        this.start = start || this.rules[0].name;\n        var byName = this.byName = {};\n        this.rules.forEach(function(rule) {\n            if (!byName.hasOwnProperty(rule.name)) {\n                byName[rule.name] = [];\n            }\n            byName[rule.name].push(rule);\n        });\n    }\n\n    // So we can allow passing (rules, start) directly to Parser for backwards compatibility\n    Grammar.fromCompiled = function(rules, start) {\n        var lexer = rules.Lexer;\n        if (rules.ParserStart) {\n          start = rules.ParserStart;\n          rules = rules.ParserRules;\n        }\n        var rules = rules.map(function (r) { return (new Rule(r.name, r.symbols, r.postprocess)); });\n        var g = new Grammar(rules, start);\n        g.lexer = lexer; // nb. storing lexer on Grammar is iffy, but unavoidable\n        return g;\n    }\n\n\n    function StreamLexer() {\n      this.reset(\"\");\n    }\n\n    StreamLexer.prototype.reset = function(data, state) {\n        this.buffer = data;\n        this.index = 0;\n        this.line = state ? state.line : 1;\n        this.lastLineBreak = state ? -state.col : 0;\n    }\n\n    StreamLexer.prototype.next = function() {\n        if (this.index < this.buffer.length) {\n            var ch = this.buffer[this.index++];\n            if (ch === '\\n') {\n              this.line += 1;\n              this.lastLineBreak = this.index;\n            }\n            return {value: ch};\n        }\n    }\n\n    StreamLexer.prototype.save = function() {\n      return {\n        line: this.line,\n        col: this.index - this.lastLineBreak,\n      }\n    }\n\n    StreamLexer.prototype.formatError = function(token, message) {\n        // nb. this gets called after consuming the offending token,\n        // so the culprit is index-1\n        var buffer = this.buffer;\n        if (typeof buffer === 'string') {\n            var nextLineBreak = buffer.indexOf('\\n', this.index);\n            if (nextLineBreak === -1) nextLineBreak = buffer.length;\n            var line = buffer.substring(this.lastLineBreak, nextLineBreak)\n            var col = this.index - this.lastLineBreak;\n            message += \" at line \" + this.line + \" col \" + col + \":\\n\\n\";\n            message += \"  \" + line + \"\\n\"\n            message += \"  \" + Array(col).join(\" \") + \"^\"\n            return message;\n        } else {\n            return message + \" at index \" + (this.index - 1);\n        }\n    }\n\n\n    function Parser(rules, start, options) {\n        if (rules instanceof Grammar) {\n            var grammar = rules;\n            var options = start;\n        } else {\n            var grammar = Grammar.fromCompiled(rules, start);\n        }\n        this.grammar = grammar;\n\n        // Read options\n        this.options = {\n            keepHistory: false,\n            lexer: grammar.lexer || new StreamLexer,\n        };\n        for (var key in (options || {})) {\n            this.options[key] = options[key];\n        }\n\n        // Setup lexer\n        this.lexer = this.options.lexer;\n        this.lexerState = undefined;\n\n        // Setup a table\n        var column = new Column(grammar, 0);\n        var table = this.table = [column];\n\n        // I could be expecting anything.\n        column.wants[grammar.start] = [];\n        column.predict(grammar.start);\n        // TODO what if start rule is nullable?\n        column.process();\n        this.current = 0; // token index\n    }\n\n    // create a reserved token for indicating a parse fail\n    Parser.fail = {};\n\n    Parser.prototype.feed = function(chunk) {\n        var lexer = this.lexer;\n        lexer.reset(chunk, this.lexerState);\n\n        var token;\n        while (token = lexer.next()) {\n            // We add new states to table[current+1]\n            var column = this.table[this.current];\n\n            // GC unused states\n            if (!this.options.keepHistory) {\n                delete this.table[this.current - 1];\n            }\n\n            var n = this.current + 1;\n            var nextColumn = new Column(this.grammar, n);\n            this.table.push(nextColumn);\n\n            // Advance all tokens that expect the symbol\n            var literal = token.value;\n            var value = lexer.constructor === StreamLexer ? token.value : token;\n            var scannable = column.scannable;\n            for (var w = scannable.length; w--; ) {\n                var state = scannable[w];\n                var expect = state.rule.symbols[state.dot];\n                // Try to consume the token\n                // either regex or literal\n                if (expect.test ? expect.test(value) :\n                    expect.type ? expect.type === token.type\n                                : expect.literal === literal) {\n                    // Add it\n                    var next = state.nextState({data: value, token: token, isToken: true, reference: n - 1});\n                    nextColumn.states.push(next);\n                }\n            }\n\n            // Next, for each of the rules, we either\n            // (a) complete it, and try to see if the reference row expected that\n            //     rule\n            // (b) predict the next nonterminal it expects by adding that\n            //     nonterminal's start state\n            // To prevent duplication, we also keep track of rules we have already\n            // added\n\n            nextColumn.process();\n\n            // If needed, throw an error:\n            if (nextColumn.states.length === 0) {\n                // No states at all! This is not good.\n                var message = this.lexer.formatError(token, \"invalid syntax\") + \"\\n\";\n                message += \"Unexpected \" + (token.type ? token.type + \" token: \" : \"\");\n                message += JSON.stringify(token.value !== undefined ? token.value : token) + \"\\n\";\n                var err = new Error(message);\n                err.offset = this.current;\n                err.token = token;\n                throw err;\n            }\n\n            // maybe save lexer state\n            if (this.options.keepHistory) {\n              column.lexerState = lexer.save()\n            }\n\n            this.current++;\n        }\n        if (column) {\n          this.lexerState = lexer.save()\n        }\n\n        // Incrementally keep track of results\n        this.results = this.finish();\n\n        // Allow chaining, for whatever it's worth\n        return this;\n    };\n\n    Parser.prototype.save = function() {\n        var column = this.table[this.current];\n        column.lexerState = this.lexerState;\n        return column;\n    };\n\n    Parser.prototype.restore = function(column) {\n        var index = column.index;\n        this.current = index;\n        this.table[index] = column;\n        this.table.splice(index + 1);\n        this.lexerState = column.lexerState;\n\n        // Incrementally keep track of results\n        this.results = this.finish();\n    };\n\n    // nb. deprecated: use save/restore instead!\n    Parser.prototype.rewind = function(index) {\n        if (!this.options.keepHistory) {\n            throw new Error('set option `keepHistory` to enable rewinding')\n        }\n        // nb. recall column (table) indicies fall between token indicies.\n        //        col 0   --   token 0   --   col 1\n        this.restore(this.table[index]);\n    };\n\n    Parser.prototype.finish = function() {\n        // Return the possible parsings\n        var considerations = [];\n        var start = this.grammar.start;\n        var column = this.table[this.table.length - 1]\n        column.states.forEach(function (t) {\n            if (t.rule.name === start\n                    && t.dot === t.rule.symbols.length\n                    && t.reference === 0\n                    && t.data !== Parser.fail) {\n                considerations.push(t);\n            }\n        });\n        return considerations.map(function(c) {return c.data; });\n    };\n\n    return {\n        Parser: Parser,\n        Grammar: Grammar,\n        Rule: Rule,\n    };\n\n}));\n","// Generated automatically by nearley, version 2.13.0\n// http://github.com/Hardmath123/nearley\n(function () {\nfunction id(x) { return x[0]; }\n\n\tconst join = sep => arr => arr.join(sep)\n\tconst map = fn => arr => arr.map(fn)\n\tconst nth = pos => arr => arr[pos]\n\tconst head = arr => arr[0]\n\tconst pipe = ( ...fns ) => x => fns.reduce((x,f) => f(x) , x)\n\tconst filter = fn => arr => arr.filter(fn)\n\tconst predR = regex => x => regex.test(x)\n\tconst notnull = x => x != null\n\tconst log = x => console.info(x) || x\n\tconst toInt = x => x | 0\n\tconst _true = () => true\n\tconst _false = () => false\n\tconst nothing = d => null\n\tconst compact = filter(notnull)\n\tconst oBind = base => ext => Object.assign({}, base, ext)\n\tconst option = oBind({type:'option'})\n\tconst push = arr => x => arr.push(x) && arr\nvar grammar = {\n    Lexer: undefined,\n    ParserRules: [\n    {\"name\": \"PROGRAM$ebnf$1\", \"symbols\": []},\n    {\"name\": \"PROGRAM$ebnf$1$subexpression$1\", \"symbols\": [\"ln\", \"LINE\"], \"postprocess\": nth(1)},\n    {\"name\": \"PROGRAM$ebnf$1\", \"symbols\": [\"PROGRAM$ebnf$1\", \"PROGRAM$ebnf$1$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"PROGRAM\", \"symbols\": [\"LINE\", \"PROGRAM$ebnf$1\"], \"postprocess\": ([a,b]) => [a,...b]},\n    {\"name\": \"LINE$string$1\", \"symbols\": [{\"literal\":\":\"}, {\"literal\":\":\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"LINE\", \"symbols\": [\"NAME\", \"_\", {\"literal\":\"=\"}, \"_\", \"DECLARATION\", \"_\", \"LINE$string$1\", \"_\", \"TYPE\", \"__\"], \"postprocess\": ([[name],,,, body,,,,[coerceTo] ]) => ({type:'declaration', name, body, coerceTo })},\n    {\"name\": \"NAME\", \"symbols\": [\"WORD\"]},\n    {\"name\": \"DECLARATION$ebnf$1\", \"symbols\": []},\n    {\"name\": \"DECLARATION$ebnf$1\", \"symbols\": [\"DECLARATION$ebnf$1\", \"DEFAULT\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"DECLARATION\", \"symbols\": [\"WORD\", \"DECLARATION$ebnf$1\"], \"postprocess\": ([path, defaults]) => ({ path, defaults })},\n    {\"name\": \"DEFAULT\", \"symbols\": [\"_\", {\"literal\":\"|\"}, \"_\", \"VALUE\"], \"postprocess\": pipe(nth(3),([val]) => option({val}))},\n    {\"name\": \"VALUE\", \"symbols\": [\"BOOL\"]},\n    {\"name\": \"VALUE\", \"symbols\": [\"NUM\"]},\n    {\"name\": \"VALUE\", \"symbols\": [\"STR\"]},\n    {\"name\": \"VALUE\", \"symbols\": [\"EXPRESSION\"]},\n    {\"name\": \"OPERATOR$string$1\", \"symbols\": [{\"literal\":\"f\"}, {\"literal\":\"i\"}, {\"literal\":\"l\"}, {\"literal\":\"e\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"OPERATOR\", \"symbols\": [\"OPERATOR$string$1\"], \"postprocess\": id},\n    {\"name\": \"EXPRESSION$subexpression$1\", \"symbols\": [\"STR\"]},\n    {\"name\": \"EXPRESSION$subexpression$1\", \"symbols\": [\"WORD\"]},\n    {\"name\": \"EXPRESSION\", \"symbols\": [\"OPERATOR\", \"_\", \"EXPRESSION$subexpression$1\"], \"postprocess\": ([operator,_,args])=>({type:'expression', operator, args })},\n    {\"name\": \"BOOL\", \"symbols\": [/[Yy]/, /[eE]/, /[sS]/], \"postprocess\": _true},\n    {\"name\": \"BOOL\", \"symbols\": [/[nN]/, /[oO]/], \"postprocess\": _false},\n    {\"name\": \"BOOL$string$1\", \"symbols\": [{\"literal\":\"t\"}, {\"literal\":\"r\"}, {\"literal\":\"u\"}, {\"literal\":\"e\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"BOOL\", \"symbols\": [\"BOOL$string$1\"], \"postprocess\": _true},\n    {\"name\": \"BOOL$string$2\", \"symbols\": [{\"literal\":\"f\"}, {\"literal\":\"a\"}, {\"literal\":\"l\"}, {\"literal\":\"s\"}, {\"literal\":\"e\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"BOOL\", \"symbols\": [\"BOOL$string$2\"], \"postprocess\": _false},\n    {\"name\": \"WORD$ebnf$1\", \"symbols\": [/[a-zA-Z_]/]},\n    {\"name\": \"WORD$ebnf$1\", \"symbols\": [\"WORD$ebnf$1\", /[a-zA-Z_]/], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"WORD\", \"symbols\": [\"WORD$ebnf$1\"], \"postprocess\": pipe( map(join('')),head)},\n    {\"name\": \"NUM$ebnf$1\", \"symbols\": [/[0-9_]/]},\n    {\"name\": \"NUM$ebnf$1\", \"symbols\": [\"NUM$ebnf$1\", /[0-9_]/], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"NUM\", \"symbols\": [\"NUM$ebnf$1\", \"UNIT\"], \"postprocess\": pipe( head,filter(predR(/[^_]/)),join(''),toInt)},\n    {\"name\": \"STR$ebnf$1\", \"symbols\": []},\n    {\"name\": \"STR$ebnf$1\", \"symbols\": [\"STR$ebnf$1\", /[^']/], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"STR\", \"symbols\": [{\"literal\":\"'\"}, \"STR$ebnf$1\", {\"literal\":\"'\"}], \"postprocess\": pipe( nth(1),join(''))},\n    {\"name\": \"UNIT$ebnf$1\", \"symbols\": []},\n    {\"name\": \"UNIT$ebnf$1\", \"symbols\": [\"UNIT$ebnf$1\", /[a-z]/], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"UNIT\", \"symbols\": [\"UNIT$ebnf$1\"]},\n    {\"name\": \"TYPE$string$1\", \"symbols\": [{\"literal\":\"I\"}, {\"literal\":\"n\"}, {\"literal\":\"t\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"TYPE\", \"symbols\": [\"TYPE$string$1\"]},\n    {\"name\": \"TYPE$string$2\", \"symbols\": [{\"literal\":\"B\"}, {\"literal\":\"o\"}, {\"literal\":\"o\"}, {\"literal\":\"l\"}, {\"literal\":\"e\"}, {\"literal\":\"a\"}, {\"literal\":\"n\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"TYPE\", \"symbols\": [\"TYPE$string$2\"]},\n    {\"name\": \"TYPE$string$3\", \"symbols\": [{\"literal\":\"S\"}, {\"literal\":\"t\"}, {\"literal\":\"r\"}, {\"literal\":\"i\"}, {\"literal\":\"n\"}, {\"literal\":\"g\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"TYPE\", \"symbols\": [\"TYPE$string$3\"]},\n    {\"name\": \"TYPE$string$4\", \"symbols\": [{\"literal\":\"J\"}, {\"literal\":\"S\"}, {\"literal\":\"O\"}, {\"literal\":\"N\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"TYPE\", \"symbols\": [\"TYPE$string$4\"]},\n    {\"name\": \"_$ebnf$1\", \"symbols\": [/[ ]/]},\n    {\"name\": \"_$ebnf$1\", \"symbols\": [\"_$ebnf$1\", /[ ]/], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"_\", \"symbols\": [\"_$ebnf$1\"], \"postprocess\": nothing},\n    {\"name\": \"__$ebnf$1\", \"symbols\": []},\n    {\"name\": \"__$ebnf$1\", \"symbols\": [\"__$ebnf$1\", /[\\s]/], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"__\", \"symbols\": [\"__$ebnf$1\"], \"postprocess\": nothing},\n    {\"name\": \"ln$ebnf$1\", \"symbols\": [{\"literal\":\"\\r\"}], \"postprocess\": id},\n    {\"name\": \"ln$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"ln\", \"symbols\": [\"ln$ebnf$1\", {\"literal\":\"\\n\"}], \"postprocess\": nothing}\n]\n  , ParserStart: \"PROGRAM\"\n}\nif (typeof module !== 'undefined'&& typeof module.exports !== 'undefined') {\n   module.exports = grammar;\n} else {\n   window.grammar = grammar;\n}\n})();\n","/*\n        @@@@@@@            @@@@@@@         @@\n      @@       @@        @@       @@      @@@\n    @@   @@@ @@  @@    @@   @@@ @@  @@   @@@@@@ @@   @@@  @@ @@@      @@@@\n   @@  @@   @@@   @@  @@  @@   @@@   @@   @@@   @@   @@@  @@@   @@  @@@   @@\n   @@  @@   @@@   @@  @@  @@   @@@   @@   @@@   @@   @@@  @@@   @@  @@@@@@@@\n   @@  @@   @@@  @@   @@  @@   @@@  @@    @@@   @@   @@@  @@@   @@  @@@\n    @@   @@@ @@@@@     @@   @@@ @@@@@      @@@    @@@ @@  @@@@@@      @@@@@\n      @@                 @@                           @@  @@\n        @@@@@@@            @@@@@@@               @@@@@    @@\n                                                          */\n//. # sanctuary-type-identifiers\n//.\n//. A type is a set of values. Boolean, for example, is the type comprising\n//. `true` and `false`. A value may be a member of multiple types (`42` is a\n//. member of Number, PositiveNumber, Integer, and many other types).\n//.\n//. In certain situations it is useful to divide JavaScript values into\n//. non-overlapping types. The language provides two constructs for this\n//. purpose: the [`typeof`][1] operator and [`Object.prototype.toString`][2].\n//. Each has pros and cons, but neither supports user-defined types.\n//.\n//. This package specifies an [algorithm][3] for deriving a _type identifier_\n//. from any JavaScript value, and exports an implementation of the algorithm.\n//. Authors of algebraic data types may follow this specification in order to\n//. make their data types compatible with the algorithm.\n//.\n//. ### Algorithm\n//.\n//. 1.  Take any JavaScript value `x`.\n//.\n//. 2.  If `x` is `null` or `undefined`, go to step 6.\n//.\n//. 3.  If `x.constructor` evaluates to `null` or `undefined`, go to step 6.\n//.\n//. 4.  If `x.constructor.prototype === x`, go to step 6. This check prevents a\n//.     prototype object from being considered a member of its associated type.\n//.\n//. 5.  If `typeof x.constructor['@@type']` evaluates to `'string'`, return\n//.     the value of `x.constructor['@@type']`.\n//.\n//. 6.  Return the [`Object.prototype.toString`][2] representation of `x`\n//.     without the leading `'[object '` and trailing `']'`.\n//.\n//. ### Compatibility\n//.\n//. For an algebraic data type to be compatible with the [algorithm][3]:\n//.\n//.   - every member of the type must have a `constructor` property pointing\n//.     to an object known as the _type representative_;\n//.\n//.   - the type representative must have a `@@type` property; and\n//.\n//.   - the type representative's `@@type` property (the _type identifier_)\n//.     must be a string primitive, ideally `'<npm-package-name>/<type-name>'`.\n//.\n//. For example:\n//.\n//. ```javascript\n//. //  Identity :: a -> Identity a\n//. function Identity(x) {\n//.   if (!(this instanceof Identity)) return new Identity(x);\n//.   this.value = x;\n//. }\n//.\n//. Identity['@@type'] = 'my-package/Identity';\n//. ```\n//.\n//. Note that by using a constructor function the `constructor` property is set\n//. implicitly for each value created. Constructor functions are convenient for\n//. this reason, but are not required. This definition is also valid:\n//.\n//. ```javascript\n//. //  IdentityTypeRep :: TypeRep Identity\n//. var IdentityTypeRep = {\n//.   '@@type': 'my-package/Identity'\n//. };\n//.\n//. //  Identity :: a -> Identity a\n//. function Identity(x) {\n//.   return {constructor: IdentityTypeRep, value: x};\n//. }\n//. ```\n//.\n//. ### Usage\n//.\n//. ```javascript\n//. var Identity = require('my-package').Identity;\n//. var type = require('sanctuary-type-identifiers');\n//.\n//. type(null);         // => 'Null'\n//. type(true);         // => 'Boolean'\n//. type([1, 2, 3]);    // => 'Array'\n//. type(Identity);     // => 'Function'\n//. type(Identity(0));  // => 'my-package/Identity'\n//. ```\n//.\n//.\n//. [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof\n//. [2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\n//. [3]: #algorithm\n\n(function(f) {\n\n  'use strict';\n\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = f();\n  } else if (typeof define === 'function' && define.amd != null) {\n    define([], f);\n  } else {\n    self.sanctuaryTypeIdentifiers = f();\n  }\n\n}(function() {\n\n  'use strict';\n\n  //  $$type :: String\n  var $$type = '@@type';\n\n  //  type :: Any -> String\n  function type(x) {\n    return x != null &&\n           x.constructor != null &&\n           x.constructor.prototype !== x &&\n           typeof x.constructor[$$type] === 'string' ?\n      x.constructor[$$type] :\n      Object.prototype.toString.call(x).slice('[object '.length, -']'.length);\n  }\n\n  return type;\n\n}));\n","/*\n             ############                  #\n            ############                  ###\n                  #####                  #####\n                #####      ####################\n              #####       ######################\n            #####                     ###########\n          #####         ######################\n        #####          ####################\n      #####                        #####\n     ############                 ###\n    ############                 */\n\n//. # sanctuary-type-classes\n//.\n//. The [Fantasy Land Specification][FL] \"specifies interoperability of common\n//. algebraic structures\" by defining a number of type classes. For each type\n//. class, it states laws which every member of a type must obey in order for\n//. the type to be a member of the type class. In order for the Maybe type to\n//. be considered a [Functor][], for example, every `Maybe a` value must have\n//. a `fantasy-land/map` method which obeys the identity and composition laws.\n//.\n//. This project provides:\n//.\n//.   - [`TypeClass`](#TypeClass), a function for defining type classes;\n//.   - one `TypeClass` value for each Fantasy Land type class;\n//.   - lawful Fantasy Land methods for JavaScript's built-in types;\n//.   - one function for each Fantasy Land method; and\n//.   - several functions derived from these functions.\n//.\n//. ## Type-class hierarchy\n//.\n/* eslint-disable max-len */\n//. <pre>\n//.  Setoid   Semigroupoid  Semigroup   Foldable        Functor      Contravariant\n//. (equals)    (compose)    (concat)   (reduce)         (map)        (contramap)\n//.     |           |           |           \\         / | | | | \\\n//.     |           |           |            \\       /  | | | |  \\\n//.     |           |           |             \\     /   | | | |   \\\n//.     |           |           |              \\   /    | | | |    \\\n//.     |           |           |               \\ /     | | | |     \\\n//.    Ord      Category     Monoid         Traversable | | | |      \\\n//.   (lte)       (id)       (empty)        (traverse)  / | | \\       \\\n//.                             |                      /  | |  \\       \\\n//.                             |                     /   / \\   \\       \\\n//.                             |             Profunctor /   \\ Bifunctor \\\n//.                             |              (promap) /     \\ (bimap)   \\\n//.                             |                      /       \\           \\\n//.                           Group                   /         \\           \\\n//.                          (invert)               Alt        Apply      Extend\n//.                                                (alt)        (ap)     (extend)\n//.                                                 /           / \\           \\\n//.                                                /           /   \\           \\\n//.                                               /           /     \\           \\\n//.                                              /           /       \\           \\\n//.                                             /           /         \\           \\\n//.                                           Plus    Applicative    Chain      Comonad\n//.                                          (zero)       (of)      (chain)    (extract)\n//.                                             \\         / \\         / \\\n//.                                              \\       /   \\       /   \\\n//.                                               \\     /     \\     /     \\\n//.                                                \\   /       \\   /       \\\n//.                                                 \\ /         \\ /         \\\n//.                                             Alternative    Monad     ChainRec\n//.                                                                     (chainRec)\n//. </pre>\n/* eslint-enable max-len */\n//.\n//. ## API\n\n(function(f) {\n\n  'use strict';\n\n  /* istanbul ignore else */\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = f(require('sanctuary-type-identifiers'));\n  } else if (typeof define === 'function' && define.amd != null) {\n    define(['sanctuary-type-identifiers'], f);\n  } else {\n    self.sanctuaryTypeClasses = f(self.sanctuaryTypeIdentifiers);\n  }\n\n}(function(type) {\n\n  'use strict';\n\n  //  concat_ :: Array a -> Array a -> Array a\n  function concat_(xs) {\n    return function(ys) {\n      return xs.concat(ys);\n    };\n  }\n\n  //  constant :: a -> b -> a\n  function constant(x) {\n    return function(y) {\n      return x;\n    };\n  }\n\n  //  forEachKey :: (StrMap a, StrMap a ~> String -> Undefined) -> Undefined\n  function forEachKey(strMap, f) {\n    Object.keys(strMap).forEach(f, strMap);\n  }\n\n  //  has :: (String, Object) -> Boolean\n  function has(k, o) {\n    return Object.prototype.hasOwnProperty.call(o, k);\n  }\n\n  //  identity :: a -> a\n  function identity(x) { return x; }\n\n  //  pair :: a -> b -> Pair a b\n  function pair(x) {\n    return function(y) {\n      return [x, y];\n    };\n  }\n\n  //  sameType :: (a, b) -> Boolean\n  function sameType(x, y) {\n    return typeof x === typeof y && type(x) === type(y);\n  }\n\n  //  type Iteration a = { value :: a, done :: Boolean }\n\n  //  iterationNext :: a -> Iteration a\n  function iterationNext(x) { return {value: x, done: false}; }\n\n  //  iterationDone :: a -> Iteration a\n  function iterationDone(x) { return {value: x, done: true}; }\n\n  //# TypeClass :: (String, String, Array TypeClass, a -> Boolean) -> TypeClass\n  //.\n  //. The arguments are:\n  //.\n  //.   - the name of the type class, prefixed by its npm package name;\n  //.   - the documentation URL of the type class;\n  //.   - an array of dependencies; and\n  //.   - a predicate which accepts any JavaScript value and returns `true`\n  //.     if the value satisfies the requirements of the type class; `false`\n  //.     otherwise.\n  //.\n  //. Example:\n  //.\n  //. ```javascript\n  //. //    hasMethod :: String -> a -> Boolean\n  //. const hasMethod = name => x => x != null && typeof x[name] == 'function';\n  //.\n  //. //    Foo :: TypeClass\n  //. const Foo = Z.TypeClass(\n  //.   'my-package/Foo',\n  //.   'http://example.com/my-package#Foo',\n  //.   [],\n  //.   hasMethod('foo')\n  //. );\n  //.\n  //. //    Bar :: TypeClass\n  //. const Bar = Z.TypeClass(\n  //.   'my-package/Bar',\n  //.   'http://example.com/my-package#Bar',\n  //.   [Foo],\n  //.   hasMethod('bar')\n  //. );\n  //. ```\n  //.\n  //. Types whose values have a `foo` method are members of the Foo type class.\n  //. Members of the Foo type class whose values have a `bar` method are also\n  //. members of the Bar type class.\n  //.\n  //. Each `TypeClass` value has a `test` field: a function which accepts\n  //. any JavaScript value and returns `true` if the value satisfies the\n  //. type class's predicate and the predicates of all the type class's\n  //. dependencies; `false` otherwise.\n  //.\n  //. `TypeClass` values may be used with [sanctuary-def][type-classes]\n  //. to define parametrically polymorphic functions which verify their\n  //. type-class constraints at run time.\n  function TypeClass(name, url, dependencies, test) {\n    if (!(this instanceof TypeClass)) {\n      return new TypeClass(name, url, dependencies, test);\n    }\n    this.name = name;\n    this.url = url;\n    this.test = function(x) {\n      return dependencies.every(function(d) { return d.test(x); }) && test(x);\n    };\n  }\n\n  TypeClass['@@type'] = 'sanctuary-type-classes/TypeClass';\n\n  //  data Location = Constructor | Value\n\n  //  Constructor :: Location\n  var Constructor = 'Constructor';\n\n  //  Value :: Location\n  var Value = 'Value';\n\n  //  _funcPath :: (Boolean, Array String, a) -> Nullable Function\n  function _funcPath(allowInheritedProps, path, _x) {\n    var x = _x;\n    for (var idx = 0; idx < path.length; idx += 1) {\n      var k = path[idx];\n      if (x == null || !(allowInheritedProps || has(k, x))) return null;\n      x = x[k];\n    }\n    return typeof x === 'function' ? x : null;\n  }\n\n  //  funcPath :: (Array String, a) -> Nullable Function\n  function funcPath(path, x) {\n    return _funcPath(true, path, x);\n  }\n\n  //  implPath :: Array String -> Nullable Function\n  function implPath(path) {\n    return _funcPath(false, path, implementations);\n  }\n\n  //  functionName :: Function -> String\n  var functionName = has('name', function f() {}) ?\n    function functionName(f) { return f.name; } :\n    /* istanbul ignore next */\n    function functionName(f) {\n      var match = /function (\\w*)/.exec(f);\n      return match == null ? '' : match[1];\n    };\n\n  //  $ :: (String, Array TypeClass, StrMap (Array Location)) -> TypeClass\n  function $(_name, dependencies, requirements) {\n    function getBoundMethod(_name) {\n      var name = 'fantasy-land/' + _name;\n      return requirements[_name] === Constructor ?\n        function(typeRep) {\n          var f = funcPath([name], typeRep);\n          return f == null && typeof typeRep === 'function' ?\n            implPath([functionName(typeRep), name]) :\n            f;\n        } :\n        function(x) {\n          var isPrototype = x != null &&\n                            x.constructor != null &&\n                            x.constructor.prototype === x;\n          var m = null;\n          if (!isPrototype) m = funcPath([name], x);\n          if (m == null)    m = implPath([type(x), 'prototype', name]);\n          return m && m.bind(x);\n        };\n    }\n\n    var version = '7.1.1';  // updated programmatically\n    var keys = Object.keys(requirements);\n\n    var typeClass = TypeClass(\n      'sanctuary-type-classes/' + _name,\n      'https://github.com/sanctuary-js/sanctuary-type-classes/tree/v' + version\n        + '#' + _name,\n      dependencies,\n      function(x) {\n        return keys.every(function(_name) {\n          var arg = requirements[_name] === Constructor ? x.constructor : x;\n          return getBoundMethod(_name)(arg) != null;\n        });\n      }\n    );\n\n    typeClass.methods = keys.reduce(function(methods, _name) {\n      methods[_name] = getBoundMethod(_name);\n      return methods;\n    }, {});\n\n    return typeClass;\n  }\n\n  //# Setoid :: TypeClass\n  //.\n  //. `TypeClass` value for [Setoid][].\n  //.\n  //. ```javascript\n  //. > Setoid.test(null)\n  //. true\n  //. ```\n  var Setoid = $('Setoid', [], {equals: Value});\n\n  //# Ord :: TypeClass\n  //.\n  //. `TypeClass` value for [Ord][].\n  //.\n  //. ```javascript\n  //. > Ord.test(0)\n  //. true\n  //.\n  //. > Ord.test(Math.sqrt)\n  //. false\n  //. ```\n  var Ord = $('Ord', [Setoid], {lte: Value});\n\n  //# Semigroupoid :: TypeClass\n  //.\n  //. `TypeClass` value for [Semigroupoid][].\n  //.\n  //. ```javascript\n  //. > Semigroupoid.test(Math.sqrt)\n  //. true\n  //.\n  //. > Semigroupoid.test(0)\n  //. false\n  //. ```\n  var Semigroupoid = $('Semigroupoid', [], {compose: Value});\n\n  //# Category :: TypeClass\n  //.\n  //. `TypeClass` value for [Category][].\n  //.\n  //. ```javascript\n  //. > Category.test(Math.sqrt)\n  //. true\n  //.\n  //. > Category.test(0)\n  //. false\n  //. ```\n  var Category = $('Category', [Semigroupoid], {id: Constructor});\n\n  //# Semigroup :: TypeClass\n  //.\n  //. `TypeClass` value for [Semigroup][].\n  //.\n  //. ```javascript\n  //. > Semigroup.test('')\n  //. true\n  //.\n  //. > Semigroup.test(0)\n  //. false\n  //. ```\n  var Semigroup = $('Semigroup', [], {concat: Value});\n\n  //# Monoid :: TypeClass\n  //.\n  //. `TypeClass` value for [Monoid][].\n  //.\n  //. ```javascript\n  //. > Monoid.test('')\n  //. true\n  //.\n  //. > Monoid.test(0)\n  //. false\n  //. ```\n  var Monoid = $('Monoid', [Semigroup], {empty: Constructor});\n\n  //# Group :: TypeClass\n  //.\n  //. `TypeClass` value for [Group][].\n  //.\n  //. ```javascript\n  //. > Group.test(Sum(0))\n  //. true\n  //.\n  //. > Group.test('')\n  //. false\n  //. ```\n  var Group = $('Group', [Monoid], {invert: Value});\n\n  //# Functor :: TypeClass\n  //.\n  //. `TypeClass` value for [Functor][].\n  //.\n  //. ```javascript\n  //. > Functor.test([])\n  //. true\n  //.\n  //. > Functor.test('')\n  //. false\n  //. ```\n  var Functor = $('Functor', [], {map: Value});\n\n  //# Bifunctor :: TypeClass\n  //.\n  //. `TypeClass` value for [Bifunctor][].\n  //.\n  //. ```javascript\n  //. > Bifunctor.test(Tuple('foo', 64))\n  //. true\n  //.\n  //. > Bifunctor.test([])\n  //. false\n  //. ```\n  var Bifunctor = $('Bifunctor', [Functor], {bimap: Value});\n\n  //# Profunctor :: TypeClass\n  //.\n  //. `TypeClass` value for [Profunctor][].\n  //.\n  //. ```javascript\n  //. > Profunctor.test(Math.sqrt)\n  //. true\n  //.\n  //. > Profunctor.test([])\n  //. false\n  //. ```\n  var Profunctor = $('Profunctor', [Functor], {promap: Value});\n\n  //# Apply :: TypeClass\n  //.\n  //. `TypeClass` value for [Apply][].\n  //.\n  //. ```javascript\n  //. > Apply.test([])\n  //. true\n  //.\n  //. > Apply.test('')\n  //. false\n  //. ```\n  var Apply = $('Apply', [Functor], {ap: Value});\n\n  //# Applicative :: TypeClass\n  //.\n  //. `TypeClass` value for [Applicative][].\n  //.\n  //. ```javascript\n  //. > Applicative.test([])\n  //. true\n  //.\n  //. > Applicative.test({})\n  //. false\n  //. ```\n  var Applicative = $('Applicative', [Apply], {of: Constructor});\n\n  //# Chain :: TypeClass\n  //.\n  //. `TypeClass` value for [Chain][].\n  //.\n  //. ```javascript\n  //. > Chain.test([])\n  //. true\n  //.\n  //. > Chain.test({})\n  //. false\n  //. ```\n  var Chain = $('Chain', [Apply], {chain: Value});\n\n  //# ChainRec :: TypeClass\n  //.\n  //. `TypeClass` value for [ChainRec][].\n  //.\n  //. ```javascript\n  //. > ChainRec.test([])\n  //. true\n  //.\n  //. > ChainRec.test({})\n  //. false\n  //. ```\n  var ChainRec = $('ChainRec', [Chain], {chainRec: Constructor});\n\n  //# Monad :: TypeClass\n  //.\n  //. `TypeClass` value for [Monad][].\n  //.\n  //. ```javascript\n  //. > Monad.test([])\n  //. true\n  //.\n  //. > Monad.test({})\n  //. false\n  //. ```\n  var Monad = $('Monad', [Applicative, Chain], {});\n\n  //# Alt :: TypeClass\n  //.\n  //. `TypeClass` value for [Alt][].\n  //.\n  //. ```javascript\n  //. > Alt.test({})\n  //. true\n  //.\n  //. > Alt.test('')\n  //. false\n  //. ```\n  var Alt = $('Alt', [Functor], {alt: Value});\n\n  //# Plus :: TypeClass\n  //.\n  //. `TypeClass` value for [Plus][].\n  //.\n  //. ```javascript\n  //. > Plus.test({})\n  //. true\n  //.\n  //. > Plus.test('')\n  //. false\n  //. ```\n  var Plus = $('Plus', [Alt], {zero: Constructor});\n\n  //# Alternative :: TypeClass\n  //.\n  //. `TypeClass` value for [Alternative][].\n  //.\n  //. ```javascript\n  //. > Alternative.test([])\n  //. true\n  //.\n  //. > Alternative.test({})\n  //. false\n  //. ```\n  var Alternative = $('Alternative', [Applicative, Plus], {});\n\n  //# Foldable :: TypeClass\n  //.\n  //. `TypeClass` value for [Foldable][].\n  //.\n  //. ```javascript\n  //. > Foldable.test({})\n  //. true\n  //.\n  //. > Foldable.test('')\n  //. false\n  //. ```\n  var Foldable = $('Foldable', [], {reduce: Value});\n\n  //# Traversable :: TypeClass\n  //.\n  //. `TypeClass` value for [Traversable][].\n  //.\n  //. ```javascript\n  //. > Traversable.test([])\n  //. true\n  //.\n  //. > Traversable.test('')\n  //. false\n  //. ```\n  var Traversable = $('Traversable', [Functor, Foldable], {traverse: Value});\n\n  //# Extend :: TypeClass\n  //.\n  //. `TypeClass` value for [Extend][].\n  //.\n  //. ```javascript\n  //. > Extend.test([])\n  //. true\n  //.\n  //. > Extend.test({})\n  //. false\n  //. ```\n  var Extend = $('Extend', [Functor], {extend: Value});\n\n  //# Comonad :: TypeClass\n  //.\n  //. `TypeClass` value for [Comonad][].\n  //.\n  //. ```javascript\n  //. > Comonad.test(Identity(0))\n  //. true\n  //.\n  //. > Comonad.test([])\n  //. false\n  //. ```\n  var Comonad = $('Comonad', [Extend], {extract: Value});\n\n  //# Contravariant :: TypeClass\n  //.\n  //. `TypeClass` value for [Contravariant][].\n  //.\n  //. ```javascript\n  //. > Contravariant.test(Math.sqrt)\n  //. true\n  //.\n  //. > Contravariant.test([])\n  //. false\n  //. ```\n  var Contravariant = $('Contravariant', [], {contramap: Value});\n\n  //  Null$prototype$toString :: Null ~> () -> String\n  function Null$prototype$toString() {\n    return 'null';\n  }\n\n  //  Null$prototype$equals :: Null ~> Null -> Boolean\n  function Null$prototype$equals(other) {\n    return true;\n  }\n\n  //  Null$prototype$lte :: Null ~> Null -> Boolean\n  function Null$prototype$lte(other) {\n    return true;\n  }\n\n  //  Undefined$prototype$toString :: Undefined ~> () -> String\n  function Undefined$prototype$toString() {\n    return 'undefined';\n  }\n\n  //  Undefined$prototype$equals :: Undefined ~> Undefined -> Boolean\n  function Undefined$prototype$equals(other) {\n    return true;\n  }\n\n  //  Undefined$prototype$lte :: Undefined ~> Undefined -> Boolean\n  function Undefined$prototype$lte(other) {\n    return true;\n  }\n\n  //  Boolean$prototype$toString :: Boolean ~> () -> String\n  function Boolean$prototype$toString() {\n    return typeof this === 'object' ?\n      'new Boolean(' + toString(this.valueOf()) + ')' :\n      this.toString();\n  }\n\n  //  Boolean$prototype$equals :: Boolean ~> Boolean -> Boolean\n  function Boolean$prototype$equals(other) {\n    return typeof this === 'object' ?\n      equals(this.valueOf(), other.valueOf()) :\n      this === other;\n  }\n\n  //  Boolean$prototype$lte :: Boolean ~> Boolean -> Boolean\n  function Boolean$prototype$lte(other) {\n    return typeof this === 'object' ?\n      lte(this.valueOf(), other.valueOf()) :\n      this === false || other === true;\n  }\n\n  //  Number$prototype$toString :: Number ~> () -> String\n  function Number$prototype$toString() {\n    return typeof this === 'object' ?\n      'new Number(' + toString(this.valueOf()) + ')' :\n      1 / this === -Infinity ? '-0' : this.toString(10);\n  }\n\n  //  Number$prototype$equals :: Number ~> Number -> Boolean\n  function Number$prototype$equals(other) {\n    return typeof this === 'object' ?\n      equals(this.valueOf(), other.valueOf()) :\n      isNaN(this) && isNaN(other) || this === other;\n  }\n\n  //  Number$prototype$lte :: Number ~> Number -> Boolean\n  function Number$prototype$lte(other) {\n    return typeof this === 'object' ?\n      lte(this.valueOf(), other.valueOf()) :\n      isNaN(this) && isNaN(other) || this <= other;\n  }\n\n  //  Date$prototype$toString :: Date ~> () -> String\n  function Date$prototype$toString() {\n    var x = isNaN(this.valueOf()) ? NaN : this.toISOString();\n    return 'new Date(' + toString(x) + ')';\n  }\n\n  //  Date$prototype$equals :: Date ~> Date -> Boolean\n  function Date$prototype$equals(other) {\n    return equals(this.valueOf(), other.valueOf());\n  }\n\n  //  Date$prototype$lte :: Date ~> Date -> Boolean\n  function Date$prototype$lte(other) {\n    return lte(this.valueOf(), other.valueOf());\n  }\n\n  //  RegExp$prototype$equals :: RegExp ~> RegExp -> Boolean\n  function RegExp$prototype$equals(other) {\n    return other.source === this.source &&\n           other.global === this.global &&\n           other.ignoreCase === this.ignoreCase &&\n           other.multiline === this.multiline &&\n           other.sticky === this.sticky &&\n           other.unicode === this.unicode;\n  }\n\n  //  String$empty :: () -> String\n  function String$empty() {\n    return '';\n  }\n\n  //  String$prototype$toString :: String ~> () -> String\n  function String$prototype$toString() {\n    return typeof this === 'object' ?\n      'new String(' + toString(this.valueOf()) + ')' :\n      JSON.stringify(this);\n  }\n\n  //  String$prototype$equals :: String ~> String -> Boolean\n  function String$prototype$equals(other) {\n    return typeof this === 'object' ?\n      equals(this.valueOf(), other.valueOf()) :\n      this === other;\n  }\n\n  //  String$prototype$lte :: String ~> String -> Boolean\n  function String$prototype$lte(other) {\n    return typeof this === 'object' ?\n      lte(this.valueOf(), other.valueOf()) :\n      this <= other;\n  }\n\n  //  String$prototype$concat :: String ~> String -> String\n  function String$prototype$concat(other) {\n    return this + other;\n  }\n\n  //  Array$empty :: () -> Array a\n  function Array$empty() {\n    return [];\n  }\n\n  //  Array$of :: a -> Array a\n  function Array$of(x) {\n    return [x];\n  }\n\n  //  Array$chainRec :: ((a -> c, b -> c, a) -> Array c, a) -> Array b\n  function Array$chainRec(f, x) {\n    var $todo = [x];\n    var $done = [];\n    while ($todo.length > 0) {\n      var xs = f(iterationNext, iterationDone, $todo.shift());\n      var $more = [];\n      for (var idx = 0; idx < xs.length; idx += 1) {\n        (xs[idx].done ? $done : $more).push(xs[idx].value);\n      }\n      Array.prototype.unshift.apply($todo, $more);\n    }\n    return $done;\n  }\n\n  //  Array$zero :: () -> Array a\n  function Array$zero() {\n    return [];\n  }\n\n  //  Array$prototype$toString :: Array a ~> () -> String\n  function Array$prototype$toString() {\n    var reprs = this.map(toString);\n    var keys = Object.keys(this).sort();\n    for (var idx = 0; idx < keys.length; idx += 1) {\n      var k = keys[idx];\n      if (!/^\\d+$/.test(k)) {\n        reprs.push(toString(k) + ': ' + toString(this[k]));\n      }\n    }\n    return '[' + reprs.join(', ') + ']';\n  }\n\n  //  Array$prototype$equals :: Array a ~> Array a -> Boolean\n  function Array$prototype$equals(other) {\n    if (other.length !== this.length) return false;\n    for (var idx = 0; idx < this.length; idx += 1) {\n      if (!equals(this[idx], other[idx])) return false;\n    }\n    return true;\n  }\n\n  //  Array$prototype$lte :: Array a ~> Array a -> Boolean\n  function Array$prototype$lte(other) {\n    for (var idx = 0; true; idx += 1) {\n      if (idx === this.length) return true;\n      if (idx === other.length) return false;\n      if (!equals(this[idx], other[idx])) return lte(this[idx], other[idx]);\n    }\n  }\n\n  //  Array$prototype$concat :: Array a ~> Array a -> Array a\n  function Array$prototype$concat(other) {\n    return this.concat(other);\n  }\n\n  //  Array$prototype$map :: Array a ~> (a -> b) -> Array b\n  function Array$prototype$map(f) {\n    return this.map(function(x) { return f(x); });\n  }\n\n  //  Array$prototype$ap :: Array a ~> Array (a -> b) -> Array b\n  function Array$prototype$ap(fs) {\n    var result = [];\n    for (var idx = 0; idx < fs.length; idx += 1) {\n      for (var idx2 = 0; idx2 < this.length; idx2 += 1) {\n        result.push(fs[idx](this[idx2]));\n      }\n    }\n    return result;\n  }\n\n  //  Array$prototype$chain :: Array a ~> (a -> Array b) -> Array b\n  function Array$prototype$chain(f) {\n    var result = [];\n    this.forEach(function(x) { Array.prototype.push.apply(result, f(x)); });\n    return result;\n  }\n\n  //  Array$prototype$alt :: Array a ~> Array a -> Array a\n  var Array$prototype$alt = Array$prototype$concat;\n\n  //  Array$prototype$reduce :: Array a ~> ((b, a) -> b, b) -> b\n  function Array$prototype$reduce(f, initial) {\n    return this.reduce(function(acc, x) { return f(acc, x); }, initial);\n  }\n\n  //  Array$prototype$traverse :: Applicative f => Array a ~> (TypeRep f, a -> f b) -> f (Array b)\n  function Array$prototype$traverse(typeRep, f) {\n    var xs = this;\n    function go(idx, n) {\n      switch (n) {\n        case 0: return of(typeRep, []);\n        case 2: return lift2(pair, f(xs[idx]), f(xs[idx + 1]));\n        default:\n          var m = Math.floor(n / 4) * 2;\n          return lift2(concat_, go(idx, m), go(idx + m, n - m));\n      }\n    }\n    return this.length % 2 === 1 ?\n      lift2(concat_, map(Array$of, f(this[0])), go(1, this.length - 1)) :\n      go(0, this.length);\n  }\n\n  //  Array$prototype$extend :: Array a ~> (Array a -> b) -> Array b\n  function Array$prototype$extend(f) {\n    return this.map(function(_, idx, xs) { return f(xs.slice(idx)); });\n  }\n\n  //  Arguments$prototype$toString :: Arguments ~> String\n  function Arguments$prototype$toString() {\n    var args = Array.prototype.map.call(this, toString).join(', ');\n    return '(function () { return arguments; }(' + args + '))';\n  }\n\n  //  Arguments$prototype$equals :: Arguments ~> Arguments -> Boolean\n  function Arguments$prototype$equals(other) {\n    return Array$prototype$equals.call(this, other);\n  }\n\n  //  Arguments$prototype$lte :: Arguments ~> Arguments -> Boolean\n  function Arguments$prototype$lte(other) {\n    return Array$prototype$lte.call(this, other);\n  }\n\n  //  Error$prototype$toString :: Error ~> () -> String\n  function Error$prototype$toString() {\n    return 'new ' + this.name + '(' + toString(this.message) + ')';\n  }\n\n  //  Error$prototype$equals :: Error ~> Error -> Boolean\n  function Error$prototype$equals(other) {\n    return equals(this.name, other.name) &&\n           equals(this.message, other.message);\n  }\n\n  //  Object$empty :: () -> StrMap a\n  function Object$empty() {\n    return {};\n  }\n\n  //  Object$zero :: () -> StrMap a\n  function Object$zero() {\n    return {};\n  }\n\n  //  Object$prototype$toString :: StrMap a ~> () -> String\n  function Object$prototype$toString() {\n    var reprs = [];\n    var keys = Object.keys(this).sort();\n    for (var idx = 0; idx < keys.length; idx += 1) {\n      var k = keys[idx];\n      reprs.push(toString(k) + ': ' + toString(this[k]));\n    }\n    return '{' + reprs.join(', ') + '}';\n  }\n\n  //  Object$prototype$equals :: StrMap a ~> StrMap a -> Boolean\n  function Object$prototype$equals(other) {\n    var self = this;\n    var keys = Object.keys(this).sort();\n    return equals(keys, Object.keys(other).sort()) &&\n           keys.every(function(k) { return equals(self[k], other[k]); });\n  }\n\n  //  Object$prototype$lte :: StrMap a ~> StrMap a -> Boolean\n  function Object$prototype$lte(other) {\n    var theseKeys = Object.keys(this).sort();\n    var otherKeys = Object.keys(other).sort();\n    while (true) {\n      if (theseKeys.length === 0) return true;\n      if (otherKeys.length === 0) return false;\n      var k = theseKeys.shift();\n      var z = otherKeys.shift();\n      if (k < z) return true;\n      if (k > z) return false;\n      if (!equals(this[k], other[k])) return lte(this[k], other[k]);\n    }\n  }\n\n  //  Object$prototype$concat :: StrMap a ~> StrMap a -> StrMap a\n  function Object$prototype$concat(other) {\n    var result = {};\n    function assign(k) { result[k] = this[k]; }\n    forEachKey(this, assign);\n    forEachKey(other, assign);\n    return result;\n  }\n\n  //  Object$prototype$map :: StrMap a ~> (a -> b) -> StrMap b\n  function Object$prototype$map(f) {\n    var result = {};\n    forEachKey(this, function(k) { result[k] = f(this[k]); });\n    return result;\n  }\n\n  //  Object$prototype$ap :: StrMap a ~> StrMap (a -> b) -> StrMap b\n  function Object$prototype$ap(other) {\n    var result = {};\n    forEachKey(this, function(k) {\n      if (has(k, other)) result[k] = other[k](this[k]);\n    });\n    return result;\n  }\n\n  //  Object$prototype$alt :: StrMap a ~> StrMap a -> StrMap a\n  var Object$prototype$alt = Object$prototype$concat;\n\n  //  Object$prototype$reduce :: StrMap a ~> ((b, a) -> b, b) -> b\n  function Object$prototype$reduce(f, initial) {\n    var self = this;\n    function reducer(acc, k) { return f(acc, self[k]); }\n    return Object.keys(this).sort().reduce(reducer, initial);\n  }\n\n  //  Object$prototype$traverse :: Applicative f => StrMap a ~> (TypeRep f, a -> f b) -> f (StrMap b)\n  function Object$prototype$traverse(typeRep, f) {\n    var self = this;\n    return Object.keys(this).reduce(function(applicative, k) {\n      function set(o) {\n        return function(v) {\n          var singleton = {}; singleton[k] = v;\n          return Object$prototype$concat.call(o, singleton);\n        };\n      }\n      return lift2(set, applicative, f(self[k]));\n    }, of(typeRep, {}));\n  }\n\n  //  Function$id :: () -> a -> a\n  function Function$id() {\n    return identity;\n  }\n\n  //  Function$of :: b -> (a -> b)\n  function Function$of(x) {\n    return function(_) { return x; };\n  }\n\n  //  Function$chainRec :: ((a -> c, b -> c, a) -> (z -> c), a) -> (z -> b)\n  function Function$chainRec(f, x) {\n    return function(a) {\n      var step = iterationNext(x);\n      while (!step.done) {\n        step = f(iterationNext, iterationDone, step.value)(a);\n      }\n      return step.value;\n    };\n  }\n\n  //  Function$prototype$equals :: Function ~> Function -> Boolean\n  function Function$prototype$equals(other) {\n    return other === this;\n  }\n\n  //  Function$prototype$compose :: (a -> b) ~> (b -> c) -> (a -> c)\n  function Function$prototype$compose(other) {\n    var semigroupoid = this;\n    return function(x) { return other(semigroupoid(x)); };\n  }\n\n  //  Function$prototype$map :: (a -> b) ~> (b -> c) -> (a -> c)\n  function Function$prototype$map(f) {\n    var functor = this;\n    return function(x) { return f(functor(x)); };\n  }\n\n  //  Function$prototype$promap :: (b -> c) ~> (a -> b, c -> d) -> (a -> d)\n  function Function$prototype$promap(f, g) {\n    var profunctor = this;\n    return function(x) { return g(profunctor(f(x))); };\n  }\n\n  //  Function$prototype$ap :: (a -> b) ~> (a -> b -> c) -> (a -> c)\n  function Function$prototype$ap(f) {\n    var apply = this;\n    return function(x) { return f(x)(apply(x)); };\n  }\n\n  //  Function$prototype$chain :: (a -> b) ~> (b -> a -> c) -> (a -> c)\n  function Function$prototype$chain(f) {\n    var chain = this;\n    return function(x) { return f(chain(x))(x); };\n  }\n\n  //  Function$prototype$contramap :: (b -> c) ~> (a -> b) -> (a -> c)\n  function Function$prototype$contramap(f) {\n    var contravariant = this;\n    return function(x) { return contravariant(f(x)); };\n  }\n\n  /* eslint-disable key-spacing */\n  var implementations = {\n    Null: {\n      prototype: {\n        toString:                   Null$prototype$toString,\n        'fantasy-land/equals':      Null$prototype$equals,\n        'fantasy-land/lte':         Null$prototype$lte\n      }\n    },\n    Undefined: {\n      prototype: {\n        toString:                   Undefined$prototype$toString,\n        'fantasy-land/equals':      Undefined$prototype$equals,\n        'fantasy-land/lte':         Undefined$prototype$lte\n      }\n    },\n    Boolean: {\n      prototype: {\n        toString:                   Boolean$prototype$toString,\n        'fantasy-land/equals':      Boolean$prototype$equals,\n        'fantasy-land/lte':         Boolean$prototype$lte\n      }\n    },\n    Number: {\n      prototype: {\n        toString:                   Number$prototype$toString,\n        'fantasy-land/equals':      Number$prototype$equals,\n        'fantasy-land/lte':         Number$prototype$lte\n      }\n    },\n    Date: {\n      prototype: {\n        toString:                   Date$prototype$toString,\n        'fantasy-land/equals':      Date$prototype$equals,\n        'fantasy-land/lte':         Date$prototype$lte\n      }\n    },\n    RegExp: {\n      prototype: {\n        'fantasy-land/equals':      RegExp$prototype$equals\n      }\n    },\n    String: {\n      'fantasy-land/empty':         String$empty,\n      prototype: {\n        toString:                   String$prototype$toString,\n        'fantasy-land/equals':      String$prototype$equals,\n        'fantasy-land/lte':         String$prototype$lte,\n        'fantasy-land/concat':      String$prototype$concat\n      }\n    },\n    Array: {\n      'fantasy-land/empty':         Array$empty,\n      'fantasy-land/of':            Array$of,\n      'fantasy-land/chainRec':      Array$chainRec,\n      'fantasy-land/zero':          Array$zero,\n      prototype: {\n        toString:                   Array$prototype$toString,\n        'fantasy-land/equals':      Array$prototype$equals,\n        'fantasy-land/lte':         Array$prototype$lte,\n        'fantasy-land/concat':      Array$prototype$concat,\n        'fantasy-land/map':         Array$prototype$map,\n        'fantasy-land/ap':          Array$prototype$ap,\n        'fantasy-land/chain':       Array$prototype$chain,\n        'fantasy-land/alt':         Array$prototype$alt,\n        'fantasy-land/reduce':      Array$prototype$reduce,\n        'fantasy-land/traverse':    Array$prototype$traverse,\n        'fantasy-land/extend':      Array$prototype$extend\n      }\n    },\n    Arguments: {\n      prototype: {\n        toString:                   Arguments$prototype$toString,\n        'fantasy-land/equals':      Arguments$prototype$equals,\n        'fantasy-land/lte':         Arguments$prototype$lte\n      }\n    },\n    Error: {\n      prototype: {\n        toString:                   Error$prototype$toString,\n        'fantasy-land/equals':      Error$prototype$equals\n      }\n    },\n    Object: {\n      'fantasy-land/empty':         Object$empty,\n      'fantasy-land/zero':          Object$zero,\n      prototype: {\n        toString:                   Object$prototype$toString,\n        'fantasy-land/equals':      Object$prototype$equals,\n        'fantasy-land/lte':         Object$prototype$lte,\n        'fantasy-land/concat':      Object$prototype$concat,\n        'fantasy-land/map':         Object$prototype$map,\n        'fantasy-land/ap':          Object$prototype$ap,\n        'fantasy-land/alt':         Object$prototype$alt,\n        'fantasy-land/reduce':      Object$prototype$reduce,\n        'fantasy-land/traverse':    Object$prototype$traverse\n      }\n    },\n    Function: {\n      'fantasy-land/id':            Function$id,\n      'fantasy-land/of':            Function$of,\n      'fantasy-land/chainRec':      Function$chainRec,\n      prototype: {\n        'fantasy-land/equals':      Function$prototype$equals,\n        'fantasy-land/compose':     Function$prototype$compose,\n        'fantasy-land/map':         Function$prototype$map,\n        'fantasy-land/promap':      Function$prototype$promap,\n        'fantasy-land/ap':          Function$prototype$ap,\n        'fantasy-land/chain':       Function$prototype$chain,\n        'fantasy-land/contramap':   Function$prototype$contramap\n      }\n    }\n  };\n  /* eslint-enable key-spacing */\n\n  //# toString :: a -> String\n  //.\n  //. Returns a useful string representation of its argument.\n  //.\n  //. Dispatches to the argument's `toString` method if appropriate.\n  //.\n  //. Where practical, `equals(eval(toString(x)), x) = true`.\n  //.\n  //. `toString` implementations are provided for the following built-in types:\n  //. Null, Undefined, Boolean, Number, Date, String, Array, Arguments, Error,\n  //. and Object.\n  //.\n  //. ```javascript\n  //. > toString(-0)\n  //. '-0'\n  //.\n  //. > toString(['foo', 'bar', 'baz'])\n  //. '[\"foo\", \"bar\", \"baz\"]'\n  //.\n  //. > toString({x: 1, y: 2, z: 3})\n  //. '{\"x\": 1, \"y\": 2, \"z\": 3}'\n  //.\n  //. > toString(Cons(1, Cons(2, Cons(3, Nil))))\n  //. 'Cons(1, Cons(2, Cons(3, Nil)))'\n  //. ```\n  var toString = (function() {\n    //  $seen :: Array Any\n    var $seen = [];\n\n    function call(method, x) {\n      $seen.push(x);\n      try { return method.call(x); } finally { $seen.pop(); }\n    }\n\n    return function toString(x) {\n      if ($seen.indexOf(x) >= 0) return '<Circular>';\n\n      var xType = type(x);\n      if (xType === 'Object') {\n        var result;\n        try { result = call(x.toString, x); } catch (err) {}\n        if (result != null && result !== '[object Object]') return result;\n      }\n\n      return call(implPath([xType, 'prototype', 'toString']) || x.toString, x);\n    };\n  }());\n\n  //# equals :: (a, b) -> Boolean\n  //.\n  //. Returns `true` if its arguments are of the same type and equal according\n  //. to the type's [`fantasy-land/equals`][] method; `false` otherwise.\n  //.\n  //. `fantasy-land/equals` implementations are provided for the following\n  //. built-in types: Null, Undefined, Boolean, Number, Date, RegExp, String,\n  //. Array, Arguments, Error, Object, and Function.\n  //.\n  //. The algorithm supports circular data structures. Two arrays are equal\n  //. if they have the same index paths and for each path have equal values.\n  //. Two arrays which represent `[1, [1, [1, [1, [1, ...]]]]]`, for example,\n  //. are equal even if their internal structures differ. Two objects are equal\n  //. if they have the same property paths and for each path have equal values.\n  //.\n  //. ```javascript\n  //. > equals(0, -0)\n  //. true\n  //.\n  //. > equals(NaN, NaN)\n  //. true\n  //.\n  //. > equals(Cons('foo', Cons('bar', Nil)), Cons('foo', Cons('bar', Nil)))\n  //. true\n  //.\n  //. > equals(Cons('foo', Cons('bar', Nil)), Cons('bar', Cons('foo', Nil)))\n  //. false\n  //. ```\n  var equals = (function() {\n    //  $pairs :: Array (Pair Any Any)\n    var $pairs = [];\n\n    return function equals(x, y) {\n      if (!sameType(x, y)) return false;\n\n      //  This algorithm for comparing circular data structures was\n      //  suggested in <http://stackoverflow.com/a/40622794/312785>.\n      if ($pairs.some(function(p) { return p[0] === x && p[1] === y; })) {\n        return true;\n      }\n\n      $pairs.push([x, y]);\n      try {\n        return Setoid.test(x) && Setoid.test(y) && Setoid.methods.equals(x)(y);\n      } finally {\n        $pairs.pop();\n      }\n    };\n  }());\n\n  //# lt :: (a, b) -> Boolean\n  //.\n  //. Returns `true` if its arguments are of the same type and the first is\n  //. less than the second according to the type's [`fantasy-land/lte`][]\n  //. method; `false` otherwise.\n  //.\n  //. This function is derived from [`lte`](#lte).\n  //.\n  //. See also [`gt`](#gt) and [`gte`](#gte).\n  //.\n  //. ```javascript\n  //. > lt(0, 0)\n  //. false\n  //.\n  //. > lt(0, 1)\n  //. true\n  //.\n  //. > lt(1, 0)\n  //. false\n  //. ```\n  function lt(x, y) {\n    return sameType(x, y) && !lte(y, x);\n  }\n\n  //# lte :: (a, b) -> Boolean\n  //.\n  //. Returns `true` if its arguments are of the same type and the first\n  //. is less than or equal to the second according to the type's\n  //. [`fantasy-land/lte`][] method; `false` otherwise.\n  //.\n  //. `fantasy-land/lte` implementations are provided for the following\n  //. built-in types: Null, Undefined, Boolean, Number, Date, String, Array,\n  //. Arguments, and Object.\n  //.\n  //. The algorithm supports circular data structures in the same manner as\n  //. [`equals`](#equals).\n  //.\n  //. See also [`lt`](#lt), [`gt`](#gt), and [`gte`](#gte).\n  //.\n  //. ```javascript\n  //. > lte(0, 0)\n  //. true\n  //.\n  //. > lte(0, 1)\n  //. true\n  //.\n  //. > lte(1, 0)\n  //. false\n  //. ```\n  var lte = (function() {\n    //  $pairs :: Array (Pair Any Any)\n    var $pairs = [];\n\n    return function lte(x, y) {\n      if (!sameType(x, y)) return false;\n\n      //  This algorithm for comparing circular data structures was\n      //  suggested in <http://stackoverflow.com/a/40622794/312785>.\n      if ($pairs.some(function(p) { return p[0] === x && p[1] === y; })) {\n        return equals(x, y);\n      }\n\n      $pairs.push([x, y]);\n      try {\n        return Ord.test(x) && Ord.test(y) && Ord.methods.lte(x)(y);\n      } finally {\n        $pairs.pop();\n      }\n    };\n  }());\n\n  //# gt :: (a, b) -> Boolean\n  //.\n  //. Returns `true` if its arguments are of the same type and the first is\n  //. greater than the second according to the type's [`fantasy-land/lte`][]\n  //. method; `false` otherwise.\n  //.\n  //. This function is derived from [`lte`](#lte).\n  //.\n  //. See also [`lt`](#lt) and [`gte`](#gte).\n  //.\n  //. ```javascript\n  //. > gt(0, 0)\n  //. false\n  //.\n  //. > gt(0, 1)\n  //. false\n  //.\n  //. > gt(1, 0)\n  //. true\n  //. ```\n  function gt(x, y) {\n    return lt(y, x);\n  }\n\n  //# gte :: (a, b) -> Boolean\n  //.\n  //. Returns `true` if its arguments are of the same type and the first\n  //. is greater than or equal to the second according to the type's\n  //. [`fantasy-land/lte`][] method; `false` otherwise.\n  //.\n  //. This function is derived from [`lte`](#lte).\n  //.\n  //. See also [`lt`](#lt) and [`gt`](#gt).\n  //.\n  //. ```javascript\n  //. > gte(0, 0)\n  //. true\n  //.\n  //. > gte(0, 1)\n  //. false\n  //.\n  //. > gte(1, 0)\n  //. true\n  //. ```\n  function gte(x, y) {\n    return lte(y, x);\n  }\n\n  //# min :: Ord a => (a, a) -> a\n  //.\n  //. Returns the smaller of its two arguments.\n  //.\n  //. This function is derived from [`lte`](#lte).\n  //.\n  //. See also [`max`](#max).\n  //.\n  //. ```javascript\n  //. > min(10, 2)\n  //. 2\n  //.\n  //. > min(new Date('1999-12-31'), new Date('2000-01-01'))\n  //. new Date('1999-12-31')\n  //.\n  //. > min('10', '2')\n  //. '10'\n  //. ```\n  function min(x, y) {\n    return lte(x, y) ? x : y;\n  }\n\n  //# max :: Ord a => (a, a) -> a\n  //.\n  //. Returns the larger of its two arguments.\n  //.\n  //. This function is derived from [`lte`](#lte).\n  //.\n  //. See also [`min`](#min).\n  //.\n  //. ```javascript\n  //. > max(10, 2)\n  //. 10\n  //.\n  //. > max(new Date('1999-12-31'), new Date('2000-01-01'))\n  //. new Date('2000-01-01')\n  //.\n  //. > max('10', '2')\n  //. '2'\n  //. ```\n  function max(x, y) {\n    return lte(x, y) ? y : x;\n  }\n\n  //# compose :: Semigroupoid c => (c j k, c i j) -> c i k\n  //.\n  //. Function wrapper for [`fantasy-land/compose`][].\n  //.\n  //. `fantasy-land/compose` implementations are provided for the following\n  //. built-in types: Function.\n  //.\n  //. ```javascript\n  //. > compose(Math.sqrt, x => x + 1)(99)\n  //. 10\n  //. ```\n  function compose(x, y) {\n    return Semigroupoid.methods.compose(y)(x);\n  }\n\n  //# id :: Category c => TypeRep c -> c\n  //.\n  //. Function wrapper for [`fantasy-land/id`][].\n  //.\n  //. `fantasy-land/id` implementations are provided for the following\n  //. built-in types: Function.\n  //.\n  //. ```javascript\n  //. > id(Function)('foo')\n  //. 'foo'\n  //. ```\n  function id(typeRep) {\n    return Category.methods.id(typeRep)();\n  }\n\n  //# concat :: Semigroup a => (a, a) -> a\n  //.\n  //. Function wrapper for [`fantasy-land/concat`][].\n  //.\n  //. `fantasy-land/concat` implementations are provided for the following\n  //. built-in types: String, Array, and Object.\n  //.\n  //. ```javascript\n  //. > concat('abc', 'def')\n  //. 'abcdef'\n  //.\n  //. > concat([1, 2, 3], [4, 5, 6])\n  //. [1, 2, 3, 4, 5, 6]\n  //.\n  //. > concat({x: 1, y: 2}, {y: 3, z: 4})\n  //. {x: 1, y: 3, z: 4}\n  //.\n  //. > concat(Cons('foo', Cons('bar', Cons('baz', Nil))), Cons('quux', Nil))\n  //. Cons('foo', Cons('bar', Cons('baz', Cons('quux', Nil))))\n  //. ```\n  function concat(x, y) {\n    return Semigroup.methods.concat(x)(y);\n  }\n\n  //# empty :: Monoid m => TypeRep m -> m\n  //.\n  //. Function wrapper for [`fantasy-land/empty`][].\n  //.\n  //. `fantasy-land/empty` implementations are provided for the following\n  //. built-in types: String, Array, and Object.\n  //.\n  //. ```javascript\n  //. > empty(String)\n  //. ''\n  //.\n  //. > empty(Array)\n  //. []\n  //.\n  //. > empty(Object)\n  //. {}\n  //.\n  //. > empty(List)\n  //. Nil\n  //. ```\n  function empty(typeRep) {\n    return Monoid.methods.empty(typeRep)();\n  }\n\n  //# invert :: Group g => g -> g\n  //.\n  //. Function wrapper for [`fantasy-land/invert`][].\n  //.\n  //. ```javascript\n  //. invert(Sum(5))\n  //. Sum(-5)\n  //. ```\n  function invert(group) {\n    return Group.methods.invert(group)();\n  }\n\n  //# map :: Functor f => (a -> b, f a) -> f b\n  //.\n  //. Function wrapper for [`fantasy-land/map`][].\n  //.\n  //. `fantasy-land/map` implementations are provided for the following\n  //. built-in types: Array, Object, and Function.\n  //.\n  //. ```javascript\n  //. > map(Math.sqrt, [1, 4, 9])\n  //. [1, 2, 3]\n  //.\n  //. > map(Math.sqrt, {x: 1, y: 4, z: 9})\n  //. {x: 1, y: 2, z: 3}\n  //.\n  //. > map(Math.sqrt, s => s.length)('Sanctuary')\n  //. 3\n  //.\n  //. > map(Math.sqrt, Tuple('foo', 64))\n  //. Tuple('foo', 8)\n  //.\n  //. > map(Math.sqrt, Nil)\n  //. Nil\n  //.\n  //. > map(Math.sqrt, Cons(1, Cons(4, Cons(9, Nil))))\n  //. Cons(1, Cons(2, Cons(3, Nil)))\n  //. ```\n  function map(f, functor) {\n    return Functor.methods.map(functor)(f);\n  }\n\n  //# bimap :: Bifunctor f => (a -> b, c -> d, f a c) -> f b d\n  //.\n  //. Function wrapper for [`fantasy-land/bimap`][].\n  //.\n  //. ```javascript\n  //. > bimap(s => s.toUpperCase(), Math.sqrt, Tuple('foo', 64))\n  //. Tuple('FOO', 8)\n  //. ```\n  function bimap(f, g, bifunctor) {\n    return Bifunctor.methods.bimap(bifunctor)(f, g);\n  }\n\n  //# promap :: Profunctor p => (a -> b, c -> d, p b c) -> p a d\n  //.\n  //. Function wrapper for [`fantasy-land/promap`][].\n  //.\n  //. `fantasy-land/promap` implementations are provided for the following\n  //. built-in types: Function.\n  //.\n  //. ```javascript\n  //. > promap(Math.abs, x => x + 1, Math.sqrt)(-100)\n  //. 11\n  //. ```\n  function promap(f, g, profunctor) {\n    return Profunctor.methods.promap(profunctor)(f, g);\n  }\n\n  //# ap :: Apply f => (f (a -> b), f a) -> f b\n  //.\n  //. Function wrapper for [`fantasy-land/ap`][].\n  //.\n  //. `fantasy-land/ap` implementations are provided for the following\n  //. built-in types: Array, Object, and Function.\n  //.\n  //. ```javascript\n  //. > ap([Math.sqrt, x => x * x], [1, 4, 9, 16, 25])\n  //. [1, 2, 3, 4, 5, 1, 16, 81, 256, 625]\n  //.\n  //. > ap({a: Math.sqrt, b: x => x * x}, {a: 16, b: 10, c: 1})\n  //. {a: 4, b: 100}\n  //.\n  //. > ap(s => n => s.slice(0, n), s => Math.ceil(s.length / 2))('Haskell')\n  //. 'Hask'\n  //.\n  //. > ap(Identity(Math.sqrt), Identity(64))\n  //. Identity(8)\n  //.\n  //. > ap(Cons(Math.sqrt, Cons(x => x * x, Nil)), Cons(16, Cons(100, Nil)))\n  //. Cons(4, Cons(10, Cons(256, Cons(10000, Nil))))\n  //. ```\n  function ap(applyF, applyX) {\n    return Apply.methods.ap(applyX)(applyF);\n  }\n\n  //# lift2 :: Apply f => (a -> b -> c, f a, f b) -> f c\n  //.\n  //. Lifts `a -> b -> c` to `Apply f => f a -> f b -> f c` and returns the\n  //. result of applying this to the given arguments.\n  //.\n  //. This function is derived from [`map`](#map) and [`ap`](#ap).\n  //.\n  //. See also [`lift3`](#lift3).\n  //.\n  //. ```javascript\n  //. > lift2(x => y => Math.pow(x, y), [10], [1, 2, 3])\n  //. [10, 100, 1000]\n  //.\n  //. > lift2(x => y => Math.pow(x, y), Identity(10), Identity(3))\n  //. Identity(1000)\n  //. ```\n  function lift2(f, x, y) {\n    return ap(map(f, x), y);\n  }\n\n  //# lift3 :: Apply f => (a -> b -> c -> d, f a, f b, f c) -> f d\n  //.\n  //. Lifts `a -> b -> c -> d` to `Apply f => f a -> f b -> f c -> f d` and\n  //. returns the result of applying this to the given arguments.\n  //.\n  //. This function is derived from [`map`](#map) and [`ap`](#ap).\n  //.\n  //. See also [`lift2`](#lift2).\n  //.\n  //. ```javascript\n  //. > lift3(x => y => z => x + z + y, ['<'], ['>'], ['foo', 'bar', 'baz'])\n  //. ['<foo>', '<bar>', '<baz>']\n  //.\n  //. > lift3(x => y => z => x + z + y, Identity('<'), Identity('>'), Identity('baz'))\n  //. Identity('<baz>')\n  //. ```\n  function lift3(f, x, y, z) {\n    return ap(ap(map(f, x), y), z);\n  }\n\n  //# apFirst :: Apply f => (f a, f b) -> f a\n  //.\n  //. Combines two effectful actions, keeping only the result of the first.\n  //. Equivalent to Haskell's `(<*)` function.\n  //.\n  //. This function is derived from [`lift2`](#lift2).\n  //.\n  //. See also [`apSecond`](#apSecond).\n  //.\n  //. ```javascript\n  //. > apFirst([1, 2], [3, 4])\n  //. [1, 1, 2, 2]\n  //.\n  //. > apFirst(Identity(1), Identity(2))\n  //. Identity(1)\n  //. ```\n  function apFirst(x, y) {\n    return lift2(constant, x, y);\n  }\n\n  //# apSecond :: Apply f => (f a, f b) -> f b\n  //.\n  //. Combines two effectful actions, keeping only the result of the second.\n  //. Equivalent to Haskell's `(*>)` function.\n  //.\n  //. This function is derived from [`lift2`](#lift2).\n  //.\n  //. See also [`apFirst`](#apFirst).\n  //.\n  //. ```javascript\n  //. > apSecond([1, 2], [3, 4])\n  //. [3, 4, 3, 4]\n  //.\n  //. > apSecond(Identity(1), Identity(2))\n  //. Identity(2)\n  //. ```\n  function apSecond(x, y) {\n    return lift2(constant(identity), x, y);\n  }\n\n  //# of :: Applicative f => (TypeRep f, a) -> f a\n  //.\n  //. Function wrapper for [`fantasy-land/of`][].\n  //.\n  //. `fantasy-land/of` implementations are provided for the following\n  //. built-in types: Array and Function.\n  //.\n  //. ```javascript\n  //. > of(Array, 42)\n  //. [42]\n  //.\n  //. > of(Function, 42)(null)\n  //. 42\n  //.\n  //. > of(List, 42)\n  //. Cons(42, Nil)\n  //. ```\n  function of(typeRep, x) {\n    return Applicative.methods.of(typeRep)(x);\n  }\n\n  //# append :: (Applicative f, Semigroup (f a)) => (a, f a) -> f a\n  //.\n  //. Returns the result of appending the first argument to the second.\n  //.\n  //. This function is derived from [`concat`](#concat) and [`of`](#of).\n  //.\n  //. See also [`prepend`](#prepend).\n  //.\n  //. ```javascript\n  //. > append(3, [1, 2])\n  //. [1, 2, 3]\n  //.\n  //. > append(3, Cons(1, Cons(2, Nil)))\n  //. Cons(1, Cons(2, Cons(3, Nil)))\n  //. ```\n  function append(x, xs) {\n    return concat(xs, of(xs.constructor, x));\n  }\n\n  //# prepend :: (Applicative f, Semigroup (f a)) => (a, f a) -> f a\n  //.\n  //. Returns the result of prepending the first argument to the second.\n  //.\n  //. This function is derived from [`concat`](#concat) and [`of`](#of).\n  //.\n  //. See also [`append`](#append).\n  //.\n  //. ```javascript\n  //. > prepend(1, [2, 3])\n  //. [1, 2, 3]\n  //.\n  //. > prepend(1, Cons(2, Cons(3, Nil)))\n  //. Cons(1, Cons(2, Cons(3, Nil)))\n  //. ```\n  function prepend(x, xs) {\n    return concat(of(xs.constructor, x), xs);\n  }\n\n  //# chain :: Chain m => (a -> m b, m a) -> m b\n  //.\n  //. Function wrapper for [`fantasy-land/chain`][].\n  //.\n  //. `fantasy-land/chain` implementations are provided for the following\n  //. built-in types: Array and Function.\n  //.\n  //. ```javascript\n  //. > chain(x => [x, x], [1, 2, 3])\n  //. [1, 1, 2, 2, 3, 3]\n  //.\n  //. > chain(x => x % 2 == 1 ? of(List, x) : Nil, Cons(1, Cons(2, Cons(3, Nil))))\n  //. Cons(1, Cons(3, Nil))\n  //.\n  //. > chain(n => s => s.slice(0, n), s => Math.ceil(s.length / 2))('Haskell')\n  //. 'Hask'\n  //. ```\n  function chain(f, chain_) {\n    return Chain.methods.chain(chain_)(f);\n  }\n\n  //# join :: Chain m => m (m a) -> m a\n  //.\n  //. Removes one level of nesting from a nested monadic structure.\n  //.\n  //. This function is derived from [`chain`](#chain).\n  //.\n  //. ```javascript\n  //. > join([[1], [2], [3]])\n  //. [1, 2, 3]\n  //.\n  //. > join([[[1, 2, 3]]])\n  //. [[1, 2, 3]]\n  //.\n  //. > join(Identity(Identity(1)))\n  //. Identity(1)\n  //. ```\n  function join(chain_) {\n    return chain(identity, chain_);\n  }\n\n  //# chainRec :: ChainRec m => (TypeRep m, (a -> c, b -> c, a) -> m c, a) -> m b\n  //.\n  //. Function wrapper for [`fantasy-land/chainRec`][].\n  //.\n  //. `fantasy-land/chainRec` implementations are provided for the following\n  //. built-in types: Array.\n  //.\n  //. ```javascript\n  //. > chainRec(\n  //. .   Array,\n  //. .   (next, done, s) => s.length == 2 ? [s + '!', s + '?'].map(done)\n  //. .                                    : [s + 'o', s + 'n'].map(next),\n  //. .   ''\n  //. . )\n  //. ['oo!', 'oo?', 'on!', 'on?', 'no!', 'no?', 'nn!', 'nn?']\n  //. ```\n  function chainRec(typeRep, f, x) {\n    return ChainRec.methods.chainRec(typeRep)(f, x);\n  }\n\n  //# filter :: (Applicative f, Foldable f, Monoid (f a)) => (a -> Boolean, f a) -> f a\n  //.\n  //. Filters its second argument in accordance with the given predicate.\n  //.\n  //. This function is derived from [`concat`](#concat), [`empty`](#empty),\n  //. [`of`](#of), and [`reduce`](#reduce).\n  //.\n  //. See also [`filterM`](#filterM).\n  //.\n  //. ```javascript\n  //. > filter(x => x % 2 == 1, [1, 2, 3])\n  //. [1, 3]\n  //.\n  //. > filter(x => x % 2 == 1, Cons(1, Cons(2, Cons(3, Nil))))\n  //. Cons(1, Cons(3, Nil))\n  //. ```\n  function filter(pred, m) {\n    //  Fast path for arrays.\n    if (Array.isArray(m)) return m.filter(function(x) { return pred(x); });\n    var M = m.constructor;\n    return reduce(function(m, x) { return pred(x) ? concat(m, of(M, x)) : m; },\n                  empty(M),\n                  m);\n  }\n\n  //# filterM :: (Alternative m, Monad m) => (a -> Boolean, m a) -> m a\n  //.\n  //. Filters its second argument in accordance with the given predicate.\n  //.\n  //. This function is derived from [`of`](#of), [`chain`](#chain), and\n  //. [`zero`](#zero).\n  //.\n  //. See also [`filter`](#filter).\n  //.\n  //. ```javascript\n  //. > filterM(x => x % 2 == 1, [1, 2, 3])\n  //. [1, 3]\n  //.\n  //. > filterM(x => x % 2 == 1, Cons(1, Cons(2, Cons(3, Nil))))\n  //. Cons(1, Cons(3, Nil))\n  //.\n  //. > filterM(x => x % 2 == 1, Nothing)\n  //. Nothing\n  //.\n  //. > filterM(x => x % 2 == 1, Just(0))\n  //. Nothing\n  //.\n  //. > filterM(x => x % 2 == 1, Just(1))\n  //. Just(1)\n  //. ```\n  function filterM(pred, m) {\n    var M = m.constructor;\n    var z = zero(M);\n    return chain(function(x) { return pred(x) ? of(M, x) : z; }, m);\n  }\n\n  //# alt :: Alt f => (f a, f a) -> f a\n  //.\n  //. Function wrapper for [`fantasy-land/alt`][].\n  //.\n  //. `fantasy-land/alt` implementations are provided for the following\n  //. built-in types: Array and Object.\n  //.\n  //. ```javascript\n  //. > alt([1, 2, 3], [4, 5, 6])\n  //. [1, 2, 3, 4, 5, 6]\n  //.\n  //. > alt(Nothing, Nothing)\n  //. Nothing\n  //.\n  //. > alt(Nothing, Just(1))\n  //. Just(1)\n  //.\n  //. > alt(Just(2), Just(3))\n  //. Just(2)\n  //. ```\n  function alt(x, y) {\n    return Alt.methods.alt(x)(y);\n  }\n\n  //# zero :: Plus f => TypeRep f -> f a\n  //.\n  //. Function wrapper for [`fantasy-land/zero`][].\n  //.\n  //. `fantasy-land/zero` implementations are provided for the following\n  //. built-in types: Array and Object.\n  //.\n  //. ```javascript\n  //. > zero(Array)\n  //. []\n  //.\n  //. > zero(Object)\n  //. {}\n  //.\n  //. > zero(Maybe)\n  //. Nothing\n  //. ```\n  function zero(typeRep) {\n    return Plus.methods.zero(typeRep)();\n  }\n\n  //# reduce :: Foldable f => ((b, a) -> b, b, f a) -> b\n  //.\n  //. Function wrapper for [`fantasy-land/reduce`][].\n  //.\n  //. `fantasy-land/reduce` implementations are provided for the following\n  //. built-in types: Array and Object.\n  //.\n  //. ```javascript\n  //. > reduce((xs, x) => [x].concat(xs), [], [1, 2, 3])\n  //. [3, 2, 1]\n  //.\n  //. > reduce(concat, '', Cons('foo', Cons('bar', Cons('baz', Nil))))\n  //. 'foobarbaz'\n  //. ```\n  function reduce(f, x, foldable) {\n    return Foldable.methods.reduce(foldable)(f, x);\n  }\n\n  //# size :: Foldable f => f a -> Integer\n  //.\n  //. Returns the number of elements of the given structure.\n  //.\n  //. This function is derived from [`reduce`](#reduce).\n  //.\n  //. ```javascript\n  //. > size([])\n  //. 0\n  //.\n  //. > size(['foo', 'bar', 'baz'])\n  //. 3\n  //.\n  //. > size(Nil)\n  //. 0\n  //.\n  //. > size(Cons('foo', Cons('bar', Cons('baz', Nil))))\n  //. 3\n  //. ```\n  function size(foldable) {\n    //  Fast path for arrays.\n    if (Array.isArray(foldable)) return foldable.length;\n    return reduce(function(n, _) { return n + 1; }, 0, foldable);\n  }\n\n  //# elem :: (Setoid a, Foldable f) => (a, f a) -> Boolean\n  //.\n  //. Takes a value and a structure and returns `true` if the\n  //. value is an element of the structure; `false` otherwise.\n  //.\n  //. This function is derived from [`equals`](#equals) and\n  //. [`reduce`](#reduce).\n  //.\n  //. ```javascript\n  //. > elem('c', ['a', 'b', 'c'])\n  //. true\n  //.\n  //. > elem('x', ['a', 'b', 'c'])\n  //. false\n  //.\n  //. > elem(3, {x: 1, y: 2, z: 3})\n  //. true\n  //.\n  //. > elem(8, {x: 1, y: 2, z: 3})\n  //. false\n  //.\n  //. > elem(0, Just(0))\n  //. true\n  //.\n  //. > elem(0, Just(1))\n  //. false\n  //.\n  //. > elem(0, Nothing)\n  //. false\n  //. ```\n  function elem(x, foldable) {\n    return reduce(function(b, y) { return b || equals(x, y); },\n                  false,\n                  foldable);\n  }\n\n  //# reverse :: (Applicative f, Foldable f, Monoid (f a)) => f a -> f a\n  //.\n  //. Reverses the elements of the given structure.\n  //.\n  //. This function is derived from [`concat`](#concat), [`empty`](#empty),\n  //. [`of`](#of), and [`reduce`](#reduce).\n  //.\n  //. ```javascript\n  //. > reverse([1, 2, 3])\n  //. [3, 2, 1]\n  //.\n  //. > reverse(Cons(1, Cons(2, Cons(3, Nil))))\n  //. Cons(3, Cons(2, Cons(1, Nil)))\n  //. ```\n  function reverse(foldable) {\n    //  Fast path for arrays.\n    if (Array.isArray(foldable)) return foldable.slice().reverse();\n    var F = foldable.constructor;\n    return reduce(function(xs, x) { return concat(of(F, x), xs); },\n                  empty(F),\n                  foldable);\n  }\n\n  //# sort :: (Ord a, Applicative f, Foldable f, Monoid (f a)) => f a -> f a\n  //.\n  //. Performs a [stable sort][] of the elements of the given structure,\n  //. using [`lte`](#lte) for comparisons.\n  //.\n  //. This function is derived from [`lte`](#lte), [`concat`](#concat),\n  //. [`empty`](#empty), [`of`](#of), and [`reduce`](#reduce).\n  //.\n  //. See also [`sortBy`](#sortBy).\n  //.\n  //. ```javascript\n  //. > sort(['foo', 'bar', 'baz'])\n  //. ['bar', 'baz', 'foo']\n  //.\n  //. > sort([Just(2), Nothing, Just(1)])\n  //. [Nothing, Just(1), Just(2)]\n  //.\n  //. > sort(Cons('foo', Cons('bar', Cons('baz', Nil))))\n  //. Cons('bar', Cons('baz', Cons('foo', Nil)))\n  //. ```\n  function sort(foldable) {\n    return sortBy(identity, foldable);\n  }\n\n  //# sortBy :: (Ord b, Applicative f, Foldable f, Monoid (f a)) => (a -> b, f a) -> f a\n  //.\n  //. Performs a [stable sort][] of the elements of the given structure,\n  //. using [`lte`](#lte) to compare the values produced by applying the\n  //. given function to each element of the structure.\n  //.\n  //. This function is derived from [`lte`](#lte), [`concat`](#concat),\n  //. [`empty`](#empty), [`of`](#of), and [`reduce`](#reduce).\n  //.\n  //. See also [`sort`](#sort).\n  //.\n  //. ```javascript\n  //. > sortBy(s => s.length, ['red', 'green', 'blue'])\n  //. ['red', 'blue', 'green']\n  //.\n  //. > sortBy(s => s.length, ['black', 'white'])\n  //. ['black', 'white']\n  //.\n  //. > sortBy(s => s.length, ['white', 'black'])\n  //. ['white', 'black']\n  //.\n  //. > sortBy(s => s.length, Cons('red', Cons('green', Cons('blue', Nil))))\n  //. Cons('red', Cons('blue', Cons('green', Nil)))\n  //. ```\n  function sortBy(f, foldable) {\n    var rs = reduce(function(xs, x) {\n      var fx = f(x);\n      var lower = 0;\n      var upper = xs.length;\n      while (lower < upper) {\n        var idx = Math.floor((lower + upper) / 2);\n        if (lte(xs[idx].fx, fx)) lower = idx + 1; else upper = idx;\n      }\n      xs.splice(lower, 0, {x: x, fx: fx});\n      return xs;\n    }, [], foldable);\n\n    var F = foldable.constructor;\n    var result = empty(F);\n    for (var idx = 0; idx < rs.length; idx += 1) {\n      result = concat(result, of(F, rs[idx].x));\n    }\n    return result;\n  }\n\n  //# takeWhile :: (Applicative f, Foldable f, Monoid (f a)) => (a -> Boolean, f a) -> f a\n  //.\n  //. Discards the first inner value which does not satisfy the predicate, and\n  //. all subsequent inner values.\n  //.\n  //. This function is derived from [`concat`](#concat), [`empty`](#empty),\n  //. [`of`](#of), and [`reduce`](#reduce).\n  //.\n  //. See also [`dropWhile`](#dropWhile).\n  //.\n  //. ```javascript\n  //. > takeWhile(s => /x/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])\n  //. ['xy', 'xz', 'yx']\n  //.\n  //. > takeWhile(s => /y/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])\n  //. ['xy']\n  //.\n  //. > takeWhile(s => /z/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])\n  //. []\n  //. ```\n  function takeWhile(pred, foldable) {\n    var take = true;\n    return filter(function(x) { return take = take && pred(x); }, foldable);\n  }\n\n  //# dropWhile :: (Applicative f, Foldable f, Monoid (f a)) => (a -> Boolean, f a) -> f a\n  //.\n  //. Retains the first inner value which does not satisfy the predicate, and\n  //. all subsequent inner values.\n  //.\n  //. This function is derived from [`concat`](#concat), [`empty`](#empty),\n  //. [`of`](#of), and [`reduce`](#reduce).\n  //.\n  //. See also [`takeWhile`](#takeWhile).\n  //.\n  //. ```javascript\n  //. > dropWhile(s => /x/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])\n  //. ['yz', 'zx', 'zy']\n  //.\n  //. > dropWhile(s => /y/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])\n  //. ['xz', 'yx', 'yz', 'zx', 'zy']\n  //.\n  //. > dropWhile(s => /z/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])\n  //. ['xy', 'xz', 'yx', 'yz', 'zx', 'zy']\n  //. ```\n  function dropWhile(pred, foldable) {\n    var take = false;\n    return filter(function(x) { return take = take || !pred(x); }, foldable);\n  }\n\n  //# traverse :: (Applicative f, Traversable t) => (TypeRep f, a -> f b, t a) -> f (t b)\n  //.\n  //. Function wrapper for [`fantasy-land/traverse`][].\n  //.\n  //. `fantasy-land/traverse` implementations are provided for the following\n  //. built-in types: Array and Object.\n  //.\n  //. See also [`sequence`](#sequence).\n  //.\n  //. ```javascript\n  //. > traverse(Array, x => x, [[1, 2, 3], [4, 5]])\n  //. [[1, 4], [1, 5], [2, 4], [2, 5], [3, 4], [3, 5]]\n  //.\n  //. > traverse(Identity, x => Identity(x + 1), [1, 2, 3])\n  //. Identity([2, 3, 4])\n  //. ```\n  function traverse(typeRep, f, traversable) {\n    return Traversable.methods.traverse(traversable)(typeRep, f);\n  }\n\n  //# sequence :: (Applicative f, Traversable t) => (TypeRep f, t (f a)) -> f (t a)\n  //.\n  //. Inverts the given `t (f a)` to produce an `f (t a)`.\n  //.\n  //. This function is derived from [`traverse`](#traverse).\n  //.\n  //. ```javascript\n  //. > sequence(Array, Identity([1, 2, 3]))\n  //. [Identity(1), Identity(2), Identity(3)]\n  //.\n  //. > sequence(Identity, [Identity(1), Identity(2), Identity(3)])\n  //. Identity([1, 2, 3])\n  //. ```\n  function sequence(typeRep, traversable) {\n    return traverse(typeRep, identity, traversable);\n  }\n\n  //# extend :: Extend w => (w a -> b, w a) -> w b\n  //.\n  //. Function wrapper for [`fantasy-land/extend`][].\n  //.\n  //. `fantasy-land/extend` implementations are provided for the following\n  //. built-in types: Array.\n  //.\n  //. ```javascript\n  //. > extend(ss => ss.join(''), ['x', 'y', 'z'])\n  //. ['xyz', 'yz', 'z']\n  //. ```\n  function extend(f, extend_) {\n    return Extend.methods.extend(extend_)(f);\n  }\n\n  //# extract :: Comonad w => w a -> a\n  //.\n  //. Function wrapper for [`fantasy-land/extract`][].\n  //.\n  //. ```javascript\n  //. > extract(Identity(42))\n  //. 42\n  //. ```\n  function extract(comonad) {\n    return Comonad.methods.extract(comonad)();\n  }\n\n  //# contramap :: Contravariant f => (b -> a, f a) -> f b\n  //.\n  //. Function wrapper for [`fantasy-land/contramap`][].\n  //.\n  //. `fantasy-land/contramap` implementations are provided for the following\n  //. built-in types: Function.\n  //.\n  //. ```javascript\n  //. > contramap(s => s.length, Math.sqrt)('Sanctuary')\n  //. 3\n  //. ```\n  function contramap(f, contravariant) {\n    return Contravariant.methods.contramap(contravariant)(f);\n  }\n\n  return {\n    TypeClass: TypeClass,\n    Setoid: Setoid,\n    Ord: Ord,\n    Semigroupoid: Semigroupoid,\n    Category: Category,\n    Semigroup: Semigroup,\n    Monoid: Monoid,\n    Group: Group,\n    Functor: Functor,\n    Bifunctor: Bifunctor,\n    Profunctor: Profunctor,\n    Apply: Apply,\n    Applicative: Applicative,\n    Chain: Chain,\n    ChainRec: ChainRec,\n    Monad: Monad,\n    Alt: Alt,\n    Plus: Plus,\n    Alternative: Alternative,\n    Foldable: Foldable,\n    Traversable: Traversable,\n    Extend: Extend,\n    Comonad: Comonad,\n    Contravariant: Contravariant,\n    toString: toString,\n    equals: equals,\n    lt: lt,\n    lte: lte,\n    gt: gt,\n    gte: gte,\n    min: min,\n    max: max,\n    compose: compose,\n    id: id,\n    concat: concat,\n    empty: empty,\n    invert: invert,\n    map: map,\n    bimap: bimap,\n    promap: promap,\n    ap: ap,\n    lift2: lift2,\n    lift3: lift3,\n    apFirst: apFirst,\n    apSecond: apSecond,\n    of: of,\n    append: append,\n    prepend: prepend,\n    chain: chain,\n    join: join,\n    chainRec: chainRec,\n    filter: filter,\n    filterM: filterM,\n    alt: alt,\n    zero: zero,\n    reduce: reduce,\n    size: size,\n    elem: elem,\n    reverse: reverse,\n    sort: sort,\n    sortBy: sortBy,\n    takeWhile: takeWhile,\n    dropWhile: dropWhile,\n    traverse: traverse,\n    sequence: sequence,\n    extend: extend,\n    extract: extract,\n    contramap: contramap\n  };\n\n}));\n\n//. [Alt]:                      https://github.com/fantasyland/fantasy-land#alt\n//. [Alternative]:              https://github.com/fantasyland/fantasy-land#alternative\n//. [Applicative]:              https://github.com/fantasyland/fantasy-land#applicative\n//. [Apply]:                    https://github.com/fantasyland/fantasy-land#apply\n//. [Bifunctor]:                https://github.com/fantasyland/fantasy-land#bifunctor\n//. [Category]:                 https://github.com/fantasyland/fantasy-land#category\n//. [Chain]:                    https://github.com/fantasyland/fantasy-land#chain\n//. [ChainRec]:                 https://github.com/fantasyland/fantasy-land#chainrec\n//. [Comonad]:                  https://github.com/fantasyland/fantasy-land#comonad\n//. [Contravariant]:            https://github.com/fantasyland/fantasy-land#contravariant\n//. [Extend]:                   https://github.com/fantasyland/fantasy-land#extend\n//. [FL]:                       https://github.com/fantasyland/fantasy-land\n//. [Foldable]:                 https://github.com/fantasyland/fantasy-land#foldable\n//. [Functor]:                  https://github.com/fantasyland/fantasy-land#functor\n//. [Group]:                    https://github.com/fantasyland/fantasy-land#group\n//. [Monad]:                    https://github.com/fantasyland/fantasy-land#monad\n//. [Monoid]:                   https://github.com/fantasyland/fantasy-land#monoid\n//. [Ord]:                      https://github.com/fantasyland/fantasy-land#ord\n//. [Plus]:                     https://github.com/fantasyland/fantasy-land#plus\n//. [Profunctor]:               https://github.com/fantasyland/fantasy-land#profunctor\n//. [Semigroup]:                https://github.com/fantasyland/fantasy-land#semigroup\n//. [Semigroupoid]:             https://github.com/fantasyland/fantasy-land#semigroupoid\n//. [Setoid]:                   https://github.com/fantasyland/fantasy-land#setoid\n//. [Traversable]:              https://github.com/fantasyland/fantasy-land#traversable\n//. [`fantasy-land/alt`]:       https://github.com/fantasyland/fantasy-land#alt-method\n//. [`fantasy-land/ap`]:        https://github.com/fantasyland/fantasy-land#ap-method\n//. [`fantasy-land/bimap`]:     https://github.com/fantasyland/fantasy-land#bimap-method\n//. [`fantasy-land/chain`]:     https://github.com/fantasyland/fantasy-land#chain-method\n//. [`fantasy-land/chainRec`]:  https://github.com/fantasyland/fantasy-land#chainrec-method\n//. [`fantasy-land/compose`]:   https://github.com/fantasyland/fantasy-land#compose-method\n//. [`fantasy-land/concat`]:    https://github.com/fantasyland/fantasy-land#concat-method\n//. [`fantasy-land/contramap`]: https://github.com/fantasyland/fantasy-land#contramap-method\n//. [`fantasy-land/empty`]:     https://github.com/fantasyland/fantasy-land#empty-method\n//. [`fantasy-land/equals`]:    https://github.com/fantasyland/fantasy-land#equals-method\n//. [`fantasy-land/extend`]:    https://github.com/fantasyland/fantasy-land#extend-method\n//. [`fantasy-land/extract`]:   https://github.com/fantasyland/fantasy-land#extract-method\n//. [`fantasy-land/id`]:        https://github.com/fantasyland/fantasy-land#id-method\n//. [`fantasy-land/invert`]:    https://github.com/fantasyland/fantasy-land#invert-method\n//. [`fantasy-land/lte`]:       https://github.com/fantasyland/fantasy-land#lte-method\n//. [`fantasy-land/map`]:       https://github.com/fantasyland/fantasy-land#map-method\n//. [`fantasy-land/of`]:        https://github.com/fantasyland/fantasy-land#of-method\n//. [`fantasy-land/promap`]:    https://github.com/fantasyland/fantasy-land#promap-method\n//. [`fantasy-land/reduce`]:    https://github.com/fantasyland/fantasy-land#reduce-method\n//. [`fantasy-land/traverse`]:  https://github.com/fantasyland/fantasy-land#traverse-method\n//. [`fantasy-land/zero`]:      https://github.com/fantasyland/fantasy-land#zero-method\n//. [stable sort]:              https://en.wikipedia.org/wiki/Sorting_algorithm#Stability\n//. [type-classes]:             https://github.com/sanctuary-js/sanctuary-def#type-classes\n","/*\n        @@@@@@@            @@@@@@@         @@\n      @@       @@        @@       @@      @@@\n    @@   @@@ @@  @@    @@   @@@ @@  @@   @@@@@@ @@   @@@  @@ @@@      @@@@\n   @@  @@   @@@   @@  @@  @@   @@@   @@   @@@   @@   @@@  @@@   @@  @@@   @@\n   @@  @@   @@@   @@  @@  @@   @@@   @@   @@@   @@   @@@  @@@   @@  @@@@@@@@\n   @@  @@   @@@  @@   @@  @@   @@@  @@    @@@   @@   @@@  @@@   @@  @@@\n    @@   @@@ @@@@@     @@   @@@ @@@@@      @@@    @@@ @@  @@@@@@      @@@@@\n      @@                 @@                           @@  @@\n        @@@@@@@            @@@@@@@               @@@@@    @@\n                                                          */\n//. # sanctuary-type-identifiers\n//.\n//. A type is a set of values. Boolean, for example, is the type comprising\n//. `true` and `false`. A value may be a member of multiple types (`42` is a\n//. member of Number, PositiveNumber, Integer, and many other types).\n//.\n//. In certain situations it is useful to divide JavaScript values into\n//. non-overlapping types. The language provides two constructs for this\n//. purpose: the [`typeof`][1] operator and [`Object.prototype.toString`][2].\n//. Each has pros and cons, but neither supports user-defined types.\n//.\n//. sanctuary-type-identifiers comprises:\n//.\n//.   - an npm and browser -compatible package for deriving the\n//.     _type identifier_ of a JavaScript value; and\n//.   - a specification which authors may follow to specify type\n//.     identifiers for their types.\n//.\n//. ### Specification\n//.\n//. For a type to be compatible with the algorithm:\n//.\n//.   - every member of the type MUST have a `constructor` property\n//.     pointing to an object known as the _type representative_;\n//.\n//.   - the type representative MUST have a `@@type` property\n//.     (the _type identifier_); and\n//.\n//.   - the type identifier MUST be a string primitive and SHOULD have\n//.     format `'<namespace>/<name>[@<version>]'`, where:\n//.\n//.       - `<namespace>` MUST consist of one or more characters, and\n//.         SHOULD equal the name of the npm package which defines the\n//.         type (including [scope][3] where appropriate);\n//.\n//.       - `<name>` MUST consist of one or more characters, and SHOULD\n//.         be the unique name of the type; and\n//.\n//.       - `<version>` MUST consist of one or more digits, and SHOULD\n//.         represent the version of the type.\n//.\n//. If the type identifier does not conform to the format specified above,\n//. it is assumed that the entire string represents the _name_ of the type;\n//. _namespace_ will be `null` and _version_ will be `0`.\n//.\n//. If the _version_ is not given, it is assumed to be `0`.\n//.\n//. For example:\n//.\n//. ```javascript\n//. //  Identity :: a -> Identity a\n//. function Identity(x) {\n//.   if (!(this instanceof Identity)) return new Identity(x);\n//.   this.value = x;\n//. }\n//.\n//. Identity['@@type'] = 'my-package/Identity';\n//. ```\n//.\n//. Note that by using a constructor function the `constructor` property is set\n//. implicitly for each value created. Constructor functions are convenient for\n//. this reason, but are not required. This definition is also valid:\n//.\n//. ```javascript\n//. //  IdentityTypeRep :: TypeRep Identity\n//. var IdentityTypeRep = {\n//.   '@@type': 'my-package/Identity'\n//. };\n//.\n//. //  Identity :: a -> Identity a\n//. function Identity(x) {\n//.   return {constructor: IdentityTypeRep, value: x};\n//. }\n//. ```\n\n(function(f) {\n\n  'use strict';\n\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = f();\n  } else if (typeof define === 'function' && define.amd != null) {\n    define([], f);\n  } else {\n    self.sanctuaryTypeIdentifiers = f();\n  }\n\n}(function() {\n\n  'use strict';\n\n  //  $$type :: String\n  var $$type = '@@type';\n\n  //  pattern :: RegExp\n  var pattern = new RegExp(\n    '^'\n  + '([\\\\s\\\\S]+)'   //  <namespace>\n  + '/'             //  SOLIDUS (U+002F)\n  + '([\\\\s\\\\S]+?)'  //  <name>\n  + '(?:'           //  optional non-capturing group {\n  +   '@'           //    COMMERCIAL AT (U+0040)\n  +   '([0-9]+)'    //    <version>\n  + ')?'            //  }\n  + '$'\n  );\n\n  //. ### Usage\n  //.\n  //. ```javascript\n  //. const type = require('sanctuary-type-identifiers');\n  //. ```\n  //.\n  //. ```javascript\n  //. > function Identity(x) {\n  //. .   if (!(this instanceof Identity)) return new Identity(x);\n  //. .   this.value = x;\n  //. . }\n  //. . Identity['@@type'] = 'my-package/Identity@1';\n  //.\n  //. > type.parse(type(Identity(0)))\n  //. {namespace: 'my-package', name: 'Identity', version: 1}\n  //. ```\n  //.\n  //. ### API\n  //.\n  //# type :: Any -> String\n  //.\n  //. Takes any value and returns a string which identifies its type. If the\n  //. value conforms to the [specification][4], the custom type identifier is\n  //. returned.\n  //.\n  //. ```javascript\n  //. > type(null)\n  //. 'Null'\n  //.\n  //. > type(true)\n  //. 'Boolean'\n  //.\n  //. > type(Identity(0))\n  //. 'my-package/Identity@1'\n  //. ```\n  function type(x) {\n    return x != null &&\n           x.constructor != null &&\n           x.constructor.prototype !== x &&\n           typeof x.constructor[$$type] === 'string' ?\n      x.constructor[$$type] :\n      Object.prototype.toString.call(x).slice('[object '.length, -']'.length);\n  }\n\n  //# type.parse :: String -> { namespace :: Nullable String, name :: String, version :: Number }\n  //.\n  //. Takes any string and parses it according to the [specification][4],\n  //. returning an object with `namespace`, `name`, and `version` fields.\n  //.\n  //. ```javascript\n  //. > type.parse('my-package/List@2')\n  //. {namespace: 'my-package', name: 'List', version: 2}\n  //.\n  //. > type.parse('nonsense!')\n  //. {namespace: null, name: 'nonsense!', version: 0}\n  //.\n  //. > type.parse(Identity['@@type'])\n  //. {namespace: 'my-package', name: 'Identity', version: 1}\n  //. ```\n  type.parse = function parse(s) {\n    var groups = pattern.exec(s);\n    return {\n      namespace: groups == null || groups[1] == null ? null : groups[1],\n      name:      groups == null                      ? s    : groups[2],\n      version:   groups == null || groups[3] == null ? 0    : Number(groups[3])\n    };\n  };\n\n  return type;\n\n}));\n\n//. [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof\n//. [2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\n//. [3]: https://docs.npmjs.com/misc/scope\n//. [4]: #specification\n","/*              ___                 ______\n               /  /\\               /  ___/\\\n        ______/  / / _______    __/  /___\\/\n       /  ___   / / /  ___  \\  /_   __/\\\n      /  /\\_/  / / /  /__/  /\\ \\/  /\\_\\/\n     /  / //  / / /  ______/ / /  / /\n    /  /_//  / / /  /______\\/ /  / /\n    \\_______/ /  \\_______/\\  /__/ /\n     \\______\\/    \\______\\/  \\__*/\n\n//. # sanctuary-def\n//.\n//. sanctuary-def is a run-time type system for JavaScript. It facilitates\n//. the definition of curried JavaScript functions which are explicit about\n//. the number of arguments to which they may be applied and the types of\n//. those arguments.\n//.\n//. It is conventional to import the package as `$`:\n//.\n//. ```javascript\n//. const $ = require('sanctuary-def');\n//. ```\n//.\n//. The next step is to define an environment. An environment is an array\n//. of [types][]. [`env`][] is an environment containing all the built-in\n//. JavaScript types. It may be used as the basis for environments which\n//. include custom types in addition to the built-in types:\n//.\n//. ```javascript\n//. //    Integer :: Type\n//. const Integer = ...;\n//.\n//. //    NonZeroInteger :: Type\n//. const NonZeroInteger = ...;\n//.\n//. //    env :: Array Type\n//. const env = $.env.concat([Integer, NonZeroInteger]);\n//. ```\n//.\n//. Type constructors such as `List :: Type -> Type` cannot be included in\n//. an environment as they're not of the correct type. One could, though,\n//. use a type constructor to define a fixed number of concrete types:\n//.\n//. ```javascript\n//. //    env :: Array Type\n//. const env = $.env.concat([\n//.   List($.Number),               // :: Type\n//.   List($.String),               // :: Type\n//.   List(List($.Number)),         // :: Type\n//.   List(List($.String)),         // :: Type\n//.   List(List(List($.Number))),   // :: Type\n//.   List(List(List($.String))),   // :: Type\n//. ]);\n//. ```\n//.\n//. Not only would this be tedious, but one could never enumerate all possible\n//. types as there are infinitely many. Instead, one should use [`Unknown`][]:\n//.\n//. ```javascript\n//. //    env :: Array Type\n//. const env = $.env.concat([List($.Unknown)]);\n//. ```\n//.\n//. The next step is to define a `def` function for the environment:\n//.\n//. ```javascript\n//. const def = $.create({checkTypes: true, env: env});\n//. ```\n//.\n//. The `checkTypes` option determines whether type checking is enabled.\n//. This allows one to only pay the performance cost of run-time type checking\n//. during development. For example:\n//.\n//. ```javascript\n//. const def = $.create({\n//.   checkTypes: process.env.NODE_ENV === 'development',\n//.   env: env,\n//. });\n//. ```\n//.\n//. `def` is a function for defining functions. For example:\n//.\n//. ```javascript\n//. //    add :: Number -> Number -> Number\n//. const add =\n//. def('add', {}, [$.Number, $.Number, $.Number], (x, y) => x + y);\n//. ```\n//.\n//. `[$.Number, $.Number, $.Number]` specifies that `add` takes two arguments\n//. of type `Number` and returns a value of type `Number`.\n//.\n//. Applying `add` to two arguments gives the expected result:\n//.\n//. ```javascript\n//. add(2, 2);\n//. // => 4\n//. ```\n//.\n//. Applying `add` to greater than two arguments results in an exception being\n//. thrown:\n//.\n//. ```javascript\n//. add(2, 2, 2);\n//. // ! TypeError: add requires two arguments; received three arguments\n//. ```\n//.\n//. Applying `add` to fewer than two arguments results in a function\n//. awaiting the remaining arguments. This is known as partial application.\n//. Partial application is convenient as it allows more specific functions\n//. to be defined in terms of more general ones:\n//.\n//. ```javascript\n//. //    inc :: Number -> Number\n//. const inc = add(1);\n//.\n//. inc(7);\n//. // => 8\n//. ```\n//.\n//. JavaScript's implicit type coercion often obfuscates the source of type\n//. errors. Consider the following function:\n//.\n//. ```javascript\n//. //    _add :: (Number, Number) -> Number\n//. const _add = (x, y) => x + y;\n//. ```\n//.\n//. The type signature indicates that `_add` takes two arguments of type\n//. `Number`, but this is not enforced. This allows type errors to be silently\n//. ignored:\n//.\n//. ```javascript\n//. _add('2', '2');\n//. // => '22'\n//. ```\n//.\n//. `add`, on the other hand, throws if applied to arguments of the wrong\n//. types:\n//.\n//. ```javascript\n//. add('2', '2');\n//. // ! TypeError: Invalid value\n//. //\n//. //   add :: Number -> Number -> Number\n//. //          ^^^^^^\n//. //            1\n//. //\n//. //   1)  \"2\" :: String\n//. //\n//. //   The value at position 1 is not a member of Number.\n//. ```\n//.\n//. Type checking is performed as arguments are provided (rather than once all\n//. arguments have been provided), so type errors are reported early:\n//.\n//. ```javascript\n//. add('X');\n//. // ! TypeError: Invalid value\n//. //\n//. //   add :: Number -> Number -> Number\n//. //          ^^^^^^\n//. //            1\n//. //\n//. //   1)  \"X\" :: String\n//. //\n//. //   The value at position 1 is not a member of Number.\n//. ```\n\n(function(f) {\n\n  'use strict';\n\n  /* istanbul ignore else */\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = f(require('sanctuary-type-classes'),\n                       require('sanctuary-type-identifiers'));\n  } else if (typeof define === 'function' && define.amd != null) {\n    define(['sanctuary-type-classes', 'sanctuary-type-identifiers'], f);\n  } else {\n    self.sanctuaryDef = f(self.sanctuaryTypeClasses,\n                          self.sanctuaryTypeIdentifiers);\n  }\n\n}(function(Z, type) {\n\n  'use strict';\n\n  //# __ :: Placeholder\n  //.\n  //. The special placeholder value.\n  //.\n  //. One may wish to partially apply a function whose parameters are in the\n  //. \"wrong\" order. Functions defined via sanctuary-def accommodate this by\n  //. accepting placeholders for arguments yet to be provided. For example:\n  //.\n  //. ```javascript\n  //. //    concatS :: String -> String -> String\n  //. const concatS =\n  //. def('concatS', {}, [$.String, $.String, $.String], (x, y) => x + y);\n  //.\n  //. //    exclaim :: String -> String\n  //. const exclaim = concatS($.__, '!');\n  //.\n  //. exclaim('ahoy');\n  //. // => 'ahoy!'\n  //. ```\n  var __ = {'@@functional/placeholder': true};\n\n  var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n  var MIN_SAFE_INTEGER = -MAX_SAFE_INTEGER;\n\n  var slice             = Array.prototype.slice;\n  var hasOwnProperty    = Object.prototype.hasOwnProperty;\n\n  function Either(tag, value) {\n    this.isLeft = tag === 'Left';\n    this.isRight = tag === 'Right';\n    this.value = value;\n  }\n\n  Either['@@type'] = 'sanctuary-def/Either';\n\n  Either.prototype['fantasy-land/map'] = function(f) {\n    return this.isLeft ? this : Right(f(this.value));\n  };\n\n  Either.prototype['fantasy-land/chain'] = function(f) {\n    return this.isLeft ? this : f(this.value);\n  };\n\n  //  Left :: a -> Either a b\n  function Left(x) { return new Either('Left', x); }\n\n  //  Right :: b -> Either a b\n  function Right(x) { return new Either('Right', x); }\n\n  //  K :: a -> b -> a\n  function K(x) { return function(y) { return x; }; }\n\n  //  always2 :: a -> (b, c) -> a\n  function always2(x) { return function(y, z) { return x; }; }\n\n  //  id :: a -> a\n  function id(x) { return x; }\n\n  //  init :: Array a -> Array a\n  function init(xs) { return xs.slice(0, -1); }\n\n  //  isEmpty :: Array a -> Boolean\n  function isEmpty(xs) { return xs.length === 0; }\n\n  //  isPrefix :: Array a -> Array a -> Boolean\n  function isPrefix(candidate) {\n    return function(xs) {\n      if (candidate.length > xs.length) return false;\n      for (var idx = 0; idx < candidate.length; idx += 1) {\n        if (candidate[idx] !== xs[idx]) return false;\n      }\n      return true;\n    };\n  }\n\n  //  last :: Array a -> a\n  function last(xs) { return xs[xs.length - 1]; }\n\n  //  memberOf :: Array a -> a -> Boolean\n  function memberOf(xs) {\n    return function(y) {\n      return xs.some(function(x) { return Z.equals(x, y); });\n    };\n  }\n\n  //  or :: (Array a, Array a) -> Array a\n  function or(xs, ys) { return isEmpty(xs) ? ys : xs; }\n\n  //  range :: (Number, Number) -> Array Number\n  function range(start, stop) {\n    var result = [];\n    for (var n = start; n < stop; n += 1) result.push(n);\n    return result;\n  }\n\n  //  singleton :: (String, a) -> StrMap a\n  function singleton(k, v) {\n    var result = {};\n    result[k] = v;\n    return result;\n  }\n\n  //  strRepeat :: (String, Integer) -> String\n  function strRepeat(s, times) {\n    return Array(times + 1).join(s);\n  }\n\n  //  r :: Char -> String -> String\n  function r(c) {\n    return function(s) {\n      return strRepeat(c, s.length);\n    };\n  }\n\n  //  _ :: String -> String\n  var _ = r(' ');\n\n  //  stripOutermostParens :: String -> String\n  function stripOutermostParens(s) {\n    return s.slice('('.length, -')'.length);\n  }\n\n  //  toMarkdownList :: (String, String, a -> String, Array a) -> String\n  function toMarkdownList(empty, s, f, xs) {\n    return isEmpty(xs) ?\n      empty :\n      Z.reduce(function(s, x) { return s + '  - ' + f(x) + '\\n'; }, s, xs);\n  }\n\n  //  trimTrailingSpaces :: String -> String\n  function trimTrailingSpaces(s) {\n    return s.replace(/[ ]+$/gm, '');\n  }\n\n  //  unless :: (Boolean, (a -> a), a) -> a\n  function unless(bool, f, x) {\n    return bool ? x : f(x);\n  }\n\n  //  when :: (Boolean, (a -> a), a) -> a\n  function when(bool, f, x) {\n    return bool ? f(x) : x;\n  }\n\n  //  wrap :: String -> String -> String -> String\n  function wrap(prefix) {\n    return function(suffix) {\n      return function(s) {\n        return prefix + s + suffix;\n      };\n    };\n  }\n\n  //  parenthesize :: String -> String\n  var parenthesize = wrap('(')(')');\n\n  //  q :: String -> String\n  var q = wrap('\\u2018')('\\u2019');\n\n  //  stripNamespace :: String -> String\n  function stripNamespace(s) { return s.slice(s.indexOf('/') + 1); }\n\n  //  _Type :: ... -> Type\n  function _Type(\n    type,       // :: String\n    name,       // :: String\n    url,        // :: String\n    format,     // :: (String -> String, String -> String -> String) -> String\n    test,       // :: Any -> Boolean\n    keys,       // :: Array String\n    types       // :: StrMap { extractor :: a -> Array b, type :: Type }\n  ) {\n    this._test = test;\n    this.format = format;\n    this.keys = keys;\n    this.name = name;\n    this.type = type;\n    this.types = types;\n    this.url = url;\n  }\n\n  _Type['@@type'] = 'sanctuary-def/Type';\n\n  _Type.prototype.validate = function(x) {\n    if (!this._test(x)) return Left({value: x, propPath: []});\n    for (var idx = 0; idx < this.keys.length; idx += 1) {\n      var k = this.keys[idx];\n      var t = this.types[k];\n      for (var idx2 = 0, ys = t.extractor(x); idx2 < ys.length; idx2 += 1) {\n        var result = t.type.validate(ys[idx2]);\n        if (result.isLeft) {\n          var value = result.value.value;\n          var propPath = Z.concat([k], result.value.propPath);\n          return Left({value: value, propPath: propPath});\n        }\n      }\n    }\n    return Right(x);\n  };\n\n  _Type.prototype.toString = function() {\n    return this.format(id, K(id));\n  };\n\n  var BINARY        = 'BINARY';\n  var FUNCTION      = 'FUNCTION';\n  var INCONSISTENT  = 'INCONSISTENT';\n  var NULLARY       = 'NULLARY';\n  var RECORD        = 'RECORD';\n  var UNARY         = 'UNARY';\n  var UNKNOWN       = 'UNKNOWN';\n  var VARIABLE      = 'VARIABLE';\n\n  //  Inconsistent :: Type\n  var Inconsistent =\n  new _Type(INCONSISTENT, '', '', always2('???'), K(false), [], {});\n\n  //  typeEq :: String -> a -> Boolean\n  function typeEq(name) {\n    return function(x) {\n      return type(x) === name;\n    };\n  }\n\n  //  typeofEq :: String -> a -> Boolean\n  function typeofEq(typeof_) {\n    return function(x) {\n      // eslint-disable-next-line valid-typeof\n      return typeof x === typeof_;\n    };\n  }\n\n  //  functionUrl :: String -> String\n  function functionUrl(name) {\n    var version = '0.14.0';  // updated programmatically\n    return 'https://github.com/sanctuary-js/sanctuary-def/tree/v' + version +\n           '#' + stripNamespace(name);\n  }\n\n  //  NullaryTypeWithUrl :: (String, Any -> Boolean) -> Type\n  function NullaryTypeWithUrl(name, test) {\n    return NullaryType(name, functionUrl(name), test);\n  }\n\n  //  EnumTypeWithUrl :: (String, Array Any) -> Type\n  function EnumTypeWithUrl(name, members) {\n    return EnumType(name, functionUrl(name), members);\n  }\n\n  //  UnaryTypeWithUrl ::\n  //    (String, Any -> Boolean, t a -> Array a) -> (Type -> Type)\n  function UnaryTypeWithUrl(name, test, _1) {\n    return UnaryType(name, functionUrl(name), test, _1);\n  }\n\n  //  BinaryTypeWithUrl ::\n  //    (String, Any -> Boolean, t a b -> Array a, t a b -> Array b) ->\n  //      ((Type, Type) -> Type)\n  function BinaryTypeWithUrl(name, test, _1, _2) {\n    return BinaryType(name, functionUrl(name), test, _1, _2);\n  }\n\n  //. ### Types\n  //.\n  //. Conceptually, a type is a set of values. One can think of a value of\n  //. type `Type` as a function of type `Any -> Boolean` which tests values\n  //. for membership in the set (though this is an oversimplification).\n\n  //# Any :: Type\n  //.\n  //. Type comprising every JavaScript value.\n  var Any = NullaryTypeWithUrl('sanctuary-def/Any', K(true));\n\n  //# AnyFunction :: Type\n  //.\n  //. Type comprising every Function value.\n  var AnyFunction = NullaryTypeWithUrl('Function', typeofEq('function'));\n\n  //# Arguments :: Type\n  //.\n  //. Type comprising every [`arguments`][arguments] object.\n  var Arguments = NullaryTypeWithUrl('Arguments', typeEq('Arguments'));\n\n  //# Array :: Type -> Type\n  //.\n  //. Constructor for homogeneous Array types.\n  var Array_ = UnaryTypeWithUrl('Array', typeEq('Array'), id);\n\n  //# Boolean :: Type\n  //.\n  //. Type comprising `true` and `false`.\n  var Boolean_ = NullaryTypeWithUrl('Boolean', typeofEq('boolean'));\n\n  //# Date :: Type\n  //.\n  //. Type comprising every Date value.\n  var Date_ = NullaryTypeWithUrl('Date', typeEq('Date'));\n\n  //# Error :: Type\n  //.\n  //. Type comprising every Error value, including values of more specific\n  //. constructors such as [`SyntaxError`][] and [`TypeError`][].\n  var Error_ = NullaryTypeWithUrl('Error', typeEq('Error'));\n\n  //# FiniteNumber :: Type\n  //.\n  //. Type comprising every [`ValidNumber`][] value except `Infinity` and\n  //. `-Infinity`.\n  var FiniteNumber = NullaryTypeWithUrl(\n    'sanctuary-def/FiniteNumber',\n    function(x) { return ValidNumber._test(x) && isFinite(x); }\n  );\n\n  //# Function :: Array Type -> Type\n  //.\n  //. Constructor for Function types.\n  //.\n  //. Examples:\n  //.\n  //.   - `$.Function([$.Date, $.String])` represents the `Date -> String`\n  //.     type; and\n  //.   - `$.Function([a, b, a])` represents the `(a, b) -> a` type.\n  function Function_(types) {\n    function format(outer, inner) {\n      var xs = types.map(function(t, idx) {\n        return unless(t.type === RECORD || isEmpty(t.keys),\n                      stripOutermostParens,\n                      inner('$' + String(idx + 1))(String(t)));\n      });\n      var parenthesize = wrap(outer('('))(outer(')'));\n      return parenthesize(unless(types.length === 2,\n                                 parenthesize,\n                                 init(xs).join(outer(', '))) +\n                          outer(' -> ') +\n                          last(xs));\n    }\n\n    var test = AnyFunction._test;\n\n    var $keys = [];\n    var $types = {};\n    types.forEach(function(t, idx) {\n      var k = '$' + String(idx + 1);\n      $keys.push(k);\n      $types[k] = {extractor: K([]), type: t};\n    });\n\n    return new _Type(FUNCTION, '', '', format, test, $keys, $types);\n  }\n\n  //# GlobalRegExp :: Type\n  //.\n  //. Type comprising every [`RegExp`][] value whose `global` flag is `true`.\n  //.\n  //. See also [`NonGlobalRegExp`][].\n  var GlobalRegExp = NullaryTypeWithUrl(\n    'sanctuary-def/GlobalRegExp',\n    function(x) { return RegExp_._test(x) && x.global; }\n  );\n\n  //# Integer :: Type\n  //.\n  //. Type comprising every integer in the range\n  //. [[`Number.MIN_SAFE_INTEGER`][min] .. [`Number.MAX_SAFE_INTEGER`][max]].\n  var Integer = NullaryTypeWithUrl(\n    'sanctuary-def/Integer',\n    function(x) {\n      return ValidNumber._test(x) &&\n             Math.floor(x) === x &&\n             x >= MIN_SAFE_INTEGER &&\n             x <= MAX_SAFE_INTEGER;\n    }\n  );\n\n  //# NegativeFiniteNumber :: Type\n  //.\n  //. Type comprising every [`FiniteNumber`][] value less than zero.\n  var NegativeFiniteNumber = NullaryTypeWithUrl(\n    'sanctuary-def/NegativeFiniteNumber',\n    function(x) { return FiniteNumber._test(x) && x < 0; }\n  );\n\n  //# NegativeInteger :: Type\n  //.\n  //. Type comprising every [`Integer`][] value less than zero.\n  var NegativeInteger = NullaryTypeWithUrl(\n    'sanctuary-def/NegativeInteger',\n    function(x) { return Integer._test(x) && x < 0; }\n  );\n\n  //# NegativeNumber :: Type\n  //.\n  //. Type comprising every [`Number`][] value less than zero.\n  var NegativeNumber = NullaryTypeWithUrl(\n    'sanctuary-def/NegativeNumber',\n    function(x) { return Number_._test(x) && x < 0; }\n  );\n\n  //# NonEmpty :: Type -> Type\n  //.\n  //. Constructor for non-empty types. `$.NonEmpty($.String)`, for example, is\n  //. the type comprising every [`String`][] value except `''`.\n  //.\n  //. The given type must satisfy the [Monoid][] and [Setoid][] specifications.\n  var NonEmpty = UnaryType(\n    'sanctuary-def/NonEmpty',\n    functionUrl('NonEmpty'),\n    function(x) {\n      return Z.Monoid.test(x) &&\n             Z.Setoid.test(x) &&\n             !Z.equals(x, Z.empty(x.constructor));\n    },\n    function(monoid) { return [monoid]; }\n  );\n\n  //# NonGlobalRegExp :: Type\n  //.\n  //. Type comprising every [`RegExp`][] value whose `global` flag is `false`.\n  //.\n  //. See also [`GlobalRegExp`][].\n  var NonGlobalRegExp = NullaryTypeWithUrl(\n    'sanctuary-def/NonGlobalRegExp',\n    function(x) { return RegExp_._test(x) && !x.global; }\n  );\n\n  //# NonNegativeInteger :: Type\n  //.\n  //. Type comprising every non-negative [`Integer`][] value (including `-0`).\n  //. Also known as the set of natural numbers under ISO 80000-2:2009.\n  var NonNegativeInteger = NullaryTypeWithUrl(\n    'sanctuary-def/NonNegativeInteger',\n    function(x) { return Integer._test(x) && x >= 0; }\n  );\n\n  //# NonZeroFiniteNumber :: Type\n  //.\n  //. Type comprising every [`FiniteNumber`][] value except `0` and `-0`.\n  var NonZeroFiniteNumber = NullaryTypeWithUrl(\n    'sanctuary-def/NonZeroFiniteNumber',\n    function(x) { return FiniteNumber._test(x) && x !== 0; }\n  );\n\n  //# NonZeroInteger :: Type\n  //.\n  //. Type comprising every [`Integer`][] value except `0` and `-0`.\n  var NonZeroInteger = NullaryTypeWithUrl(\n    'sanctuary-def/NonZeroInteger',\n    function(x) { return Integer._test(x) && x !== 0; }\n  );\n\n  //# NonZeroValidNumber :: Type\n  //.\n  //. Type comprising every [`ValidNumber`][] value except `0` and `-0`.\n  var NonZeroValidNumber = NullaryTypeWithUrl(\n    'sanctuary-def/NonZeroValidNumber',\n    function(x) { return ValidNumber._test(x) && x !== 0; }\n  );\n\n  //# Null :: Type\n  //.\n  //. Type whose sole member is `null`.\n  var Null = NullaryTypeWithUrl('Null', typeEq('Null'));\n\n  //# Nullable :: Type -> Type\n  //.\n  //. Constructor for types which include `null` as a member.\n  var Nullable = UnaryTypeWithUrl(\n    'sanctuary-def/Nullable',\n    K(true),\n    function(nullable) {\n      // eslint-disable-next-line eqeqeq\n      return nullable === null ? [] : [nullable];\n    }\n  );\n\n  //# Number :: Type\n  //.\n  //. Type comprising every primitive Number value (including `NaN`).\n  var Number_ = NullaryTypeWithUrl('Number', typeofEq('number'));\n\n  //# Object :: Type\n  //.\n  //. Type comprising every \"plain\" Object value. Specifically, values\n  //. created via:\n  //.\n  //.   - object literal syntax;\n  //.   - [`Object.create`][]; or\n  //.   - the `new` operator in conjunction with `Object` or a custom\n  //.     constructor function.\n  var Object_ = NullaryTypeWithUrl('Object', typeEq('Object'));\n\n  //# Pair :: Type -> Type -> Type\n  //.\n  //. Constructor for tuple types of length 2. Arrays are said to represent\n  //. tuples. `['foo', 42]` is a member of `Pair String Number`.\n  var Pair = BinaryTypeWithUrl(\n    'sanctuary-def/Pair',\n    function(x) { return typeEq('Array')(x) && x.length === 2; },\n    function(pair) { return [pair[0]]; },\n    function(pair) { return [pair[1]]; }\n  );\n\n  //# PositiveFiniteNumber :: Type\n  //.\n  //. Type comprising every [`FiniteNumber`][] value greater than zero.\n  var PositiveFiniteNumber = NullaryTypeWithUrl(\n    'sanctuary-def/PositiveFiniteNumber',\n    function(x) { return FiniteNumber._test(x) && x > 0; }\n  );\n\n  //# PositiveInteger :: Type\n  //.\n  //. Type comprising every [`Integer`][] value greater than zero.\n  var PositiveInteger = NullaryTypeWithUrl(\n    'sanctuary-def/PositiveInteger',\n    function(x) { return Integer._test(x) && x > 0; }\n  );\n\n  //# PositiveNumber :: Type\n  //.\n  //. Type comprising every [`Number`][] value greater than zero.\n  var PositiveNumber = NullaryTypeWithUrl(\n    'sanctuary-def/PositiveNumber',\n    function(x) { return Number_._test(x) && x > 0; }\n  );\n\n  //# RegExp :: Type\n  //.\n  //. Type comprising every RegExp value.\n  var RegExp_ = NullaryTypeWithUrl('RegExp', typeEq('RegExp'));\n\n  //# RegexFlags :: Type\n  //.\n  //. Type comprising the canonical RegExp flags:\n  //.\n  //.   - `''`\n  //.   - `'g'`\n  //.   - `'i'`\n  //.   - `'m'`\n  //.   - `'gi'`\n  //.   - `'gm'`\n  //.   - `'im'`\n  //.   - `'gim'`\n  var RegexFlags = EnumTypeWithUrl(\n    'sanctuary-def/RegexFlags',\n    ['', 'g', 'i', 'm', 'gi', 'gm', 'im', 'gim']\n  );\n\n  //# StrMap :: Type -> Type\n  //.\n  //. Constructor for homogeneous Object types.\n  //.\n  //. `{foo: 1, bar: 2, baz: 3}`, for example, is a member of `StrMap Number`;\n  //. `{foo: 1, bar: 2, baz: 'XXX'}` is not.\n  var StrMap = UnaryTypeWithUrl(\n    'sanctuary-def/StrMap',\n    Object_._test,\n    function(strMap) {\n      return Z.reduce(function(xs, x) { return xs.concat([x]); }, [], strMap);\n    }\n  );\n\n  //# String :: Type\n  //.\n  //. Type comprising every primitive String value.\n  var String_ = NullaryTypeWithUrl('String', typeofEq('string'));\n\n  //# Symbol :: Type\n  //.\n  //. Type comprising every Symbol value.\n  var Symbol_ = NullaryTypeWithUrl('Symbol', typeofEq('symbol'));\n\n  //# Type :: Type\n  //.\n  //. Type comprising every `Type` value.\n  var Type = NullaryTypeWithUrl('Type', typeEq('sanctuary-def/Type'));\n\n  //# TypeClass :: Type\n  //.\n  //. Type comprising every [`TypeClass`][] value.\n  var TypeClass =\n  NullaryTypeWithUrl('TypeClass', typeEq('sanctuary-type-classes/TypeClass'));\n\n  //# Undefined :: Type\n  //.\n  //. Type whose sole member is `undefined`.\n  var Undefined = NullaryTypeWithUrl('Undefined', typeEq('Undefined'));\n\n  //# Unknown :: Type\n  //.\n  //. Type used to represent missing type information. The type of `[]`,\n  //. for example, is `Array ???`.\n  //.\n  //. May be used with type constructors when defining environments. Given a\n  //. type constructor `List :: Type -> Type`, one could use `List($.Unknown)`\n  //. to include an infinite number of types in an environment:\n  //.\n  //.   - `List Number`\n  //.   - `List String`\n  //.   - `List (List Number)`\n  //.   - `List (List String)`\n  //.   - `List (List (List Number))`\n  //.   - `List (List (List String))`\n  //.   - `...`\n  var Unknown =\n  new _Type(UNKNOWN, '', '', always2('Unknown'), K(true), [], {});\n\n  //# ValidDate :: Type\n  //.\n  //. Type comprising every [`Date`][] value except `new Date(NaN)`.\n  var ValidDate = NullaryTypeWithUrl(\n    'sanctuary-def/ValidDate',\n    function(x) { return Date_._test(x) && !isNaN(x.valueOf()); }\n  );\n\n  //# ValidNumber :: Type\n  //.\n  //. Type comprising every [`Number`][] value except `NaN`.\n  var ValidNumber = NullaryTypeWithUrl(\n    'sanctuary-def/ValidNumber',\n    function(x) { return Number_._test(x) && !isNaN(x); }\n  );\n\n  //# env :: Array Type\n  //.\n  //. An array of [types][]:\n  //.\n  //.   - <code>[AnyFunction](#AnyFunction)</code>\n  //.   - <code>[Arguments](#Arguments)</code>\n  //.   - <code>[Array](#Array)([Unknown](#Unknown))</code>\n  //.   - <code>[Boolean](#Boolean)</code>\n  //.   - <code>[Date](#Date)</code>\n  //.   - <code>[Error](#Error)</code>\n  //.   - <code>[Null](#Null)</code>\n  //.   - <code>[Number](#Number)</code>\n  //.   - <code>[Object](#Object)</code>\n  //.   - <code>[RegExp](#RegExp)</code>\n  //.   - <code>[StrMap](#StrMap)([Unknown](#Unknown))</code>\n  //.   - <code>[String](#String)</code>\n  //.   - <code>[Symbol](#Symbol)</code>\n  //.   - <code>[Undefined](#Undefined)</code>\n  var env = [\n    AnyFunction,\n    Arguments,\n    Array_(Unknown),\n    Boolean_,\n    Date_,\n    Error_,\n    Null,\n    Number_,\n    Object_,\n    RegExp_,\n    StrMap(Unknown),\n    String_,\n    Symbol_,\n    Undefined\n  ];\n\n  //  Unchecked :: String -> Type\n  function Unchecked(s) { return NullaryType(s, '', K(true)); }\n\n  var def = _create({checkTypes: true, env: env});\n\n  //  arity :: (Number, Function) -> Function\n  function arity(n, f) {\n    return (\n      n === 0 ?\n        function() {\n          return f.apply(this, arguments);\n        } :\n      n === 1 ?\n        function($1) {\n          return f.apply(this, arguments);\n        } :\n      n === 2 ?\n        function($1, $2) {\n          return f.apply(this, arguments);\n        } :\n      n === 3 ?\n        function($1, $2, $3) {\n          return f.apply(this, arguments);\n        } :\n      n === 4 ?\n        function($1, $2, $3, $4) {\n          return f.apply(this, arguments);\n        } :\n      n === 5 ?\n        function($1, $2, $3, $4, $5) {\n          return f.apply(this, arguments);\n        } :\n      n === 6 ?\n        function($1, $2, $3, $4, $5, $6) {\n          return f.apply(this, arguments);\n        } :\n      n === 7 ?\n        function($1, $2, $3, $4, $5, $6, $7) {\n          return f.apply(this, arguments);\n        } :\n      n === 8 ?\n        function($1, $2, $3, $4, $5, $6, $7, $8) {\n          return f.apply(this, arguments);\n        } :\n      // else\n        function($1, $2, $3, $4, $5, $6, $7, $8, $9) {\n          return f.apply(this, arguments);\n        }\n    );\n  }\n\n  //  numArgs :: Number -> String\n  function numArgs(n) {\n    switch (n) {\n      case  0:  return  'zero arguments';\n      case  1:  return   'one argument';\n      case  2:  return   'two arguments';\n      case  3:  return 'three arguments';\n      case  4:  return  'four arguments';\n      case  5:  return  'five arguments';\n      case  6:  return   'six arguments';\n      case  7:  return 'seven arguments';\n      case  8:  return 'eight arguments';\n      case  9:  return  'nine arguments';\n      default:  return  n + ' arguments';\n    }\n  }\n\n  //  expandUnknown :: ... -> Array Type\n  function expandUnknown(\n    env,            // :: Array Type\n    seen,           // :: Array Object\n    value,          // :: Any\n    r               // :: { extractor :: a -> Array b, type :: Type }\n  ) {\n    return r.type.type === UNKNOWN ?\n      _determineActualTypes(env, seen, r.extractor(value)) :\n      [r.type];\n  }\n\n  //  _determineActualTypes :: ... -> Array Type\n  function _determineActualTypes(\n    env,            // :: Array Type\n    seen,           // :: Array Object\n    values          // :: Array Any\n  ) {\n    function refine(types, value) {\n      var seen$;\n      if (typeof value === 'object' && value != null ||\n          typeof value === 'function') {\n        //  Abort if a circular reference is encountered; add the current\n        //  object to the array of seen objects otherwise.\n        if (seen.indexOf(value) >= 0) return [];\n        seen$ = Z.concat(seen, [value]);\n      } else {\n        seen$ = seen;\n      }\n      return Z.chain(function(t) {\n        return (\n          t.name === 'sanctuary-def/Nullable' || t.validate(value).isLeft ?\n            [] :\n          t.type === UNARY ?\n            Z.map(fromUnaryType(t),\n                  expandUnknown(env, seen$, value, t.types.$1)) :\n          t.type === BINARY ?\n            xprod(t,\n                  expandUnknown(env, seen$, value, t.types.$1),\n                  expandUnknown(env, seen$, value, t.types.$2)) :\n          // else\n            [t]\n        );\n      }, types);\n    }\n\n    return isEmpty(values) ?\n      [Unknown] :\n      or(Z.reduce(refine, env, values), [Inconsistent]);\n  }\n\n  //  isConsistent :: Type -> Boolean\n  function isConsistent(t) {\n    return t.type === UNARY   ? isConsistent(t.types.$1.type) :\n           t.type === BINARY  ? isConsistent(t.types.$1.type) &&\n                                isConsistent(t.types.$2.type) :\n           /* else */           t.type !== INCONSISTENT;\n  }\n\n  //  determineActualTypesStrict :: (Array Type, Array Any) -> Array Type\n  function determineActualTypesStrict(env, values) {\n    return _determineActualTypes(env, [], values)\n           .filter(isConsistent);\n  }\n\n  //  determineActualTypesLoose :: (Array Type, Array Any) -> Array Type\n  function determineActualTypesLoose(env, values) {\n    return _determineActualTypes(env, [], values)\n           .filter(function(t) { return t.type !== INCONSISTENT; });\n  }\n\n  //  TypeInfo = { name :: String\n  //             , constraints :: StrMap (Array TypeClass)\n  //             , types :: Array Type }\n  //\n  //  TypeVarMap = StrMap { types :: Array Type\n  //                      , valuesByPath :: StrMap (Array Any) }\n  //\n  //  PropPath = Array (Number | String)\n\n  //  updateTypeVarMap :: ... -> TypeVarMap\n  function updateTypeVarMap(\n    env,            // :: Array Type\n    typeVarMap,     // :: TypeVarMap\n    typeVar,        // :: Type\n    index,          // :: Integer\n    propPath,       // :: PropPath\n    values          // :: Array Any\n  ) {\n    var $typeVarMap = {};\n    for (var typeVarName in typeVarMap) {\n      var entry = typeVarMap[typeVarName];\n      var $entry = {types: entry.types.slice(), valuesByPath: {}};\n      for (var k in entry.valuesByPath) {\n        $entry.valuesByPath[k] = entry.valuesByPath[k].slice();\n      }\n      $typeVarMap[typeVarName] = $entry;\n    }\n    if (!hasOwnProperty.call($typeVarMap, typeVar.name)) {\n      $typeVarMap[typeVar.name] = {types: env.slice(), valuesByPath: {}};\n    }\n\n    var key = JSON.stringify(Z.concat([index], propPath));\n    if (!hasOwnProperty.call($typeVarMap[typeVar.name].valuesByPath, key)) {\n      $typeVarMap[typeVar.name].valuesByPath[key] = [];\n    }\n\n    var isNullaryTypeVar = isEmpty(typeVar.keys);\n\n    values.forEach(function(value) {\n      $typeVarMap[typeVar.name].valuesByPath[key].push(value);\n      $typeVarMap[typeVar.name].types = Z.chain(\n        function(t) {\n          var xs;\n          var invalid = !test(env, t, value);\n          return (\n            invalid ?\n              [] :\n            t.type === UNARY ?\n              isNullaryTypeVar &&\n              t.types.$1.type.type === UNKNOWN &&\n              !isEmpty(xs = t.types.$1.extractor(value)) ?\n                Z.map(fromUnaryType(t),\n                      determineActualTypesStrict(env, xs)) :\n                [t] :\n            t.type === BINARY ?\n              isNullaryTypeVar ?\n                xprod(t,\n                      t.types.$1.type.type === UNKNOWN &&\n                      !isEmpty(xs = t.types.$1.extractor(value)) ?\n                        determineActualTypesStrict(env, xs) :\n                        [t.types.$1.type],\n                      t.types.$2.type.type === UNKNOWN &&\n                      !isEmpty(xs = t.types.$2.extractor(value)) ?\n                        determineActualTypesStrict(env, xs) :\n                        [t.types.$2.type]) :\n                [t] :\n            // else\n              [t]\n          );\n        },\n        $typeVarMap[typeVar.name].types\n      );\n    });\n\n    return $typeVarMap;\n  }\n\n  //  underlineTypeVars :: (TypeInfo, StrMap (Array Any)) -> String\n  function underlineTypeVars(typeInfo, valuesByPath) {\n    //  Note: Sorting these keys lexicographically is not \"correct\", but it\n    //  does the right thing for indexes less than 10.\n    var paths = Z.map(JSON.parse, Object.keys(valuesByPath).sort());\n    return underline(\n      typeInfo,\n      K(K(_)),\n      function(index) {\n        return function(f) {\n          return function(t) {\n            return function(propPath) {\n              var indexedPropPath = Z.concat([index], propPath);\n              return function(s) {\n                if (paths.some(isPrefix(indexedPropPath))) {\n                  var key = JSON.stringify(indexedPropPath);\n                  if (!hasOwnProperty.call(valuesByPath, key)) return s;\n                  if (!isEmpty(valuesByPath[key])) return f(s);\n                }\n                return _(s);\n              };\n            };\n          };\n        };\n      }\n    );\n  }\n\n  //  satisfactoryTypes ::\n  //    ... -> Either (() -> Error) { typeVarMap :: TypeVarMap\n  //                                , types :: Array Type }\n  function satisfactoryTypes(\n    env,            // :: Array Type\n    typeInfo,       // :: TypeInfo\n    typeVarMap,     // :: TypeVarMap\n    expType,        // :: Type\n    index,          // :: Integer\n    propPath,       // :: PropPath\n    values          // :: Array Any\n  ) {\n    var recur = satisfactoryTypes;\n\n    for (var idx = 0; idx < values.length; idx += 1) {\n      var result = expType.validate(values[idx]);\n      if (result.isLeft) {\n        return Left(function() {\n          return invalidValue(env,\n                              typeInfo,\n                              index,\n                              result.value.propPath,\n                              result.value.value);\n        });\n      }\n    }\n\n    switch (expType.type) {\n\n      case VARIABLE:\n        var typeVarName = expType.name;\n        var constraints = typeInfo.constraints;\n        if (hasOwnProperty.call(constraints, typeVarName)) {\n          var typeClasses = constraints[typeVarName];\n          for (idx = 0; idx < values.length; idx += 1) {\n            for (var idx2 = 0; idx2 < typeClasses.length; idx2 += 1) {\n              if (!typeClasses[idx2].test(values[idx])) {\n                return Left(function() {\n                  return typeClassConstraintViolation(\n                    env,\n                    typeInfo,\n                    typeClasses[idx2],\n                    index,\n                    propPath,\n                    values[idx],\n                    typeVarMap\n                  );\n                });\n              }\n            }\n          }\n        }\n\n        var typeVarMap$ = updateTypeVarMap(env,\n                                           typeVarMap,\n                                           expType,\n                                           index,\n                                           propPath,\n                                           values);\n\n        var okTypes = typeVarMap$[typeVarName].types;\n        return isEmpty(okTypes) && !isEmpty(values) ?\n          Left(function() {\n            return typeVarConstraintViolation(\n              env,\n              typeInfo,\n              index,\n              propPath,\n              typeVarMap$[typeVarName].valuesByPath\n            );\n          }) :\n          Z.reduce(function(e, t) {\n            return isEmpty(expType.keys) || isEmpty(t.keys) ?\n              e :\n              Z.chain(function(r) {\n                //  The `a` in `Functor f => f a` corresponds to the `a`\n                //  in `Maybe a` but to the `b` in `Either a b`. A type\n                //  variable's $1 will correspond to either $1 or $2 of\n                //  the actual type depending on the actual type's arity.\n                var offset = t.keys.length - expType.keys.length;\n                return expType.keys.reduce(function(e, k, idx) {\n                  var extractor = t.types[t.keys[offset + idx]].extractor;\n                  var innerValues = Z.chain(extractor, values);\n                  return Z.chain(\n                    function(r) {\n                      return recur(env,\n                                   typeInfo,\n                                   r.typeVarMap,\n                                   expType.types[k].type,\n                                   index,\n                                   Z.concat(propPath, [k]),\n                                   innerValues);\n                    },\n                    Z.reduce(function(e, x) {\n                      var t = expType.types[k].type;\n                      return Z.chain(function(r) {\n                        return test(env, t, x) ? Right(r) : Left(function() {\n                          var propPath$ = Z.concat(propPath, [k]);\n                          return t.type === VARIABLE ?\n                            typeVarConstraintViolation(\n                              env,\n                              typeInfo,\n                              index,\n                              propPath$,\n                              singleton(JSON.stringify(Z.concat([index],\n                                                                propPath$)),\n                                        [x])\n                            ) :\n                            invalidValue(env, typeInfo, index, propPath$, x);\n                        });\n                      }, e);\n                    }, e, innerValues)\n                  );\n                }, Right(r));\n              }, e);\n          }, Right({typeVarMap: typeVarMap$, types: okTypes}), okTypes);\n\n      case UNARY:\n        return Z.map(\n          function(result) {\n            return {\n              typeVarMap: result.typeVarMap,\n              types: Z.map(fromUnaryType(expType),\n                           or(result.types, [expType.types.$1.type]))\n            };\n          },\n          recur(env,\n                typeInfo,\n                typeVarMap,\n                expType.types.$1.type,\n                index,\n                Z.concat(propPath, ['$1']),\n                Z.chain(expType.types.$1.extractor, values))\n        );\n\n      case BINARY:\n        return Z.chain(\n          function(result) {\n            var $1s = result.types;\n            return Z.map(\n              function(result) {\n                var $2s = result.types;\n                return {\n                  typeVarMap: result.typeVarMap,\n                  types: xprod(expType,\n                               or($1s, [expType.types.$1.type]),\n                               or($2s, [expType.types.$2.type]))\n                };\n              },\n              recur(env,\n                    typeInfo,\n                    result.typeVarMap,\n                    expType.types.$2.type,\n                    index,\n                    Z.concat(propPath, ['$2']),\n                    Z.chain(expType.types.$2.extractor, values))\n            );\n          },\n          recur(env,\n                typeInfo,\n                typeVarMap,\n                expType.types.$1.type,\n                index,\n                Z.concat(propPath, ['$1']),\n                Z.chain(expType.types.$1.extractor, values))\n        );\n\n      case RECORD:\n        return Z.reduce(function(e, k) {\n          return Z.chain(function(r) {\n            return recur(env,\n                         typeInfo,\n                         r.typeVarMap,\n                         expType.types[k].type,\n                         index,\n                         Z.concat(propPath, [k]),\n                         Z.chain(expType.types[k].extractor, values));\n          }, e);\n        }, Right({typeVarMap: typeVarMap, types: [expType]}), expType.keys);\n\n      default:\n        return Right({typeVarMap: typeVarMap, types: [expType]});\n    }\n  }\n\n  //# test :: Array Type -> Type -> a -> Boolean\n  //.\n  //. Takes an environment, a type, and any value. Returns `true` if the value\n  //. is a member of the type; `false` otherwise.\n  //.\n  //. The environment is only significant if the type contains\n  //. [type variables][].\n  //.\n  //. One may define a more restrictive type in terms of a more general one:\n  //.\n  //. ```javascript\n  //. //    NonNegativeInteger :: Type\n  //. const NonNegativeInteger = $.NullaryType(\n  //.   'my-package/NonNegativeInteger',\n  //.   'http://example.com/my-package#NonNegativeInteger',\n  //.   x => $.test([], $.Integer, x) && x >= 0\n  //. );\n  //. ```\n  //.\n  //. Using types as predicates is useful in other contexts too. One could,\n  //. for example, define a [record type][] for each endpoint of a REST API\n  //. and validate the bodies of incoming POST requests against these types.\n  function test(env, t, x) {\n    var typeInfo = {name: 'name', constraints: {}, types: [t]};\n    return satisfactoryTypes(env, typeInfo, {}, t, 0, [], [x]).isRight;\n  }\n\n  //. ### Type constructors\n  //.\n  //. sanctuary-def provides several functions for defining types.\n\n  //# NullaryType :: String -> String -> (Any -> Boolean) -> Type\n  //.\n  //. Type constructor for types with no type variables (such as [`Number`][]).\n  //.\n  //. To define a nullary type `t` one must provide:\n  //.\n  //.   - the name of `t` (exposed as `t.name`);\n  //.\n  //.   - the documentation URL of `t` (exposed as `t.url`); and\n  //.\n  //.   - a predicate which accepts any JavaScript value and returns `true` if\n  //.     (and only if) the value is a member of `t`.\n  //.\n  //. For example:\n  //.\n  //. ```javascript\n  //. //    Integer :: Type\n  //. const Integer = $.NullaryType(\n  //.   'my-package/Integer',\n  //.   'http://example.com/my-package#Integer',\n  //.   x => typeof x === 'number' &&\n  //.        Math.floor(x) === x &&\n  //.        x >= Number.MIN_SAFE_INTEGER &&\n  //.        x <= Number.MAX_SAFE_INTEGER\n  //. );\n  //.\n  //. //    NonZeroInteger :: Type\n  //. const NonZeroInteger = $.NullaryType(\n  //.   'my-package/NonZeroInteger',\n  //.   'http://example.com/my-package#NonZeroInteger',\n  //.   x => $.test([], Integer, x) && x !== 0\n  //. );\n  //.\n  //. //    rem :: Integer -> NonZeroInteger -> Integer\n  //. const rem =\n  //. def('rem', {}, [Integer, NonZeroInteger, Integer], (x, y) => x % y);\n  //.\n  //. rem(42, 5);\n  //. // => 2\n  //.\n  //. rem(0.5);\n  //. // ! TypeError: Invalid value\n  //. //\n  //. //   rem :: Integer -> NonZeroInteger -> Integer\n  //. //          ^^^^^^^\n  //. //             1\n  //. //\n  //. //   1)  0.5 :: Number\n  //. //\n  //. //   The value at position 1 is not a member of Integer.\n  //.\n  //. rem(42, 0);\n  //. // ! TypeError: Invalid value\n  //. //\n  //. //   rem :: Integer -> NonZeroInteger -> Integer\n  //. //                     ^^^^^^^^^^^^^^\n  //. //                           1\n  //. //\n  //. //   1)  0 :: Number\n  //. //\n  //. //   The value at position 1 is not a member of NonZeroInteger.\n  //. ```\n  function NullaryType(name, url, test) {\n    function format(outer, inner) {\n      return outer(stripNamespace(name));\n    }\n    return new _Type(NULLARY, name, url, format, test, [], {});\n  }\n\n  var CheckedNullaryType =\n  def('NullaryType',\n      {},\n      [String_, String_, Function_([Any, Boolean_]), Type],\n      NullaryType);\n\n  //# UnaryType :: String -> String -> (Any -> Boolean) -> (t a -> Array a) -> (Type -> Type)\n  //.\n  //. Type constructor for types with one type variable (such as [`Array`][]).\n  //.\n  //. To define a unary type `t a` one must provide:\n  //.\n  //.   - the name of `t` (exposed as `t.name`);\n  //.\n  //.   - the documentation URL of `t` (exposed as `t.url`);\n  //.\n  //.   - a predicate which accepts any JavaScript value and returns `true`\n  //.     if (and only if) the value is a member of `t x` for some type `x`;\n  //.\n  //.   - a function which takes any value of type `t a` and returns an array\n  //.     of the values of type `a` contained in the `t` (exposed as\n  //.     `t.types.$1.extractor`); and\n  //.\n  //.   - the type of `a` (exposed as `t.types.$1.type`).\n  //.\n  //. For example:\n  //.\n  //. ```javascript\n  //. const type = require('sanctuary-type-identifiers');\n  //.\n  //. //    maybeTypeIdent :: String\n  //. const maybeTypeIdent = 'my-package/Maybe';\n  //.\n  //. //    Maybe :: Type -> Type\n  //. const Maybe = $.UnaryType(\n  //.   maybeTypeIdent,\n  //.   'http://example.com/my-package#Maybe',\n  //.   x => type(x) === maybeTypeIdent,\n  //.   maybe => maybe.isJust ? [maybe.value] : []\n  //. );\n  //.\n  //. //    MaybeTypeRep :: TypeRep Maybe\n  //. const MaybeTypeRep = {'@@type': maybeTypeIdent};\n  //.\n  //. //    Nothing :: Maybe a\n  //. const Nothing = {\n  //.   constructor: MaybeTypeRep,\n  //.   isJust: false,\n  //.   isNothing: true,\n  //.   toString: () => 'Nothing',\n  //. };\n  //.\n  //. //    Just :: a -> Maybe a\n  //. const Just = x => ({\n  //.   constructor: MaybeTypeRep,\n  //.   isJust: true,\n  //.   isNothing: false,\n  //.   toString: () => 'Just(' + Z.toString(x) + ')',\n  //.   value: x,\n  //. });\n  //.\n  //. //    fromMaybe :: a -> Maybe a -> a\n  //. const fromMaybe =\n  //. def('fromMaybe', {}, [a, Maybe(a), a], (x, m) => m.isJust ? m.value : x);\n  //.\n  //. fromMaybe(0, Just(42));\n  //. // => 42\n  //.\n  //. fromMaybe(0, Nothing);\n  //. // => 0\n  //.\n  //. fromMaybe(0, Just('XXX'));\n  //. // ! TypeError: Type-variable constraint violation\n  //. //\n  //. //   fromMaybe :: a -> Maybe a -> a\n  //. //                ^          ^\n  //. //                1          2\n  //. //\n  //. //   1)  0 :: Number\n  //. //\n  //. //   2)  \"XXX\" :: String\n  //. //\n  //. //   Since there is no type of which all the above values are members, the type-variable constraint has been violated.\n  //. ```\n  function UnaryType(name, url, test, _1) {\n    return function($1) {\n      function format(outer, inner) {\n        return outer('(' + stripNamespace(name) + ' ') +\n               inner('$1')(String($1)) + outer(')');\n      }\n      var types = {$1: {extractor: _1, type: $1}};\n      return new _Type(UNARY, name, url, format, test, ['$1'], types);\n    };\n  }\n\n  var CheckedUnaryType =\n  def('UnaryType',\n      {},\n      [String_,\n       String_,\n       Function_([Any, Boolean_]),\n       Function_([Unchecked('t a'), Array_(Unchecked('a'))]),\n       AnyFunction],\n      function(name, url, test, _1) {\n        return def(stripNamespace(name),\n                   {},\n                   [Type, Type],\n                   UnaryType(name, url, test, _1));\n      });\n\n  //  fromUnaryType :: Type -> (Type -> Type)\n  function fromUnaryType(t) {\n    return UnaryType(t.name, t.url, t._test, t.types.$1.extractor);\n  }\n\n  //# BinaryType :: String -> String -> (Any -> Boolean) -> (t a b -> Array a) -> (t a b -> Array b) -> (Type -> Type -> Type)\n  //.\n  //. Type constructor for types with two type variables (such as [`Pair`][]).\n  //.\n  //. To define a binary type `t a b` one must provide:\n  //.\n  //.   - the name of `t` (exposed as `t.name`);\n  //.\n  //.   - the documentation URL of `t` (exposed as `t.url`);\n  //.\n  //.   - a predicate which accepts any JavaScript value and returns `true`\n  //.     if (and only if) the value is a member of `t x y` for some types\n  //.     `x` and `y`;\n  //.\n  //.   - a function which takes any value of type `t a b` and returns an array\n  //.     of the values of type `a` contained in the `t` (exposed as\n  //.     `t.types.$1.extractor`);\n  //.\n  //.   - a function which takes any value of type `t a b` and returns an array\n  //.     of the values of type `b` contained in the `t` (exposed as\n  //.     `t.types.$2.extractor`);\n  //.\n  //.   - the type of `a` (exposed as `t.types.$1.type`); and\n  //.\n  //.   - the type of `b` (exposed as `t.types.$2.type`).\n  //.\n  //. For example:\n  //.\n  //. ```javascript\n  //. const type = require('sanctuary-type-identifiers');\n  //.\n  //. //    pairTypeIdent :: String\n  //. const pairTypeIdent = 'my-package/Pair';\n  //.\n  //. //    $Pair :: Type -> Type -> Type\n  //. const $Pair = $.BinaryType(\n  //.   pairTypeIdent,\n  //.   'http://example.com/my-package#Pair',\n  //.   x => type(x) === pairTypeIdent,\n  //.   pair => [pair[0]],\n  //.   pair => [pair[1]]\n  //. );\n  //.\n  //. //    PairTypeRep :: TypeRep Pair\n  //. const PairTypeRep = {'@@type': pairTypeIdent};\n  //.\n  //. //    Pair :: a -> b -> Pair a b\n  //. const Pair = def('Pair', {}, [a, b, $Pair(a, b)], (x, y) => ({\n  //.   '0': x,\n  //.   '1': y,\n  //.   constructor: PairTypeRep,\n  //.   length: 2,\n  //.   toString: () => 'Pair(' + Z.toString(x) + ', ' + Z.toString(y) + ')',\n  //. }));\n  //.\n  //. //    Rank :: Type\n  //. const Rank = $.NullaryType(\n  //.   'my-package/Rank',\n  //.   'http://example.com/my-package#Rank',\n  //.   x => typeof x === 'string' && /^([A23456789JQK]|10)$/.test(x)\n  //. );\n  //.\n  //. //    Suit :: Type\n  //. const Suit = $.NullaryType(\n  //.   'my-package/Suit',\n  //.   'http://example.com/my-package#Suit',\n  //.   x => typeof x === 'string' && /^[\\u2660\\u2663\\u2665\\u2666]$/.test(x)\n  //. );\n  //.\n  //. //    Card :: Type\n  //. const Card = $Pair(Rank, Suit);\n  //.\n  //. //    showCard :: Card -> String\n  //. const showCard =\n  //. def('showCard', {}, [Card, $.String], card => card[0] + card[1]);\n  //.\n  //. showCard(Pair('A', ''));\n  //. // => 'A'\n  //.\n  //. showCard(Pair('X', ''));\n  //. // ! TypeError: Invalid value\n  //. //\n  //. //   showCard :: Pair Rank Suit -> String\n  //. //                    ^^^^\n  //. //                     1\n  //. //\n  //. //   1)  \"X\" :: String\n  //. //\n  //. //   The value at position 1 is not a member of Rank.\n  //. ```\n  function BinaryType(name, url, test, _1, _2) {\n    return function($1, $2) {\n      function format(outer, inner) {\n        return outer('(' + stripNamespace(name) + ' ') +\n               inner('$1')(String($1)) + outer(' ') +\n               inner('$2')(String($2)) + outer(')');\n      }\n      var types = {$1: {extractor: _1, type: $1},\n                   $2: {extractor: _2, type: $2}};\n      return new _Type(BINARY, name, url, format, test, ['$1', '$2'], types);\n    };\n  }\n\n  var CheckedBinaryType =\n  def('BinaryType',\n      {},\n      [String_,\n       String_,\n       Function_([Any, Boolean_]),\n       Function_([Unchecked('t a b'), Array_(Unchecked('a'))]),\n       Function_([Unchecked('t a b'), Array_(Unchecked('b'))]),\n       AnyFunction],\n      function(name, url, test, _1, _2) {\n        return def(stripNamespace(name),\n                   {},\n                   [Type, Type, Type],\n                   BinaryType(name, url, test, _1, _2));\n      });\n\n  //  xprod :: (Type, Array Type, Array Type) -> Array Type\n  function xprod(t, $1s, $2s) {\n    var specialize = BinaryType(t.name,\n                                t.url,\n                                t._test,\n                                t.types.$1.extractor,\n                                t.types.$2.extractor);\n    var $types = [];\n    $1s.forEach(function($1) {\n      $2s.forEach(function($2) {\n        $types.push(specialize($1, $2));\n      });\n    });\n    return $types;\n  }\n\n  //# EnumType :: String -> String -> Array Any -> Type\n  //.\n  //. Type constructor for [enumerated types][] (such as [`RegexFlags`][]).\n  //.\n  //. To define an enumerated type `t` one must provide:\n  //.\n  //.   - the name of `t` (exposed as `t.name`);\n  //.\n  //.   - the documentation URL of `t` (exposed as `t.url`); and\n  //.\n  //.   - an array of distinct values.\n  //.\n  //. For example:\n  //.\n  //. ```javascript\n  //. //    Denomination :: Type\n  //. const Denomination = $.EnumType(\n  //.   'my-package/Denomination',\n  //.   'http://example.com/my-package#Denomination',\n  //.   [10, 20, 50, 100, 200]\n  //. );\n  //. ```\n  function EnumType(name, url, members) {\n    return NullaryType(name, url, memberOf(members));\n  }\n\n  var CheckedEnumType =\n  def('EnumType', {}, [String_, String_, Array_(Any), Type], EnumType);\n\n  //# RecordType :: StrMap Type -> Type\n  //.\n  //. `RecordType` is used to construct record types. The type definition\n  //. specifies the name and type of each required field.\n  //.\n  //. To define a record type one must provide:\n  //.\n  //.   - an object mapping field name to type.\n  //.\n  //. For example:\n  //.\n  //. ```javascript\n  //. //    Point :: Type\n  //. const Point = $.RecordType({x: $.FiniteNumber, y: $.FiniteNumber});\n  //.\n  //. //    dist :: Point -> Point -> FiniteNumber\n  //. const dist =\n  //. def('dist', {}, [Point, Point, $.FiniteNumber],\n  //.     (p, q) => Math.sqrt(Math.pow(p.x - q.x, 2) +\n  //.                         Math.pow(p.y - q.y, 2)));\n  //.\n  //. dist({x: 0, y: 0}, {x: 3, y: 4});\n  //. // => 5\n  //.\n  //. dist({x: 0, y: 0}, {x: 3, y: 4, color: 'red'});\n  //. // => 5\n  //.\n  //. dist({x: 0, y: 0}, {x: NaN, y: NaN});\n  //. // ! TypeError: Invalid value\n  //. //\n  //. //   dist :: { x :: FiniteNumber, y :: FiniteNumber } -> { x :: FiniteNumber, y :: FiniteNumber } -> FiniteNumber\n  //. //                                                              ^^^^^^^^^^^^\n  //. //                                                                   1\n  //. //\n  //. //   1)  NaN :: Number\n  //. //\n  //. //   The value at position 1 is not a member of FiniteNumber.\n  //.\n  //. dist(0);\n  //. // ! TypeError: Invalid value\n  //. //\n  //. //   dist :: { x :: FiniteNumber, y :: FiniteNumber } -> { x :: FiniteNumber, y :: FiniteNumber } -> FiniteNumber\n  //. //           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  //. //                              1\n  //. //\n  //. //   1)  0 :: Number\n  //. //\n  //. //   The value at position 1 is not a member of { x :: FiniteNumber, y :: FiniteNumber }.\n  //. ```\n  function RecordType(fields) {\n    var keys = Object.keys(fields).sort();\n\n    function format(outer, inner) {\n      return wrap(outer('{'))(outer(' }'))(Z.map(function(k) {\n        var t = fields[k];\n        return outer(' ' + k + ' :: ') +\n               unless(t.type === RECORD || isEmpty(t.keys),\n                      stripOutermostParens,\n                      inner(k)(String(t)));\n      }, keys).join(outer(',')));\n    }\n\n    function test(x) {\n      return x != null &&\n             keys.every(function(k) { return hasOwnProperty.call(x, k); });\n    }\n\n    var $types = {};\n    keys.forEach(function(k) {\n      $types[k] = {extractor: function(x) { return [x[k]]; }, type: fields[k]};\n    });\n\n    return new _Type(RECORD, '', '', format, test, keys, $types);\n  }\n\n  var CheckedRecordType =\n  def('RecordType', {}, [StrMap(Type), Type], RecordType);\n\n  //# TypeVariable :: String -> Type\n  //.\n  //. Polymorphism is powerful. Not being able to define a function for\n  //. all types would be very limiting indeed: one couldn't even define the\n  //. identity function!\n  //.\n  //. Before defining a polymorphic function one must define one or more type\n  //. variables:\n  //.\n  //. ```javascript\n  //. const a = $.TypeVariable('a');\n  //. const b = $.TypeVariable('b');\n  //.\n  //. //    id :: a -> a\n  //. const id = def('id', {}, [a, a], x => x);\n  //.\n  //. id(42);\n  //. // => 42\n  //.\n  //. id(null);\n  //. // => null\n  //. ```\n  //.\n  //. The same type variable may be used in multiple positions, creating a\n  //. constraint:\n  //.\n  //. ```javascript\n  //. //    cmp :: a -> a -> Number\n  //. const cmp =\n  //. def('cmp', {}, [a, a, $.Number], (x, y) => x < y ? -1 : x > y ? 1 : 0);\n  //.\n  //. cmp(42, 42);\n  //. // => 0\n  //.\n  //. cmp('a', 'z');\n  //. // => -1\n  //.\n  //. cmp('z', 'a');\n  //. // => 1\n  //.\n  //. cmp(0, '1');\n  //. // ! TypeError: Type-variable constraint violation\n  //. //\n  //. //   cmp :: a -> a -> Number\n  //. //          ^    ^\n  //. //          1    2\n  //. //\n  //. //   1)  0 :: Number\n  //. //\n  //. //   2)  \"1\" :: String\n  //. //\n  //. //   Since there is no type of which all the above values are members, the type-variable constraint has been violated.\n  //. ```\n  function TypeVariable(name) {\n    return new _Type(VARIABLE, name, '', always2(name), K(true), [], {});\n  }\n\n  var CheckedTypeVariable =\n  def('TypeVariable', {}, [String_, Type], TypeVariable);\n\n  //# UnaryTypeVariable :: String -> (Type -> Type)\n  //.\n  //. Combines [`UnaryType`][] and [`TypeVariable`][].\n  //.\n  //. To define a unary type variable `t a` one must provide:\n  //.\n  //.   - a name (conventionally matching `^[a-z]$`); and\n  //.\n  //.   - the type of `a` (exposed as `t.types.$1.type`).\n  //.\n  //. Consider the type of a generalized `map`:\n  //.\n  //. ```haskell\n  //. map :: Functor f => (a -> b) -> f a -> f b\n  //. ```\n  //.\n  //. `f` is a unary type variable. With two (nullary) type variables, one\n  //. unary type variable, and one [type class][] it's possible to define a\n  //. fully polymorphic `map` function:\n  //.\n  //. ```javascript\n  //. const $ = require('sanctuary-def');\n  //. const Z = require('sanctuary-type-classes');\n  //.\n  //. const a = $.TypeVariable('a');\n  //. const b = $.TypeVariable('b');\n  //. const f = $.UnaryTypeVariable('f');\n  //.\n  //. //    map :: Functor f => (a -> b) -> f a -> f b\n  //. const map =\n  //. def('map',\n  //.     {f: [Z.Functor]},\n  //.     [$.Function([a, b]), f(a), f(b)],\n  //.     Z.map);\n  //. ```\n  //.\n  //. Whereas a regular type variable is fully resolved (`a` might become\n  //. `Array (Array String)`, for example), a unary type variable defers to\n  //. its type argument, which may itself be a type variable. The type argument\n  //. corresponds to the type argument of a unary type or the *second* type\n  //. argument of a binary type. The second type argument of `Map k v`, for\n  //. example, is `v`. One could replace `Functor => f` with `Map k` or with\n  //. `Map Integer`, but not with `Map`.\n  //.\n  //. This shallow inspection makes it possible to constrain a value's \"outer\"\n  //. and \"inner\" types independently.\n  function UnaryTypeVariable(name) {\n    return function($1) {\n      function format(outer, inner) {\n        return outer('(' + name + ' ') + inner('$1')(String($1)) + outer(')');\n      }\n      var types = {$1: {extractor: K([]), type: $1}};\n      return new _Type(VARIABLE, name, '', format, K(true), ['$1'], types);\n    };\n  }\n\n  var CheckedUnaryTypeVariable =\n  def('UnaryTypeVariable',\n      {},\n      [String_, AnyFunction],\n      function(name) {\n        return def(name, {}, [Type, Type], UnaryTypeVariable(name));\n      });\n\n  //# BinaryTypeVariable :: String -> (Type -> Type -> Type)\n  //.\n  //. Combines [`BinaryType`][] and [`TypeVariable`][].\n  //.\n  //. To define a binary type variable `t a b` one must provide:\n  //.\n  //.   - a name (conventionally matching `^[a-z]$`);\n  //.\n  //.   - the type of `a` (exposed as `t.types.$1.type`); and\n  //.\n  //.   - the type of `b` (exposed as `t.types.$2.type`).\n  //.\n  //. The more detailed explanation of [`UnaryTypeVariable`][] also applies to\n  //. `BinaryTypeVariable`.\n  function BinaryTypeVariable(name) {\n    return function($1, $2) {\n      function format(outer, inner) {\n        return outer('(' + name + ' ') + inner('$1')(String($1)) + outer(' ') +\n                                         inner('$2')(String($2)) + outer(')');\n      }\n      var keys = ['$1', '$2'];\n      var types = {$1: {extractor: K([]), type: $1},\n                   $2: {extractor: K([]), type: $2}};\n      return new _Type(VARIABLE, name, '', format, K(true), keys, types);\n    };\n  }\n\n  var CheckedBinaryTypeVariable =\n  def('BinaryTypeVariable',\n      {},\n      [String_, AnyFunction],\n      function(name) {\n        return def(name, {}, [Type, Type, Type], BinaryTypeVariable(name));\n      });\n\n  //# Thunk :: Type -> Type\n  //.\n  //. `$.Thunk(T)` is shorthand for `$.Function([T])`, the type comprising\n  //. every nullary function (thunk) which returns a value of type `T`.\n  var Thunk =\n  def('Thunk',\n      {},\n      [Type, Type],\n      function(t) { return Function_([t]); });\n\n  //# Predicate :: Type -> Type\n  //.\n  //. `$.Predicate(T)` is shorthand for `$.Function([T, $.Boolean])`, the type\n  //. comprising every predicate function which takes a value of type `T`.\n  var Predicate =\n  def('Predicate',\n      {},\n      [Type, Type],\n      function(t) { return Function_([t, Boolean_]); });\n\n  //. ### Type classes\n  //.\n  //. `concatS`, defined earlier, is a function which concatenates two strings.\n  //. This is overly restrictive, since other types support concatenation\n  //. (Array, for example).\n  //.\n  //. One could use a type variable to define a polymorphic \"concat\" function:\n  //.\n  //. ```javascript\n  //. //    _concat :: a -> a -> a\n  //. const _concat =\n  //. def('_concat', {}, [a, a, a], (x, y) => x.concat(y));\n  //.\n  //. _concat('fizz', 'buzz');\n  //. // => 'fizzbuzz'\n  //.\n  //. _concat([1, 2], [3, 4]);\n  //. // => [1, 2, 3, 4]\n  //.\n  //. _concat([1, 2], 'buzz');\n  //. // ! TypeError: Type-variable constraint violation\n  //. //\n  //. //   _concat :: a -> a -> a\n  //. //              ^    ^\n  //. //              1    2\n  //. //\n  //. //   1)  [1, 2] :: Array Number\n  //. //\n  //. //   2)  \"buzz\" :: String\n  //. //\n  //. //   Since there is no type of which all the above values are members, the type-variable constraint has been violated.\n  //. ```\n  //.\n  //. The type of `_concat` is misleading: it suggests that it can operate on\n  //. any two values of *any* one type. In fact there's an implicit constraint,\n  //. since the type must support concatenation (in [mathematical][semigroup]\n  //. terms, the type must have a [semigroup][FL:Semigroup]). The run-time type\n  //. errors that result when this constraint is violated are not particularly\n  //. descriptive:\n  //.\n  //. ```javascript\n  //. _concat({}, {});\n  //. // ! TypeError: undefined is not a function\n  //.\n  //. _concat(null, null);\n  //. // ! TypeError: Cannot read property 'concat' of null\n  //. ```\n  //.\n  //. The solution is to constrain `a` by first defining a [`TypeClass`][]\n  //. value, then specifying the constraint in the definition of the \"concat\"\n  //. function:\n  //.\n  //. ```javascript\n  //. const Z = require('sanctuary-type-classes');\n  //.\n  //. //    Semigroup :: TypeClass\n  //. const Semigroup = Z.TypeClass(\n  //.   'my-package/Semigroup',\n  //.   'http://example.com/my-package#Semigroup',\n  //.   [],\n  //.   x => x != null && typeof x.concat === 'function'\n  //. );\n  //.\n  //. //    concat :: Semigroup a => a -> a -> a\n  //. const concat =\n  //. def('concat', {a: [Semigroup]}, [a, a, a], (x, y) => x.concat(y));\n  //.\n  //. concat([1, 2], [3, 4]);\n  //. // => [1, 2, 3, 4]\n  //.\n  //. concat({}, {});\n  //. // ! TypeError: Type-class constraint violation\n  //. //\n  //. //   concat :: Semigroup a => a -> a -> a\n  //. //             ^^^^^^^^^^^    ^\n  //. //                            1\n  //. //\n  //. //   1)  {} :: Object, StrMap ???\n  //. //\n  //. //   concat requires a to satisfy the Semigroup type-class constraint; the value at position 1 does not.\n  //. //\n  //. //   See http://example.com/my-package#Semigroup for information about the my-package/Semigroup type class.\n  //.\n  //. concat(null, null);\n  //. // ! TypeError: Type-class constraint violation\n  //. //\n  //. //   concat :: Semigroup a => a -> a -> a\n  //. //             ^^^^^^^^^^^    ^\n  //. //                            1\n  //. //\n  //. //   1)  null :: Null\n  //. //\n  //. //   concat requires a to satisfy the Semigroup type-class constraint; the value at position 1 does not.\n  //. //\n  //. //   See http://example.com/my-package#Semigroup for information about the my-package/Semigroup type class.\n  //. ```\n  //.\n  //. Multiple constraints may be placed on a type variable by including\n  //. multiple `TypeClass` values in the array (e.g. `{a: [Foo, Bar, Baz]}`).\n\n  //  checkValue :: ... -> Undefined\n  function checkValue(\n    env,                // :: Array Type\n    typeInfo,           // :: TypeInfo\n    $typeVarMapBox,     // :: Box TypeVarMap\n    index,              // :: Integer\n    propPath,           // :: PropPath\n    t,                  // :: Type\n    value               // :: Any\n  ) {\n    if (t.type === VARIABLE) {\n      $typeVarMapBox[0] =\n        updateTypeVarMap(env, $typeVarMapBox[0], t, index, propPath, [value]);\n      if (isEmpty($typeVarMapBox[0][t.name].types)) {\n        throw typeVarConstraintViolation(\n          env,\n          typeInfo,\n          index,\n          propPath,\n          $typeVarMapBox[0][t.name].valuesByPath\n        );\n      }\n    } else if (!test(env, t, value)) {\n      throw invalidValue(env, typeInfo, index, propPath, value);\n    }\n  }\n\n  //  wrapFunction :: ... -> Function\n  function wrapFunction(\n    env,                // :: Array Type\n    typeInfo,           // :: TypeInfo\n    $typeVarMapBox,     // :: Box TypeVarMap\n    index,              // :: Integer\n    f                   // :: Function\n  ) {\n    var expType = typeInfo.types[index];\n    var numArgsExpected = expType.keys.length - 1;\n    return arity(numArgsExpected, function() {\n      var args = slice.call(arguments);\n      if (args.length !== numArgsExpected) {\n        throw invalidArgumentsLength(typeInfo, index, numArgsExpected, args);\n      }\n      function checkValue$(propPath, t, x) {\n        checkValue(env, typeInfo, $typeVarMapBox, index, propPath, t, x);\n      }\n      init(expType.keys).forEach(function(k, idx) {\n        checkValue$([k], expType.types[k].type, args[idx]);\n      });\n\n      var output = f.apply(this, arguments);\n      var k = last(expType.keys);\n      checkValue$([k], expType.types[k].type, output);\n      return output;\n    });\n  }\n\n  //  wrapFunctionCond ::\n  //    Array Type -> TypeInfo -> Box TypeVarMap -> Integer -> a -> a\n  function wrapFunctionCond(env, typeInfo, $typeVarMapBox, index, value) {\n    return typeInfo.types[index].type === FUNCTION ?\n      wrapFunction(env, typeInfo, $typeVarMapBox, index, value) :\n      value;\n  }\n\n  //  wrapFunctions :: ... -> Array Any\n  function wrapFunctions(\n    env,                // :: Array Type\n    typeInfo,           // :: TypeInfo\n    $typeVarMapBox,     // :: Box TypeVarMap\n    values              // :: Array Any\n  ) {\n    return values.map(function(value, idx) {\n      return wrapFunctionCond(env, typeInfo, $typeVarMapBox, idx, value);\n    });\n  }\n\n  //  tooManyArguments :: (TypeInfo, Integer) -> Error\n  //\n  //  This function is used in `curry` when a function defined via `def`\n  //  is applied to too many arguments.\n  function tooManyArguments(typeInfo, numArgsReceived) {\n    var numArgsExpected = typeInfo.types.length - 1;\n    return new TypeError(trimTrailingSpaces(\n      'Function applied to too many arguments\\n\\n' +\n      typeSignature(typeInfo) + '\\n\\n' +\n      q(typeInfo.name) + ' expected' +\n      (numArgsExpected > 0 ? ' at most ' : ' ') + numArgs(numArgsExpected) +\n      ' but received ' + numArgs(numArgsReceived) + '.\\n'\n    ));\n  }\n\n  //  constraintsRepr :: ... -> String\n  function constraintsRepr(\n    constraints,    // :: StrMap (Array TypeClass)\n    outer,          // :: String -> String\n    inner           // :: String -> TypeClass -> String -> String\n  ) {\n    var $reprs = [];\n    Object.keys(constraints).sort().forEach(function(k) {\n      var f = inner(k);\n      constraints[k].forEach(function(typeClass) {\n        $reprs.push(f(typeClass)(stripNamespace(typeClass.name) + ' ' + k));\n      });\n    });\n    return when($reprs.length > 0,\n                function(s) { return s + outer(' => '); },\n                when($reprs.length > 1,\n                     wrap(outer('('))(outer(')')),\n                     $reprs.join(outer(', '))));\n  }\n\n  //  label :: String -> String -> String\n  function label(label) {\n    return function(s) {\n      var delta = s.length - label.length;\n      return strRepeat(' ', Math.floor(delta / 2)) + label +\n             strRepeat(' ', Math.ceil(delta / 2));\n    };\n  }\n\n  //  typeVarNames :: Type -> Array String\n  function typeVarNames(t) {\n    return Z.concat(\n      t.type === VARIABLE ? [t.name] : [],\n      Z.chain(function(k) { return typeVarNames(t.types[k].type); }, t.keys)\n    );\n  }\n\n  //  showTypeWith :: TypeInfo -> Type -> String\n  function showTypeWith(typeInfo) {\n    var names = Z.chain(typeVarNames, typeInfo.types);\n    return function(t) {\n      var code = 'a'.charCodeAt(0);\n      return unless(\n        t.type === FUNCTION || t.type === RECORD || isEmpty(t.keys),\n        stripOutermostParens,\n        String(t).replace(/\\bUnknown\\b/g, function() {\n          // eslint-disable-next-line no-plusplus\n          do var name = String.fromCharCode(code++);\n          while (names.indexOf(name) >= 0);\n          return name;\n        })\n      );\n    };\n  }\n\n  //  showTypeQuoted :: Type -> String\n  function showTypeQuoted(t) {\n    return q(unless(t.type === RECORD || isEmpty(t.keys),\n                    stripOutermostParens,\n                    String(t)));\n  }\n\n  //  showValuesAndTypes :: ... -> String\n  function showValuesAndTypes(\n    env,            // :: Array Type\n    typeInfo,       // :: TypeInfo\n    values,         // :: Array Any\n    pos             // :: Integer\n  ) {\n    var showType = showTypeWith(typeInfo);\n    return String(pos) + ')  ' + Z.map(function(x) {\n      var types = determineActualTypesLoose(env, [x]);\n      return Z.toString(x) + ' :: ' + Z.map(showType, types).join(', ');\n    }, values).join('\\n    ');\n  }\n\n  //  typeSignature :: TypeInfo -> String\n  function typeSignature(typeInfo) {\n    var reprs = Z.map(showTypeWith(typeInfo), typeInfo.types);\n    var arity = reprs.length - 1;\n    return typeInfo.name + ' :: ' +\n             constraintsRepr(typeInfo.constraints, id, K(K(id))) +\n             when(arity === 0, parenthesize, init(reprs).join(' -> ')) +\n             ' -> ' + last(reprs);\n  }\n\n  //  _underline :: ... -> String\n  function _underline(\n    t,              // :: Type\n    propPath,       // :: PropPath\n    formatType3     // :: Type -> Array String -> String -> String\n  ) {\n    return unless(t.type === RECORD ||\n                    isEmpty(t.keys) ||\n                    t.type === FUNCTION && isEmpty(propPath) ||\n                    !isEmpty(propPath),\n                  stripOutermostParens,\n                  formatType3(t)(propPath)(t.format(_, function(k) {\n                    return K(_underline(t.types[k].type,\n                                        Z.concat(propPath, [k]),\n                                        formatType3));\n                  })));\n  }\n\n  //  underline :: ... -> String\n  function underline(\n    typeInfo,               // :: TypeInfo\n    underlineConstraint,    // :: String -> TypeClass -> String -> String\n    formatType5\n    // :: Integer -> (String -> String) -> Type -> PropPath -> String -> String\n  ) {\n    var st = typeInfo.types.reduce(function(st, t, index) {\n      var formatType4 = formatType5(index);\n      var counter = st.counter;\n      function replace(s) { return label(String(counter += 1))(s); }\n      return {\n        carets: Z.concat(st.carets, [_underline(t, [], formatType4(r('^')))]),\n        numbers: Z.concat(st.numbers,\n                          [_underline(t, [], formatType4(replace))]),\n        counter: counter\n      };\n    }, {carets: [], numbers: [], counter: 0});\n\n    return typeSignature(typeInfo) + '\\n' +\n           _(typeInfo.name + ' :: ') +\n             constraintsRepr(typeInfo.constraints, _, underlineConstraint) +\n             st.carets.join(_(' -> ')) + '\\n' +\n           _(typeInfo.name + ' :: ') +\n             constraintsRepr(typeInfo.constraints, _, K(K(_))) +\n             st.numbers.join(_(' -> ')) + '\\n';\n  }\n\n  //  resolvePropPath :: (Type, Array String) -> Type\n  function resolvePropPath(t, propPath) {\n    return Z.reduce(function(t, prop) { return t.types[prop].type; },\n                    t,\n                    propPath);\n  }\n\n  //  formatType6 ::\n  //    PropPath -> Integer -> (String -> String) ->\n  //      Type -> PropPath -> String -> String\n  function formatType6(indexedPropPath) {\n    return function(index_) {\n      return function(f) {\n        return function(t) {\n          return function(propPath_) {\n            var indexedPropPath_ = Z.concat([index_], propPath_);\n            var p = isPrefix(indexedPropPath_)(indexedPropPath);\n            var q = isPrefix(indexedPropPath)(indexedPropPath_);\n            return p && q ? f : p ? id : _;\n          };\n        };\n      };\n    };\n  }\n\n  //  see :: (String, { name :: String, url :: String? }) -> String\n  function see(label, record) {\n    return record.url == null || record.url === '' ?\n           '' :\n           '\\nSee ' + record.url +\n           ' for information about the ' + record.name + ' ' + label + '.\\n';\n  }\n\n  //  typeClassConstraintViolation :: ... -> Error\n  function typeClassConstraintViolation(\n    env,            // :: Array Type\n    typeInfo,       // :: TypeInfo\n    typeClass,      // :: TypeClass\n    index,          // :: Integer\n    propPath,       // :: PropPath\n    value,          // :: Any\n    typeVarMap      // :: TypeVarMap\n  ) {\n    var expType = resolvePropPath(typeInfo.types[index], propPath);\n    return new TypeError(trimTrailingSpaces(\n      'Type-class constraint violation\\n\\n' +\n      underline(typeInfo,\n                function(tvn) {\n                  return function(tc) {\n                    return tvn === expType.name && tc.name === typeClass.name ?\n                      r('^') :\n                      _;\n                  };\n                },\n                formatType6(Z.concat([index], propPath))) +\n      '\\n' +\n      showValuesAndTypes(env, typeInfo, [value], 1) + '\\n\\n' +\n      q(typeInfo.name) + ' requires ' + q(expType.name) + ' to satisfy the ' +\n      stripNamespace(typeClass.name) + ' type-class constraint; ' +\n      'the value at position 1 does not.\\n' +\n      see('type class', typeClass)\n    ));\n  }\n\n  //  typeVarConstraintViolation :: ... -> Error\n  function typeVarConstraintViolation(\n    env,            // :: Array Type\n    typeInfo,       // :: TypeInfo\n    index,          // :: Integer\n    propPath,       // :: PropPath\n    valuesByPath    // :: StrMap (Array Any)\n  ) {\n    //  If we apply an a -> a -> a -> a function to Left('x'), Right(1), and\n    //  Right(null) we'd like to avoid underlining the first argument position,\n    //  since Left('x') is compatible with the other a values.\n    var key = JSON.stringify(Z.concat([index], propPath));\n    var values = valuesByPath[key];\n\n    //  Note: Sorting these keys lexicographically is not \"correct\", but it\n    //  does the right thing for indexes less than 10.\n    var keys = Object.keys(valuesByPath).sort().filter(function(k) {\n      var values_ = valuesByPath[k];\n      return (\n        //  Keep X, the position at which the violation was observed.\n        k === key ||\n        //  Keep positions whose values are incompatible with the values at X.\n        isEmpty(determineActualTypesStrict(env, Z.concat(values, values_)))\n      );\n    });\n\n    var underlinedTypeVars =\n    underlineTypeVars(typeInfo,\n                      Z.reduce(function($valuesByPath, k) {\n                        $valuesByPath[k] = valuesByPath[k];\n                        return $valuesByPath;\n                      }, {}, keys));\n\n    return new TypeError(trimTrailingSpaces(\n      values.length === 1 && isEmpty(determineActualTypesLoose(env, values)) ?\n        'Unrecognized value\\n\\n' +\n        underlinedTypeVars + '\\n' +\n        '1)  ' + Z.toString(values[0]) + ' :: (no types)\\n\\n' +\n        toMarkdownList(\n          'The environment is empty! ' +\n          'Polymorphic functions require a non-empty environment.\\n',\n          'The value at position 1 is not a member of any type in ' +\n          'the environment.\\n\\n' +\n          'The environment contains the following types:\\n\\n',\n          showTypeWith(typeInfo),\n          env\n        ) :\n      // else\n        'Type-variable constraint violation\\n\\n' +\n        underlinedTypeVars + '\\n' +\n        Z.reduce(function(st, k) {\n          var values = valuesByPath[k];\n          return isEmpty(values) ? st : {\n            idx: st.idx + 1,\n            s: st.s +\n               showValuesAndTypes(env, typeInfo, values, st.idx + 1) +\n               '\\n\\n'\n          };\n        }, {idx: 0, s: ''}, keys).s +\n        'Since there is no type of which all the above values are ' +\n        'members, the type-variable constraint has been violated.\\n'\n    ));\n  }\n\n  //  invalidValue :: ... -> Error\n  function invalidValue(\n    env,            // :: Array Type\n    typeInfo,       // :: TypeInfo\n    index,          // :: Integer\n    propPath,       // :: PropPath\n    value           // :: Any\n  ) {\n    var t = resolvePropPath(typeInfo.types[index], propPath);\n    return new TypeError(trimTrailingSpaces(\n      'Invalid value\\n\\n' +\n      underline(typeInfo,\n                K(K(_)),\n                formatType6(Z.concat([index], propPath))) +\n      '\\n' +\n      showValuesAndTypes(env, typeInfo, [value], 1) + '\\n\\n' +\n      'The value at position 1 is not a member of ' + showTypeQuoted(t) + '.' +\n      '\\n' +\n      see('type', t)\n    ));\n  }\n\n  //  invalidArgumentsLength :: ... -> Error\n  //\n  //  This function is used in `wrapFunction` to ensure that higher-order\n  //  functions defined via `def` only ever apply a function argument to\n  //  the correct number of arguments.\n  function invalidArgumentsLength(\n    typeInfo,           // :: TypeInfo\n    index,              // :: Integer\n    numArgsExpected,    // :: Integer\n    args                // :: Array Any\n  ) {\n    return new TypeError(trimTrailingSpaces(\n      q(typeInfo.name) + ' applied ' + showTypeQuoted(typeInfo.types[index]) +\n      ' to the wrong number of arguments\\n\\n' +\n      underline(\n        typeInfo,\n        K(K(_)),\n        function(index_) {\n          return function(f) {\n            return function(t) {\n              return function(propPath) {\n                return function(s) {\n                  return index_ === index ?\n                    String(t).replace(\n                      /^[(](.*) -> (.*)[)]$/,\n                      function(s, $1, $2) {\n                        return _('(') + f($1) + _(' -> ' + $2 + ')');\n                      }\n                    ) :\n                    _(s);\n                };\n              };\n            };\n          };\n        }\n      ) + '\\n' +\n      'Expected ' + numArgs(numArgsExpected) +\n      ' but received ' + numArgs(args.length) +\n      toMarkdownList('.\\n', ':\\n\\n', Z.toString, args)\n    ));\n  }\n\n  //  assertRight :: Either (() -> Error) a -> a !\n  function assertRight(either) {\n    if (either.isLeft) throw either.value();\n    return either.value;\n  }\n\n  //  curry :: ... -> Function\n  function curry(\n    opts,         // :: Options\n    typeInfo,     // :: TypeInfo\n    _typeVarMap,  // :: TypeVarMap\n    _values,      // :: Array Any\n    _indexes,     // :: Array Integer\n    impl          // :: Function\n  ) {\n    var n = typeInfo.types.length - 1;\n\n    var curried = arity(_indexes.length, function() {\n      if (opts.checkTypes) {\n        var delta = _indexes.length - arguments.length;\n        if (delta < 0) throw tooManyArguments(typeInfo, n - delta);\n      }\n      var typeVarMap = _typeVarMap;\n      var values = _values.slice();\n      var indexes = [];\n      for (var idx = 0; idx < _indexes.length; idx += 1) {\n        var index = _indexes[idx];\n\n        if (idx < arguments.length &&\n            !(typeof arguments[idx] === 'object' &&\n              arguments[idx] != null &&\n              arguments[idx]['@@functional/placeholder'] === true)) {\n\n          var value = arguments[idx];\n          if (opts.checkTypes) {\n            var result = satisfactoryTypes(opts.env,\n                                           typeInfo,\n                                           typeVarMap,\n                                           typeInfo.types[index],\n                                           index,\n                                           [],\n                                           [value]);\n            typeVarMap = assertRight(result).typeVarMap;\n          }\n          values[index] = value;\n        } else {\n          indexes.push(index);\n        }\n      }\n      if (isEmpty(indexes)) {\n        if (opts.checkTypes) {\n          var returnValue = impl.apply(this,\n                                       wrapFunctions(opts.env,\n                                                     typeInfo,\n                                                     [typeVarMap],\n                                                     values));\n          assertRight(satisfactoryTypes(opts.env,\n                                        typeInfo,\n                                        typeVarMap,\n                                        typeInfo.types[n],\n                                        n,\n                                        [],\n                                        [returnValue]));\n          return wrapFunctionCond(env, typeInfo, [typeVarMap], n, returnValue);\n        } else {\n          return impl.apply(this, values);\n        }\n      } else {\n        return curry(opts, typeInfo, typeVarMap, values, indexes, impl);\n      }\n    });\n\n    var showType = showTypeWith(typeInfo);\n    curried.inspect = curried.toString = function() {\n      var vReprs = [];\n      var tReprs = [];\n      for (var idx = 0, placeholders = 0; idx < n; idx += 1) {\n        if (_indexes.indexOf(idx) >= 0) {\n          placeholders += 1;\n          tReprs.push(showType(typeInfo.types[idx]));\n        } else {\n          while (placeholders > 0) {\n            vReprs.push('__');\n            placeholders -= 1;\n          }\n          vReprs.push(Z.toString(_values[idx]));\n        }\n      }\n      return typeInfo.name +\n             when(vReprs.length > 0, parenthesize, vReprs.join(', ')) +\n             ' :: ' +\n             constraintsRepr(typeInfo.constraints, id, K(K(id))) +\n             when(n === 0, parenthesize, tReprs.join(' -> ')) +\n             ' -> ' + showType(typeInfo.types[n]);\n    };\n\n    return curried;\n  }\n\n  function _create(opts) {\n    function def(name, constraints, expTypes, impl) {\n      var values = new Array(expTypes.length - 1);\n      if (values.length > 9) {\n        throw new RangeError(q(def.name) + ' cannot define a function ' +\n                             'with arity greater than nine');\n      }\n      return curry(opts,\n                   {name: name, constraints: constraints, types: expTypes},\n                   {},\n                   values,\n                   range(0, values.length),\n                   impl);\n    }\n    return def(def.name,\n               {},\n               [String_,\n                StrMap(Array_(TypeClass)),\n                NonEmpty(Array_(Type)),\n                AnyFunction,\n                AnyFunction],\n               def);\n  }\n\n  var create =\n  def('create',\n      {},\n      [RecordType({checkTypes: Boolean_, env: Array_(Any)}), AnyFunction],\n      _create);\n\n  //  fromUncheckedUnaryType :: (Type -> Type) -> (Type -> Type)\n  function fromUncheckedUnaryType(typeConstructor) {\n    var t = typeConstructor(Unknown);\n    var _1 = t.types.$1.extractor;\n    return CheckedUnaryType(t.name, t.url, t._test, _1);\n  }\n\n  //  fromUncheckedBinaryType :: ((Type, Type) -> Type) ->\n  //                             (Type -> Type -> Type)\n  function fromUncheckedBinaryType(typeConstructor) {\n    var t = typeConstructor(Unknown, Unknown);\n    var _1 = t.types.$1.extractor;\n    var _2 = t.types.$2.extractor;\n    return CheckedBinaryType(t.name, t.url, t._test, _1, _2);\n  }\n\n  return {\n    __: __,\n    Any: Any,\n    AnyFunction: AnyFunction,\n    Arguments: Arguments,\n    Array: fromUncheckedUnaryType(Array_),\n    Boolean: Boolean_,\n    Date: Date_,\n    Error: Error_,\n    FiniteNumber: FiniteNumber,\n    Function: def('Function', {}, [Array_(Type), Type], Function_),\n    GlobalRegExp: GlobalRegExp,\n    Integer: Integer,\n    NegativeFiniteNumber: NegativeFiniteNumber,\n    NegativeInteger: NegativeInteger,\n    NegativeNumber: NegativeNumber,\n    NonEmpty: NonEmpty,\n    NonGlobalRegExp: NonGlobalRegExp,\n    NonNegativeInteger: NonNegativeInteger,\n    NonZeroFiniteNumber: NonZeroFiniteNumber,\n    NonZeroInteger: NonZeroInteger,\n    NonZeroValidNumber: NonZeroValidNumber,\n    Null: Null,\n    Nullable: fromUncheckedUnaryType(Nullable),\n    Number: Number_,\n    Object: Object_,\n    Pair: fromUncheckedBinaryType(Pair),\n    PositiveFiniteNumber: PositiveFiniteNumber,\n    PositiveInteger: PositiveInteger,\n    PositiveNumber: PositiveNumber,\n    RegExp: RegExp_,\n    RegexFlags: RegexFlags,\n    StrMap: fromUncheckedUnaryType(StrMap),\n    String: String_,\n    Symbol: Symbol_,\n    Type: Type,\n    TypeClass: TypeClass,\n    Undefined: Undefined,\n    Unknown: Unknown,\n    ValidDate: ValidDate,\n    ValidNumber: ValidNumber,\n    env: env,\n    create: create,\n    test: def('test', {}, [Array_(Type), Type, Any, Boolean_], test),\n    NullaryType: CheckedNullaryType,\n    UnaryType: CheckedUnaryType,\n    BinaryType: CheckedBinaryType,\n    EnumType: CheckedEnumType,\n    RecordType: CheckedRecordType,\n    TypeVariable: CheckedTypeVariable,\n    UnaryTypeVariable: CheckedUnaryTypeVariable,\n    BinaryTypeVariable: CheckedBinaryTypeVariable,\n    Thunk: Thunk,\n    Predicate: Predicate\n  };\n\n}));\n\n//. [FL:Semigroup]:         https://github.com/fantasyland/fantasy-land#semigroup\n//. [Monoid]:               https://github.com/fantasyland/fantasy-land#monoid\n//. [Setoid]:               https://github.com/fantasyland/fantasy-land#setoid\n//. [`Array`]:              #Array\n//. [`BinaryType`]:         #BinaryType\n//. [`Date`]:               #Date\n//. [`FiniteNumber`]:       #FiniteNumber\n//. [`GlobalRegExp`]:       #GlobalRegExp\n//. [`Integer`]:            #Integer\n//. [`NonGlobalRegExp`]:    #NonGlobalRegExp\n//. [`Number`]:             #Number\n//. [`Object.create`]:      https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create\n//. [`Pair`]:               #Pair\n//. [`RegExp`]:             #RegExp\n//. [`RegexFlags`]:         #RegexFlags\n//. [`String`]:             #String\n//. [`SyntaxError`]:        https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError\n//. [`TypeClass`]:          https://github.com/sanctuary-js/sanctuary-type-classes#TypeClass\n//. [`TypeError`]:          https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError\n//. [`TypeVariable`]:       #TypeVariable\n//. [`UnaryType`]:          #UnaryType\n//. [`UnaryTypeVariable`]:  #UnaryTypeVariable\n//. [`Unknown`]:            #Unknown\n//. [`ValidNumber`]:        #ValidNumber\n//. [`env`]:                #env\n//. [arguments]:            https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments\n//. [enumerated types]:     https://en.wikipedia.org/wiki/Enumerated_type\n//. [max]:                  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER\n//. [min]:                  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_SAFE_INTEGER\n//. [record type]:          #RecordType\n//. [semigroup]:            https://en.wikipedia.org/wiki/Semigroup\n//. [type class]:           #type-classes\n//. [type variables]:       #TypeVariable\n//. [types]:                #types\n","/*    #######\n   ####     ####\n ####   ###   ####\n#####   ###########   sanctuary\n########   ########   noun\n###########   #####   1 [ mass noun ] refuge from unsafe JavaScript\n ####   ###   ####\n   ####     ####\n      #######    */\n\n//. # Sanctuary\n//.\n//. [![npm](https://img.shields.io/npm/v/sanctuary.svg)](https://www.npmjs.com/package/sanctuary)\n//. [![CircleCI](https://img.shields.io/circleci/project/github/sanctuary-js/sanctuary/master.svg)](https://circleci.com/gh/sanctuary-js/sanctuary/tree/master)\n//. [![Gitter](https://img.shields.io/gitter/room/badges/shields.svg)](https://gitter.im/sanctuary-js/sanctuary)\n//.\n//. Sanctuary is a JavaScript functional programming library inspired by\n//. [Haskell][] and [PureScript][]. It's stricter than [Ramda][], and\n//. provides a similar suite of functions.\n//.\n//. Sanctuary promotes programs composed of simple, pure functions. Such\n//. programs are easier to comprehend, test, and maintain &ndash; they are\n//. also a pleasure to write.\n//.\n//. Sanctuary provides two data types, [Maybe][] and [Either][], both of\n//. which are compatible with [Fantasy Land][]. Thanks to these data types\n//. even Sanctuary functions which may fail, such as [`head`](#head), are\n//. composable.\n//.\n//. Sanctuary makes it possible to write safe code without null checks.\n//. In JavaScript it's trivial to introduce a possible run-time type error:\n//.\n//.     words[0].toUpperCase()\n//.\n//. If `words` is `[]` we'll get a familiar error at run-time:\n//.\n//.     TypeError: Cannot read property 'toUpperCase' of undefined\n//.\n//. Sanctuary gives us a fighting chance of avoiding such errors. We might\n//. write:\n//.\n//.     S.map(S.toUpper, S.head(words))\n//.\n//. Sanctuary is designed to work in Node.js and in ES5-compatible browsers.\n//.\n//. ## Types\n//.\n//. Sanctuary uses Haskell-like type signatures to describe the types of\n//. values, including functions. `'foo'`, for example, is a member of `String`;\n//. `[1, 2, 3]` is a member of `Array Number`. The double colon (`::`) is used\n//. to mean \"is a member of\", so one could write:\n//.\n//.     'foo' :: String\n//.     [1, 2, 3] :: Array Number\n//.\n//. An identifier may appear to the left of the double colon:\n//.\n//.     Math.PI :: Number\n//.\n//. The arrow (`->`) is used to express a function's type:\n//.\n//.     Math.abs :: Number -> Number\n//.\n//. That states that `Math.abs` is a unary function which takes an argument\n//. of type `Number` and returns a value of type `Number`.\n//.\n//. Some functions are parametrically polymorphic: their types are not fixed.\n//. Type variables are used in the representations of such functions:\n//.\n//.     S.I :: a -> a\n//.\n//. `a` is a type variable. Type variables are not capitalized, so they\n//. are differentiable from type identifiers (which are always capitalized).\n//. By convention type variables have single-character names. The signature\n//. above states that `S.I` takes a value of any type and returns a value of\n//. the same type. Some signatures feature multiple type variables:\n//.\n//.     S.K :: a -> b -> a\n//.\n//. It must be possible to replace all occurrences of `a` with a concrete type.\n//. The same applies for each other type variable. For the function above, the\n//. types with which `a` and `b` are replaced may be different, but needn't be.\n//.\n//. Since all Sanctuary functions are curried (they accept their arguments\n//. one at a time), a binary function is represented as a unary function which\n//. returns a unary function: `* -> * -> *`. This aligns neatly with Haskell,\n//. which uses curried functions exclusively. In JavaScript, though, we may\n//. wish to represent the types of functions with arities less than or greater\n//. than one. The general form is `(<input-types>) -> <output-type>`, where\n//. `<input-types>` comprises zero or more commaspace (<code>, </code>)\n//. -separated type representations:\n//.\n//.   - `() -> String`\n//.   - `(a, b) -> a`\n//.   - `(a, b, c) -> d`\n//.\n//. `Number -> Number` can thus be seen as shorthand for `(Number) -> Number`.\n//.\n//. The question mark (`?`) is used to represent types which include `null`\n//. and `undefined` as members. `String?`, for example, represents the type\n//. comprising `null`, `undefined`, and all strings.\n//.\n//. Sanctuary embraces types. JavaScript doesn't support algebraic data types,\n//. but these can be simulated by providing a group of data constructors which\n//. return values with the same set of methods. A value of the Either type, for\n//. example, is created via the Left constructor or the Right constructor.\n//.\n//. It's necessary to extend Haskell's notation to describe implicit arguments\n//. to the *methods* provided by Sanctuary's types. In `x.map(y)`, for example,\n//. the `map` method takes an implicit argument `x` in addition to the explicit\n//. argument `y`. The type of the value upon which a method is invoked appears\n//. at the beginning of the signature, separated from the arguments and return\n//. value by a squiggly arrow (`~>`). The type of the `fantasy-land/map` method\n//. of the Maybe type is written `Maybe a ~> (a -> b) -> Maybe b`. One could\n//. read this as:\n//.\n//. _When the `fantasy-land/map` method is invoked on a value of type `Maybe a`\n//. (for any type `a`) with an argument of type `a -> b` (for any type `b`),\n//. it returns a value of type `Maybe b`._\n//.\n//. The squiggly arrow is also used when representing non-function properties.\n//. `Maybe a ~> Boolean`, for example, represents a Boolean property of a value\n//. of type `Maybe a`.\n//.\n//. Sanctuary supports type classes: constraints on type variables. Whereas\n//. `a -> a` implicitly supports every type, `Functor f => (a -> b) -> f a ->\n//. f b` requires that `f` be a type which satisfies the requirements of the\n//. Functor type class. Type-class constraints appear at the beginning of a\n//. type signature, separated from the rest of the signature by a fat arrow\n//. (`=>`).\n//.\n//. ### Type representatives\n//.\n//. What is the type of `Number`? One answer is `a -> Number`, since it's a\n//. function which takes an argument of any type and returns a Number value.\n//. When provided as the first argument to [`is`](#is), though, `Number` is\n//. really the value-level representative of the Number type.\n//.\n//. Sanctuary uses the TypeRep pseudotype to describe type representatives.\n//. For example:\n//.\n//.     Number :: TypeRep Number\n//.\n//. `Number` is the sole inhabitant of the TypeRep Number type.\n//.\n//. ## Type checking\n//.\n//. Sanctuary functions are defined via [sanctuary-def][] to provide run-time\n//. type checking. This is tremendously useful during development: type errors\n//. are reported immediately, avoiding circuitous stack traces (at best) and\n//. silent failures due to type coercion (at worst). For example:\n//.\n//. ```javascript\n//. S.add(2, true);\n//. // ! TypeError: Invalid value\n//. //\n//. //   add :: FiniteNumber -> FiniteNumber -> FiniteNumber\n//. //                          ^^^^^^^^^^^^\n//. //                               1\n//. //\n//. //   1)  true :: Boolean\n//. //\n//. //   The value at position 1 is not a member of FiniteNumber.\n//. //\n//. //   See v:sanctuary-js/sanctuary-def#FiniteNumber for information about the sanctuary-def/FiniteNumber type.\n//. ```\n//.\n//. Compare this to the behaviour of Ramda's unchecked equivalent:\n//.\n//. ```javascript\n//. R.add(2, true);\n//. // => 3\n//. ```\n//.\n//. There is a performance cost to run-time type checking. One may wish to\n//. disable type checking in certain contexts to avoid paying this cost.\n//. [`create`](#create) facilitates the creation of a Sanctuary module which\n//. does not perform type checking.\n//.\n//. In Node, one could use an environment variable to determine whether to\n//. perform type checking:\n//.\n//. ```javascript\n//. const {create, env} = require('sanctuary');\n//.\n//. const checkTypes = process.env.NODE_ENV !== 'production';\n//. const S = create({checkTypes, env});\n//. ```\n//.\n//. ## API\n\n(function(f) {\n\n  'use strict';\n\n  /* istanbul ignore else */\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = f(require('sanctuary-def'),\n                       require('sanctuary-type-classes'),\n                       require('sanctuary-type-identifiers'));\n  } else if (typeof define === 'function' && define.amd != null) {\n    define(['sanctuary-def',\n            'sanctuary-type-classes',\n            'sanctuary-type-identifiers'],\n           f);\n  } else {\n    self.sanctuary = f(self.sanctuaryDef,\n                       self.sanctuaryTypeClasses,\n                       self.sanctuaryTypeIdentifiers);\n  }\n\n}(function($, Z, type) {\n\n  'use strict';\n\n  //  Fn :: (Type, Type) -> Type\n  function Fn(x, y) { return $.Function([x, y]); }\n\n  //  flip$ :: ((a, b) -> c) -> b -> a -> c\n  function flip$(f) {\n    return function(x) {\n      return function(y) {\n        return f(y, x);\n      };\n    };\n  }\n\n  //  toObject :: a -> Object\n  function toObject(x) {\n    return x == null ? Object.create(null) : Object(x);\n  }\n\n  //  typeEq :: String -> a -> Boolean\n  function typeEq(typeIdent) {\n    return function(x) {\n      return type(x) === typeIdent;\n    };\n  }\n\n  //  uncurry2 :: (a -> b -> c) -> ((a, b) -> c)\n  function uncurry2(f) {\n    return function(x, y) {\n      return f(x)(y);\n    };\n  }\n\n  //  readmeUrl :: String -> String\n  function readmeUrl(id) {\n    var version = '0.14.1';  // updated programmatically\n    return 'https://github.com/sanctuary-js/sanctuary/tree/v' + version +\n           '#' + id;\n  }\n\n  //  :: Type\n  var a = $.TypeVariable('a');\n  var b = $.TypeVariable('b');\n  var c = $.TypeVariable('c');\n  var d = $.TypeVariable('d');\n  var e = $.TypeVariable('e');\n  var g = $.TypeVariable('g');\n  var l = $.TypeVariable('l');\n  var r = $.TypeVariable('r');\n\n  //  :: Type -> Type\n  var f = $.UnaryTypeVariable('f');\n  var m = $.UnaryTypeVariable('m');\n  var t = $.UnaryTypeVariable('t');\n  var w = $.UnaryTypeVariable('w');\n\n  //  :: Type -> Type -> Type\n  var p = $.BinaryTypeVariable('p');\n  var s = $.BinaryTypeVariable('s');\n\n  //  eitherTypeIdent :: String\n  var eitherTypeIdent = 'sanctuary/Either';\n\n  //  $Either :: Type -> Type -> Type\n  var $Either = $.BinaryType(\n    eitherTypeIdent,\n    readmeUrl('EitherType'),\n    typeEq(eitherTypeIdent),\n    function(either) { return either.isLeft ? [either.value] : []; },\n    function(either) { return either.isRight ? [either.value] : []; }\n  );\n\n  //  List :: Type -> Type\n  var List = $.UnaryType(\n    'sanctuary/List',\n    readmeUrl('list'),\n    function(x) { return $.String._test(x) || Array.isArray(x); },\n    function(list) { return $.String._test(list) ? [] : list; }\n  );\n\n  //  maybeTypeIdent :: String\n  var maybeTypeIdent = 'sanctuary/Maybe';\n\n  //  $Maybe :: Type -> Type\n  var $Maybe = $.UnaryType(\n    maybeTypeIdent,\n    readmeUrl('MaybeType'),\n    typeEq(maybeTypeIdent),\n    function(maybe) { return maybe.isJust ? [maybe.value] : []; }\n  );\n\n  //  TypeRep :: Type -> Type\n  var TypeRep = $.UnaryType(\n    'sanctuary/TypeRep',\n    readmeUrl('type-representatives'),\n    function(x) {\n      return $.AnyFunction._test(x) ||\n             x != null && $.String._test(x['@@type']);\n    },\n    function(typeRep) { return []; }\n  );\n\n  //  defaultEnv :: Array Type\n  var defaultEnv = Z.concat($.env, [\n    $.FiniteNumber,\n    $.NonZeroFiniteNumber,\n    $Either($.Unknown, $.Unknown),\n    Fn($.Unknown, $.Unknown),\n    $.GlobalRegExp,\n    $.NonGlobalRegExp,\n    $.Integer,\n    $.NonNegativeInteger,\n    $Maybe($.Unknown),\n    $.Pair($.Unknown, $.Unknown),\n    $.RegexFlags,\n    $.ValidDate,\n    $.ValidNumber\n  ]);\n\n  //  Options :: Type\n  var Options = $.RecordType({checkTypes: $.Boolean, env: $.Array($.Any)});\n\n  //  createSanctuary :: Options -> Module\n  function createSanctuary(opts) {\n\n  /* eslint-disable indent */\n\n  //  checkTypes :: Boolean\n  var checkTypes = opts.checkTypes;\n\n  //  env :: Array Type\n  var env = opts.env;\n\n  var S = {};\n\n  //# create :: { checkTypes :: Boolean, env :: Array Type } -> Module\n  //.\n  //. Takes an options record and returns a Sanctuary module. `checkTypes`\n  //. specifies whether to enable type checking. The module's polymorphic\n  //. functions (such as [`I`](#I)) require each value associated with a\n  //. type variable to be a member of at least one type in the environment.\n  //.\n  //. A well-typed application of a Sanctuary function will produce the same\n  //. result regardless of whether type checking is enabled. If type checking\n  //. is enabled, a badly typed application will produce an exception with a\n  //. descriptive error message.\n  //.\n  //. The following snippet demonstrates defining a custom type and using\n  //. `create` to produce a Sanctuary module which is aware of that type:\n  //.\n  //. ```javascript\n  //. const {create, env} = require('sanctuary');\n  //. const $ = require('sanctuary-def');\n  //. const type = require('sanctuary-type-identifiers');\n  //.\n  //. //    Identity :: a -> Identity a\n  //. const Identity = function Identity(x) {\n  //.   if (!(this instanceof Identity)) return new Identity(x);\n  //.   this.value = x;\n  //. };\n  //.\n  //. Identity['@@type'] = 'my-package/Identity@1';\n  //.\n  //. Identity.prototype['fantasy-land/map'] = function(f) {\n  //.   return Identity(f(this.value));\n  //. };\n  //.\n  //. //    IdentityType :: Type -> Type\n  //. const IdentityType = $.UnaryType(\n  //.   Identity['@@type'],\n  //.   'http://example.com/my-package#Identity',\n  //.   x => type(x) === Identity['@@type'],\n  //.   identity => [identity.value]\n  //. );\n  //.\n  //. const S = create({\n  //.   checkTypes: process.env.NODE_ENV !== 'production',\n  //.   env: env.concat([IdentityType($.Unknown)]),\n  //. });\n  //.\n  //. S.map(S.sub(1), Identity(43));\n  //. // => Identity(42)\n  //. ```\n  //.\n  //. See also [`env`](#env).\n  S.create =\n  $.create({checkTypes: checkTypes, env: defaultEnv})('create',\n                                                      {},\n                                                      [Options, $.Object],\n                                                      createSanctuary);\n\n  //# env :: Array Type\n  //.\n  //. The default environment, which may be used as is or as the basis of a\n  //. custom environment in conjunction with [`create`](#create).\n  S.env = defaultEnv;\n\n  /* istanbul ignore if */\n  if (typeof __doctest !== 'undefined') {\n    /* global __doctest:false */\n    /* eslint-disable no-unused-vars */\n    var _List = __doctest.require('./test/internal/List');\n    var Cons = _List.Cons;\n    var Nil = _List.Nil;\n    var Sum = __doctest.require('./test/internal/Sum');\n    /* eslint-enable no-unused-vars */\n    env = Z.concat(env, [_List.Type($.Unknown), Sum.Type]);\n  }\n\n  var def = $.create({checkTypes: checkTypes, env: env});\n\n  //. ### Placeholder\n  //.\n  //. Sanctuary functions are designed with partial application in mind.\n  //. In many cases one can define a more specific function in terms of\n  //. a more general one simply by applying the more general function to\n  //. some (but not all) of its arguments. For example, one could define\n  //. `sum :: Foldable f => f Number -> Number` as `S.reduce(S.add, 0)`.\n  //.\n  //. In some cases, though, there are multiple orders in which one may\n  //. wish to provide a function's arguments. `S.concat('prefix')` is a\n  //. function which prefixes its argument, but how would one define a\n  //. function which suffixes its argument? It's possible with the help\n  //. of [`__`](#__), the special placeholder value.\n  //.\n  //. The placeholder indicates a hole to be filled at some future time.\n  //. The following are all equivalent (`_` represents the placeholder):\n  //.\n  //.   - `f(x, y, z)`\n  //.   - `f(_, y, z)(x)`\n  //.   - `f(_, _, z)(x, y)`\n  //.   - `f(_, _, z)(_, y)(x)`\n\n  //# __ :: Placeholder\n  //.\n  //. The special [placeholder](#placeholder) value.\n  //.\n  //. ```javascript\n  //. > S.map(S.concat('@'), ['foo', 'bar', 'baz'])\n  //. ['@foo', '@bar', '@baz']\n  //.\n  //. > S.map(S.concat(S.__, '?'), ['foo', 'bar', 'baz'])\n  //. ['foo?', 'bar?', 'baz?']\n  //. ```\n  S.__ = $.__;\n\n  //. ### Classify\n\n  //# type :: Any -> { namespace :: Maybe String, name :: String, version :: NonNegativeInteger }\n  //.\n  //. Returns the result of parsing the [type identifier][] of the given value.\n  //.\n  //. ```javascript\n  //. > S.type(S.Just(42))\n  //. {namespace: Just('sanctuary'), name: 'Maybe', version: 0}\n  //.\n  //. > S.type([1, 2, 3])\n  //. {namespace: Nothing, name: 'Array', version: 0}\n  //. ```\n  S.type =\n  def('type',\n      {},\n      [$.Any,\n       $.RecordType({namespace: $Maybe($.String),\n                     name: $.String,\n                     version: $.NonNegativeInteger})],\n      function(x) {\n        var r = type.parse(type(x));\n        r.namespace = toMaybe(r.namespace);\n        return r;\n      });\n\n  //# is :: TypeRep a -> Any -> Boolean\n  //.\n  //. Takes a [type representative](#type-representatives) and a value of any\n  //. type and returns `true` [iff][] the given value is of the specified type.\n  //. Subtyping is not respected.\n  //.\n  //. ```javascript\n  //. > S.is(Number, 42)\n  //. true\n  //.\n  //. > S.is(Object, 42)\n  //. false\n  //.\n  //. > S.is(String, 42)\n  //. false\n  //. ```\n  function is(typeRep, x) {\n    var xType = type(x);\n    if ($.String._test(typeRep['@@type'])) {\n      return xType === typeRep['@@type'];\n    } else {\n      var match = /function (\\w*)/.exec(typeRep);\n      return match != null && match[1] === xType;\n    }\n  }\n  S.is = def('is', {}, [TypeRep(a), $.Any, $.Boolean], is);\n\n  //. ### Showable\n\n  //# toString :: Any -> String\n  //.\n  //. Alias of [`Z.toString`][].\n  //.\n  //. ```javascript\n  //. > S.toString(-0)\n  //. '-0'\n  //.\n  //. > S.toString(['foo', 'bar', 'baz'])\n  //. '[\"foo\", \"bar\", \"baz\"]'\n  //.\n  //. > S.toString({x: 1, y: 2, z: 3})\n  //. '{\"x\": 1, \"y\": 2, \"z\": 3}'\n  //.\n  //. > S.toString(S.Left(S.Right(S.Just(S.Nothing))))\n  //. 'Left(Right(Just(Nothing)))'\n  //. ```\n  S.toString = def('toString', {}, [$.Any, $.String], Z.toString);\n\n  //. ### Fantasy Land\n  //.\n  //. Sanctuary is compatible with the [Fantasy Land][] specification.\n\n  //# equals :: Setoid a => a -> a -> Boolean\n  //.\n  //. Curried version of [`Z.equals`][] which requires two arguments of the\n  //. same type.\n  //.\n  //. To compare values of different types first use [`create`](#create) to\n  //. create a Sanctuary module with type checking disabled, then use that\n  //. module's `equals` function.\n  //.\n  //. ```javascript\n  //. > S.equals(0, -0)\n  //. true\n  //.\n  //. > S.equals(NaN, NaN)\n  //. true\n  //.\n  //. > S.equals(S.Just([1, 2, 3]), S.Just([1, 2, 3]))\n  //. true\n  //.\n  //. > S.equals(S.Just([1, 2, 3]), S.Just([1, 2, 4]))\n  //. false\n  //. ```\n  S.equals = def('equals', {a: [Z.Setoid]}, [a, a, $.Boolean], Z.equals);\n\n  //# lt :: Ord a => a -> (a -> Boolean)\n  //.\n  //. Returns `true` [iff][] the *second* argument is less than the first\n  //. according to [`Z.lt`][]. The arguments must be provided one at a time.\n  //.\n  //. See also [`lt_`](#lt_).\n  //.\n  //. ```javascript\n  //. > S.filter(S.lt(3), [1, 2, 3, 4, 5])\n  //. [1, 2]\n  //. ```\n  S.lt = def('lt', {a: [Z.Ord]}, [a, $.Predicate(a)], flip$(Z.lt));\n\n  //# lt_ :: Ord a => a -> a -> Boolean\n  //.\n  //. Returns `true` [iff][] the first argument is less than the second\n  //. according to [`Z.lt`][].\n  //.\n  //. See also [`lt`](#lt).\n  //.\n  //. ```javascript\n  //. > S.lt_([1, 2, 3], [1, 2, 3])\n  //. false\n  //.\n  //. > S.lt_([1, 2, 3], [1, 2, 4])\n  //. true\n  //.\n  //. > S.lt_([1, 2, 3], [1, 2])\n  //. false\n  //. ```\n  S.lt_ = def('lt_', {a: [Z.Ord]}, [a, a, $.Boolean], Z.lt);\n\n  //# lte :: Ord a => a -> (a -> Boolean)\n  //.\n  //. Returns `true` [iff][] the *second* argument is less than or equal to\n  //. the first according to [`Z.lte`][]. The arguments must be provided one\n  //. at a time.\n  //.\n  //. See also [`lte_`](#lte_).\n  //.\n  //. ```javascript\n  //. > S.filter(S.lte(3), [1, 2, 3, 4, 5])\n  //. [1, 2, 3]\n  //. ```\n  S.lte = def('lte', {a: [Z.Ord]}, [a, $.Predicate(a)], flip$(Z.lte));\n\n  //# lte_ :: Ord a => a -> a -> Boolean\n  //.\n  //. Returns `true` [iff][] the first argument is less than or equal to the\n  //. second according to [`Z.lte`][].\n  //.\n  //. See also [`lte`](#lte).\n  //.\n  //. ```javascript\n  //. > S.lte_([1, 2, 3], [1, 2, 3])\n  //. true\n  //.\n  //. > S.lte_([1, 2, 3], [1, 2, 4])\n  //. true\n  //.\n  //. > S.lte_([1, 2, 3], [1, 2])\n  //. false\n  //. ```\n  S.lte_ = def('lte_', {a: [Z.Ord]}, [a, a, $.Boolean], Z.lte);\n\n  //# gt :: Ord a => a -> (a -> Boolean)\n  //.\n  //. Returns `true` [iff][] the *second* argument is greater than the first\n  //. according to [`Z.gt`][]. The arguments must be provided one at a time.\n  //.\n  //. See also [`gt_`](#gt_).\n  //.\n  //. ```javascript\n  //. > S.filter(S.gt(3), [1, 2, 3, 4, 5])\n  //. [4, 5]\n  //. ```\n  S.gt = def('gt', {a: [Z.Ord]}, [a, $.Predicate(a)], flip$(Z.gt));\n\n  //# gt_ :: Ord a => a -> a -> Boolean\n  //.\n  //. Returns `true` [iff][] the first argument is greater than the second\n  //. according to [`Z.gt`][].\n  //.\n  //. See also [`gt`](#gt).\n  //.\n  //. ```javascript\n  //. > S.gt_([1, 2, 3], [1, 2, 3])\n  //. false\n  //.\n  //. > S.gt_([1, 2, 3], [1, 2, 4])\n  //. false\n  //.\n  //. > S.gt_([1, 2, 3], [1, 2])\n  //. true\n  //. ```\n  S.gt_ = def('gt_', {a: [Z.Ord]}, [a, a, $.Boolean], Z.gt);\n\n  //# gte :: Ord a => a -> (a -> Boolean)\n  //.\n  //. Returns `true` [iff][] the *second* argument is greater than or equal\n  //. to the first according to [`Z.gte`][]. The arguments must be provided\n  //. one at a time.\n  //.\n  //. See also [`gte_`](#gte_).\n  //.\n  //. ```javascript\n  //. > S.filter(S.gte(3), [1, 2, 3, 4, 5])\n  //. [3, 4, 5]\n  //. ```\n  S.gte = def('gte', {a: [Z.Ord]}, [a, $.Predicate(a)], flip$(Z.gte));\n\n  //# gte_ :: Ord a => a -> a -> Boolean\n  //.\n  //. Returns `true` [iff][] the first argument is greater than or equal to\n  //. the second according to [`Z.gte`][].\n  //.\n  //. See also [`gte`](#gte).\n  //.\n  //. ```javascript\n  //. > S.gte_([1, 2, 3], [1, 2, 3])\n  //. true\n  //.\n  //. > S.gte_([1, 2, 3], [1, 2, 4])\n  //. false\n  //.\n  //. > S.gte_([1, 2, 3], [1, 2])\n  //. true\n  //. ```\n  S.gte_ = def('gte_', {a: [Z.Ord]}, [a, a, $.Boolean], Z.gte);\n\n  //# min :: Ord a => a -> a -> a\n  //.\n  //. Returns the smaller of its two arguments (according to [`Z.lte`][]).\n  //.\n  //. See also [`max`](#max).\n  //.\n  //. ```javascript\n  //. > S.min(10, 2)\n  //. 2\n  //.\n  //. > S.min(new Date('1999-12-31'), new Date('2000-01-01'))\n  //. new Date('1999-12-31')\n  //.\n  //. > S.min('10', '2')\n  //. '10'\n  //. ```\n  S.min = def('min', {a: [Z.Ord]}, [a, a, a], Z.min);\n\n  //# max :: Ord a => a -> a -> a\n  //.\n  //. Returns the larger of its two arguments (according to [`Z.lte`][]).\n  //.\n  //. See also [`min`](#min).\n  //.\n  //. ```javascript\n  //. > S.max(10, 2)\n  //. 10\n  //.\n  //. > S.max(new Date('1999-12-31'), new Date('2000-01-01'))\n  //. new Date('2000-01-01')\n  //.\n  //. > S.max('10', '2')\n  //. '2'\n  //. ```\n  S.max = def('max', {a: [Z.Ord]}, [a, a, a], Z.max);\n\n  //# id :: Category c => TypeRep c -> c\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.id`][].\n  //.\n  //. ```javascript\n  //. > S.id(Function)(42)\n  //. 42\n  //. ```\n  S.id = def('id', {c: [Z.Category]}, [TypeRep(c), c], Z.id);\n\n  //# concat :: Semigroup a => a -> a -> a\n  //.\n  //. Curried version of [`Z.concat`][].\n  //.\n  //. ```javascript\n  //. > S.concat('abc', 'def')\n  //. 'abcdef'\n  //.\n  //. > S.concat([1, 2, 3], [4, 5, 6])\n  //. [1, 2, 3, 4, 5, 6]\n  //.\n  //. > S.concat({x: 1, y: 2}, {y: 3, z: 4})\n  //. {x: 1, y: 3, z: 4}\n  //.\n  //. > S.concat(S.Just([1, 2, 3]), S.Just([4, 5, 6]))\n  //. Just([1, 2, 3, 4, 5, 6])\n  //.\n  //. > S.concat(Sum(18), Sum(24))\n  //. Sum(42)\n  //. ```\n  S.concat = def('concat', {a: [Z.Semigroup]}, [a, a, a], Z.concat);\n\n  //# empty :: Monoid a => TypeRep a -> a\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.empty`][].\n  //.\n  //. ```javascript\n  //. > S.empty(String)\n  //. ''\n  //.\n  //. > S.empty(Array)\n  //. []\n  //.\n  //. > S.empty(Object)\n  //. {}\n  //.\n  //. > S.empty(Sum)\n  //. Sum(0)\n  //. ```\n  S.empty = def('empty', {a: [Z.Monoid]}, [TypeRep(a), a], Z.empty);\n\n  //# invert :: Group g => g -> g\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.invert`][].\n  //.\n  //. ```javascript\n  //. > S.invert(Sum(5))\n  //. Sum(-5)\n  //. ```\n  S.invert = def('invert', {g: [Z.Group]}, [g, g], Z.invert);\n\n  //# map :: Functor f => (a -> b) -> f a -> f b\n  //.\n  //. Curried version of [`Z.map`][].\n  //.\n  //. ```javascript\n  //. > S.map(Math.sqrt, [1, 4, 9])\n  //. [1, 2, 3]\n  //.\n  //. > S.map(Math.sqrt, {x: 1, y: 4, z: 9})\n  //. {x: 1, y: 2, z: 3}\n  //.\n  //. > S.map(Math.sqrt, S.Just(9))\n  //. Just(3)\n  //.\n  //. > S.map(Math.sqrt, S.Right(9))\n  //. Right(3)\n  //. ```\n  //.\n  //. Replacing `Functor f => f` with `Function x` produces the B combinator\n  //. from combinatory logic (i.e. [`compose`](#compose)):\n  //.\n  //.     Functor f => (a -> b) -> f a -> f b\n  //.     (a -> b) -> Function x a -> Function x b\n  //.     (a -> c) -> Function x a -> Function x c\n  //.     (b -> c) -> Function x b -> Function x c\n  //.     (b -> c) -> Function a b -> Function a c\n  //.     (b -> c) -> (a -> b) -> (a -> c)\n  //.\n  //. ```javascript\n  //. > S.map(Math.sqrt, S.add(1))(99)\n  //. 10\n  //. ```\n  S.map = def('map', {f: [Z.Functor]}, [Fn(a, b), f(a), f(b)], Z.map);\n\n  //# bimap :: Bifunctor f => (a -> b) -> (c -> d) -> f a c -> f b d\n  //.\n  //. Curried version of [`Z.bimap`][].\n  //.\n  //. ```javascript\n  //. > S.bimap(S.toUpper, Math.sqrt, S.Left('foo'))\n  //. Left('FOO')\n  //.\n  //. > S.bimap(S.toUpper, Math.sqrt, S.Right(64))\n  //. Right(8)\n  //. ```\n  S.bimap =\n  def('bimap',\n      {p: [Z.Bifunctor]},\n      [Fn(a, b), Fn(c, d), p(a, c), p(b, d)],\n      Z.bimap);\n\n  //# promap :: Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d\n  //.\n  //. Curried version of [`Z.promap`][].\n  //.\n  //. ```javascript\n  //. > S.promap(Math.abs, S.add(1), Math.sqrt)(-100)\n  //. 11\n  //. ```\n  S.promap =\n  def('promap',\n      {p: [Z.Profunctor]},\n      [Fn(a, b), Fn(c, d), p(b, c), p(a, d)],\n      Z.promap);\n\n  //# alt :: Alt f => f a -> f a -> f a\n  //.\n  //. Curried version of [`Z.alt`][].\n  //.\n  //. ```javascript\n  //. > S.alt(S.Nothing, S.Just(1))\n  //. Just(1)\n  //.\n  //. > S.alt(S.Just(2), S.Just(3))\n  //. Just(2)\n  //.\n  //. > S.alt(S.Left('X'), S.Right(1))\n  //. Right(1)\n  //.\n  //. > S.alt(S.Right(2), S.Right(3))\n  //. Right(2)\n  //. ```\n  S.alt = def('alt', {f: [Z.Alt]}, [f(a), f(a), f(a)], Z.alt);\n\n  //# zero :: Plus f => TypeRep f -> f a\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.zero`][].\n  //.\n  //. ```javascript\n  //. > S.zero(Array)\n  //. []\n  //.\n  //. > S.zero(Object)\n  //. {}\n  //.\n  //. > S.zero(S.Maybe)\n  //. Nothing\n  //. ```\n  S.zero =\n  def('zero', {f: [Z.Plus]}, [TypeRep($.TypeVariable('f')), f(a)], Z.zero);\n\n  //# reduce :: Foldable f => (b -> a -> b) -> b -> f a -> b\n  //.\n  //. Takes a curried binary function, an initial value, and a [Foldable][],\n  //. and applies the function to the initial value and the Foldable's first\n  //. value, then applies the function to the result of the previous\n  //. application and the Foldable's second value. Repeats this process\n  //. until each of the Foldable's values has been used. Returns the initial\n  //. value if the Foldable is empty; the result of the final application\n  //. otherwise.\n  //.\n  //. ```javascript\n  //. > S.reduce(S.add, 0, [1, 2, 3, 4, 5])\n  //. 15\n  //.\n  //. > S.reduce(xs => x => [x].concat(xs), [], [1, 2, 3, 4, 5])\n  //. [5, 4, 3, 2, 1]\n  //. ```\n  function reduce(f, initial, foldable) {\n    return Z.reduce(uncurry2(f), initial, foldable);\n  }\n  S.reduce =\n  def('reduce', {f: [Z.Foldable]}, [Fn(a, Fn(b, a)), a, f(b), a], reduce);\n\n  //# traverse :: (Applicative f, Traversable t) => TypeRep f -> (a -> f b) -> t a -> f (t b)\n  //.\n  //. Curried version of [`Z.traverse`][].\n  //.\n  //. ```javascript\n  //. > S.traverse(Array, S.words, S.Just('foo bar baz'))\n  //. [Just('foo'), Just('bar'), Just('baz')]\n  //.\n  //. > S.traverse(Array, S.words, S.Nothing)\n  //. [Nothing]\n  //.\n  //. > S.traverse(S.Maybe, S.parseInt(16), ['A', 'B', 'C'])\n  //. Just([10, 11, 12])\n  //.\n  //. > S.traverse(S.Maybe, S.parseInt(16), ['A', 'B', 'C', 'X'])\n  //. Nothing\n  //.\n  //. > S.traverse(S.Maybe, S.parseInt(16), {a: 'A', b: 'B', c: 'C'})\n  //. Just({a: 10, b: 11, c: 12})\n  //.\n  //. > S.traverse(S.Maybe, S.parseInt(16), {a: 'A', b: 'B', c: 'C', x: 'X'})\n  //. Nothing\n  //. ```\n  S.traverse =\n  def('traverse',\n      {f: [Z.Applicative], t: [Z.Traversable]},\n      [TypeRep($.TypeVariable('f')), Fn(a, f(b)), t(a), f(t(b))],\n      Z.traverse);\n\n  //# sequence :: (Applicative f, Traversable t) => TypeRep f -> t (f a) -> f (t a)\n  //.\n  //. Curried version of [`Z.sequence`][]. Inverts the given `t (f a)`\n  //. to produce an `f (t a)`.\n  //.\n  //. ```javascript\n  //. > S.sequence(Array, S.Just([1, 2, 3]))\n  //. [Just(1), Just(2), Just(3)]\n  //.\n  //. > S.sequence(S.Maybe, [S.Just(1), S.Just(2), S.Just(3)])\n  //. Just([1, 2, 3])\n  //.\n  //. > S.sequence(S.Maybe, [S.Just(1), S.Just(2), S.Nothing])\n  //. Nothing\n  //.\n  //. > S.sequence(S.Maybe, {a: S.Just(1), b: S.Just(2), c: S.Just(3)})\n  //. Just({a: 1, b: 2, c: 3})\n  //.\n  //. > S.sequence(S.Maybe, {a: S.Just(1), b: S.Just(2), c: S.Nothing})\n  //. Nothing\n  //. ```\n  S.sequence =\n  def('sequence',\n      {f: [Z.Applicative], t: [Z.Traversable]},\n      [TypeRep($.TypeVariable('f')), t(f(a)), f(t(a))],\n      Z.sequence);\n\n  //# ap :: Apply f => f (a -> b) -> f a -> f b\n  //.\n  //. Curried version of [`Z.ap`][].\n  //.\n  //. ```javascript\n  //. > S.ap([Math.sqrt, x => x * x], [1, 4, 9, 16, 25])\n  //. [1, 2, 3, 4, 5, 1, 16, 81, 256, 625]\n  //.\n  //. > S.ap({x: Math.sqrt, y: S.add(1), z: S.sub(1)}, {w: 4, x: 4, y: 4})\n  //. {x: 2, y: 5}\n  //.\n  //. > S.ap(S.Just(Math.sqrt), S.Just(64))\n  //. Just(8)\n  //. ```\n  //.\n  //. Replacing `Apply f => f` with `Function x` produces the S combinator\n  //. from combinatory logic:\n  //.\n  //.     Apply f => f (a -> b) -> f a -> f b\n  //.     Function x (a -> b) -> Function x a -> Function x b\n  //.     Function x (a -> c) -> Function x a -> Function x c\n  //.     Function x (b -> c) -> Function x b -> Function x c\n  //.     Function a (b -> c) -> Function a b -> Function a c\n  //.     (a -> b -> c) -> (a -> b) -> (a -> c)\n  //.\n  //. ```javascript\n  //. > S.ap(s => n => s.slice(0, n), s => Math.ceil(s.length / 2))('Haskell')\n  //. 'Hask'\n  //. ```\n  S.ap =\n  def('ap',\n      {f: [Z.Apply]},\n      [f(Fn(a, b)), f(a), f(b)],\n      Z.ap);\n\n  //# lift2 :: Apply f => (a -> b -> c) -> f a -> f b -> f c\n  //.\n  //. Promotes a curried binary function to a function which operates on two\n  //. [Apply][]s.\n  //.\n  //. ```javascript\n  //. > S.lift2(S.add, S.Just(2), S.Just(3))\n  //. Just(5)\n  //.\n  //. > S.lift2(S.add, S.Just(2), S.Nothing)\n  //. Nothing\n  //.\n  //. > S.lift2(S.and, S.Just(true), S.Just(true))\n  //. Just(true)\n  //.\n  //. > S.lift2(S.and, S.Just(true), S.Just(false))\n  //. Just(false)\n  //. ```\n  S.lift2 =\n  def('lift2', {f: [Z.Apply]}, [Fn(a, Fn(b, c)), f(a), f(b), f(c)], Z.lift2);\n\n  //# lift3 :: Apply f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n  //.\n  //. Promotes a curried ternary function to a function which operates on three\n  //. [Apply][]s.\n  //.\n  //. ```javascript\n  //. > S.lift3(S.reduce, S.Just(S.add), S.Just(0), S.Just([1, 2, 3]))\n  //. Just(6)\n  //.\n  //. > S.lift3(S.reduce, S.Just(S.add), S.Just(0), S.Nothing)\n  //. Nothing\n  //. ```\n  S.lift3 =\n  def('lift3',\n      {f: [Z.Apply]},\n      [Fn(a, Fn(b, Fn(c, d))), f(a), f(b), f(c), f(d)],\n      Z.lift3);\n\n  //# apFirst :: Apply f => f a -> f b -> f a\n  //.\n  //. Curried version of [`Z.apFirst`][]. Combines two effectful actions,\n  //. keeping only the result of the first. Equivalent to Haskell's `(<*)`\n  //. function.\n  //.\n  //. See also [`apSecond`](#apSecond).\n  //.\n  //. ```javascript\n  //. > S.apFirst([1, 2], [3, 4])\n  //. [1, 1, 2, 2]\n  //.\n  //. > S.apFirst(S.Just(1), S.Just(2))\n  //. Just(1)\n  //. ```\n  S.apFirst = def('apFirst', {f: [Z.Apply]}, [f(a), f(b), f(a)], Z.apFirst);\n\n  //# apSecond :: Apply f => f a -> f b -> f b\n  //.\n  //. Curried version of [`Z.apSecond`][]. Combines two effectful actions,\n  //. keeping only the result of the second. Equivalent to Haskell's `(*>)`\n  //. function.\n  //.\n  //. See also [`apFirst`](#apFirst).\n  //.\n  //. ```javascript\n  //. > S.apSecond([1, 2], [3, 4])\n  //. [3, 4, 3, 4]\n  //.\n  //. > S.apSecond(S.Just(1), S.Just(2))\n  //. Just(2)\n  //. ```\n  S.apSecond = def('apSecond', {f: [Z.Apply]}, [f(a), f(b), f(b)], Z.apSecond);\n\n  //# of :: Applicative f => TypeRep f -> a -> f a\n  //.\n  //. Curried version of [`Z.of`][].\n  //.\n  //. ```javascript\n  //. > S.of(Array, 42)\n  //. [42]\n  //.\n  //. > S.of(Function, 42)(null)\n  //. 42\n  //.\n  //. > S.of(S.Maybe, 42)\n  //. Just(42)\n  //.\n  //. > S.of(S.Either, 42)\n  //. Right(42)\n  //. ```\n  S.of =\n  def('of',\n      {f: [Z.Applicative]},\n      [TypeRep($.TypeVariable('f')), a, f(a)],\n      Z.of);\n\n  //# chain :: Chain m => (a -> m b) -> m a -> m b\n  //.\n  //. Curried version of [`Z.chain`][].\n  //.\n  //. ```javascript\n  //. > S.chain(x => [x, x], [1, 2, 3])\n  //. [1, 1, 2, 2, 3, 3]\n  //.\n  //. > S.chain(n => s => s.slice(0, n), s => Math.ceil(s.length / 2))('slice')\n  //. 'sli'\n  //.\n  //. > S.chain(S.parseInt(10), S.Just('123'))\n  //. Just(123)\n  //.\n  //. > S.chain(S.parseInt(10), S.Just('XXX'))\n  //. Nothing\n  //. ```\n  S.chain = def('chain', {m: [Z.Chain]}, [Fn(a, m(b)), m(a), m(b)], Z.chain);\n\n  //# join :: Chain m => m (m a) -> m a\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.join`][].\n  //. Removes one level of nesting from a nested monadic structure.\n  //.\n  //. ```javascript\n  //. > S.join([[1], [2], [3]])\n  //. [1, 2, 3]\n  //.\n  //. > S.join([[[1, 2, 3]]])\n  //. [[1, 2, 3]]\n  //.\n  //. > S.join(S.Just(S.Just(1)))\n  //. S.Just(1)\n  //. ```\n  //.\n  //. Replacing `Chain m => m` with `Function x` produces the W combinator\n  //. from combinatory logic:\n  //.\n  //.     Chain m => m (m a) -> m a\n  //.     Function x (Function x a) -> Function x a\n  //.     (x -> x -> a) -> (x -> a)\n  //.\n  //. ```javascript\n  //. > S.join(S.concat)('abc')\n  //. 'abcabc'\n  //. ```\n  S.join = def('join', {m: [Z.Chain]}, [m(m(a)), m(a)], Z.join);\n\n  //# chainRec :: ChainRec m => TypeRep m -> (a -> m (Either a b)) -> a -> m b\n  //.\n  //. Performs a [`chain`](#chain)-like computation with constant stack usage.\n  //. Similar to [`Z.chainRec`][], but curried and more convenient due to the\n  //. use of the Either type to indicate completion (via a Right).\n  //.\n  //. ```javascript\n  //. > S.chainRec(Array,\n  //. .            s => s.length === 2 ? S.map(S.Right, [s + '!', s + '?'])\n  //. .                                : S.map(S.Left, [s + 'o', s + 'n']),\n  //. .            '')\n  //. ['oo!', 'oo?', 'on!', 'on?', 'no!', 'no?', 'nn!', 'nn?']\n  //. ```\n  function chainRec(typeRep, f, x) {\n    function step(next, done, x) {\n      return Z.map(function(e) { return either(next, done, e); }, f(x));\n    }\n    return Z.chainRec(typeRep, step, x);\n  }\n  S.chainRec =\n  def('chainRec',\n      {m: [Z.ChainRec]},\n      [TypeRep($.TypeVariable('m')), Fn(a, m($Either(a, b))), a, m(b)],\n      chainRec);\n\n  //# extend :: Extend w => (w a -> b) -> w a -> w b\n  //.\n  //. Curried version of [`Z.extend`][].\n  //.\n  //. ```javascript\n  //. > S.extend(S.joinWith(''), ['x', 'y', 'z'])\n  //. ['xyz', 'yz', 'z']\n  //. ```\n  S.extend =\n  def('extend', {w: [Z.Extend]}, [Fn(w(a), b), w(a), w(b)], Z.extend);\n\n  //# extract :: Comonad w => w a -> a\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.extract`][].\n  S.extract =\n  def('extract', {w: [Z.Comonad]}, [w(a), a], Z.extract);\n\n  //# contramap :: Contravariant f => (b -> a) -> f a -> f b\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.contramap`][].\n  //.\n  //. ```javascript\n  //. > S.contramap(s => s.length, Math.sqrt)('Sanctuary')\n  //. 3\n  //. ```\n  S.contramap =\n  def('contramap',\n      {f: [Z.Contravariant]},\n      [Fn(b, a), f(a), f(b)],\n      Z.contramap);\n\n  //# filter :: (Applicative f, Foldable f, Monoid (f a)) => (a -> Boolean) -> f a -> f a\n  //.\n  //. Curried version of [`Z.filter`][]. Filters its second argument in\n  //. accordance with the given predicate.\n  //.\n  //. See also [`filterM`](#filterM).\n  //.\n  //. ```javascript\n  //. > S.filter(S.odd, [1, 2, 3, 4, 5])\n  //. [1, 3, 5]\n  //. ```\n  S.filter =\n  def('filter',\n      {f: [Z.Applicative, Z.Foldable, Z.Monoid]},\n      [$.Predicate(a), f(a), f(a)],\n      Z.filter);\n\n  //# filterM :: (Alternative m, Monad m) => (a -> Boolean) -> m a -> m a\n  //.\n  //. Curried version of [`Z.filterM`][]. Filters its second argument in\n  //. accordance with the given predicate.\n  //.\n  //. See also [`filter`](#filter).\n  //.\n  //. ```javascript\n  //. > S.filterM(S.odd, [1, 2, 3, 4, 5])\n  //. [1, 3, 5]\n  //.\n  //. > S.filterM(S.odd, S.Just(9))\n  //. Just(9)\n  //.\n  //. > S.filterM(S.odd, S.Just(4))\n  //. Nothing\n  //. ```\n  S.filterM =\n  def('filterM',\n      {m: [Z.Alternative, Z.Monad]},\n      [$.Predicate(a), m(a), m(a)],\n      Z.filterM);\n\n  //# takeWhile :: (Foldable f, Alternative f) => (a -> Boolean) -> f a -> f a\n  //.\n  //. Discards the first inner value which does not satisfy the predicate, and\n  //. all subsequent inner values.\n  //.\n  //. ```javascript\n  //. > S.takeWhile(S.odd, [3, 3, 3, 7, 6, 3, 5, 4])\n  //. [3, 3, 3, 7]\n  //.\n  //. > S.takeWhile(S.even, [3, 3, 3, 7, 6, 3, 5, 4])\n  //. []\n  //. ```\n  S.takeWhile =\n  def('takeWhile',\n      {f: [Z.Foldable, Z.Alternative]},\n      [$.Predicate(a), f(a), f(a)],\n      Z.takeWhile);\n\n  //# dropWhile :: (Foldable f, Alternative f) => (a -> Boolean) -> f a -> f a\n  //.\n  //. Retains the first inner value which does not satisfy the predicate, and\n  //. all subsequent inner values.\n  //.\n  //. ```javascript\n  //. > S.dropWhile(S.odd, [3, 3, 3, 7, 6, 3, 5, 4])\n  //. [6, 3, 5, 4]\n  //.\n  //. > S.dropWhile(S.even, [3, 3, 3, 7, 6, 3, 5, 4])\n  //. [3, 3, 3, 7, 6, 3, 5, 4]\n  //. ```\n  S.dropWhile =\n  def('dropWhile',\n      {f: [Z.Foldable, Z.Alternative]},\n      [$.Predicate(a), f(a), f(a)],\n      Z.dropWhile);\n\n  //. ### Combinator\n\n  //# I :: a -> a\n  //.\n  //. The I combinator. Returns its argument. Equivalent to Haskell's `id`\n  //. function.\n  //.\n  //. ```javascript\n  //. > S.I('foo')\n  //. 'foo'\n  //. ```\n  function I(x) {\n    return x;\n  }\n  S.I = def('I', {}, [a, a], I);\n\n  //# K :: a -> b -> a\n  //.\n  //. The K combinator. Takes two values and returns the first. Equivalent to\n  //. Haskell's `const` function.\n  //.\n  //. ```javascript\n  //. > S.K('foo', 'bar')\n  //. 'foo'\n  //.\n  //. > S.map(S.K(42), S.range(0, 5))\n  //. [42, 42, 42, 42, 42]\n  //. ```\n  function K(x, y) {\n    return x;\n  }\n  S.K = def('K', {}, [a, b, a], K);\n\n  //# A :: (a -> b) -> a -> b\n  //.\n  //. The A combinator. Takes a function and a value, and returns the result\n  //. of applying the function to the value. Equivalent to Haskell's `($)`\n  //. function.\n  //.\n  //. ```javascript\n  //. > S.A(S.add(1), 42)\n  //. 43\n  //.\n  //. > S.map(S.A(S.__, 100), [S.add(1), Math.sqrt])\n  //. [101, 10]\n  //. ```\n  function A(f, x) {\n    return f(x);\n  }\n  S.A = def('A', {}, [Fn(a, b), a, b], A);\n\n  //# T :: a -> (a -> b) -> b\n  //.\n  //. The T ([thrush][]) combinator. Takes a value and a function, and returns\n  //. the result of applying the function to the value. Equivalent to Haskell's\n  //. `(&)` function.\n  //.\n  //. ```javascript\n  //. > S.T(42, S.add(1))\n  //. 43\n  //.\n  //. > S.map(S.T(100), [S.add(1), Math.sqrt])\n  //. [101, 10]\n  //. ```\n  function T(x, f) {\n    return f(x);\n  }\n  S.T = def('T', {}, [a, Fn(a, b), b], T);\n\n  //. ### Function\n\n  //# curry2 :: ((a, b) -> c) -> a -> b -> c\n  //.\n  //. Curries the given binary function.\n  //.\n  //. ```javascript\n  //. > S.map(S.curry2(Math.pow)(10), [1, 2, 3])\n  //. [10, 100, 1000]\n  //.\n  //. > S.map(S.curry2(Math.pow, 10), [1, 2, 3])\n  //. [10, 100, 1000]\n  //. ```\n  function curry2(f, x, y) {\n    return f(x, y);\n  }\n  S.curry2 =\n  def('curry2',\n      {},\n      [$.Function([a, b, c]), a, b, c],\n      curry2);\n\n  //# curry3 :: ((a, b, c) -> d) -> a -> b -> c -> d\n  //.\n  //. Curries the given ternary function.\n  //.\n  //. ```javascript\n  //. > global.replaceString = S.curry3((what, replacement, string) =>\n  //. .   string.replace(what, replacement)\n  //. . )\n  //. replaceString\n  //.\n  //. > replaceString('banana')('orange')('banana icecream')\n  //. 'orange icecream'\n  //.\n  //. > replaceString('banana', 'orange', 'banana icecream')\n  //. 'orange icecream'\n  //. ```\n  function curry3(f, x, y, z) {\n    return f(x, y, z);\n  }\n  S.curry3 =\n  def('curry3',\n      {},\n      [$.Function([a, b, c, d]), a, b, c, d],\n      curry3);\n\n  //# curry4 :: ((a, b, c, d) -> e) -> a -> b -> c -> d -> e\n  //.\n  //. Curries the given quaternary function.\n  //.\n  //. ```javascript\n  //. > global.createRect = S.curry4((x, y, width, height) =>\n  //. .   ({x, y, width, height})\n  //. . )\n  //. createRect\n  //.\n  //. > createRect(0)(0)(10)(10)\n  //. {x: 0, y: 0, width: 10, height: 10}\n  //.\n  //. > createRect(0, 0, 10, 10)\n  //. {x: 0, y: 0, width: 10, height: 10}\n  //. ```\n  function curry4(f, w, x, y, z) {\n    return f(w, x, y, z);\n  }\n  S.curry4 =\n  def('curry4',\n      {},\n      [$.Function([a, b, c, d, e]), a, b, c, d, e],\n      curry4);\n\n  //# curry5 :: ((a, b, c, d, e) -> f) -> a -> b -> c -> d -> e -> f\n  //.\n  //. Curries the given quinary function.\n  //.\n  //. ```javascript\n  //. > global.toUrl = S.curry5((protocol, creds, hostname, port, pathname) =>\n  //. .   protocol + '//' +\n  //. .   S.maybe('', _ => _.username + ':' + _.password + '@', creds) +\n  //. .   hostname +\n  //. .   S.maybe('', S.concat(':'), port) +\n  //. .   pathname\n  //. . )\n  //. toUrl\n  //.\n  //. > toUrl('https:')(S.Nothing)('example.com')(S.Just('443'))('/foo/bar')\n  //. 'https://example.com:443/foo/bar'\n  //.\n  //. > toUrl('https:', S.Nothing, 'example.com', S.Just('443'), '/foo/bar')\n  //. 'https://example.com:443/foo/bar'\n  //. ```\n  function curry5(f, v, w, x, y, z) {\n    return f(v, w, x, y, z);\n  }\n  S.curry5 =\n  def('curry5',\n      {},\n      [$.Function([a, b, c, d, e, r]), a, b, c, d, e, r],\n      curry5);\n\n  //# flip :: (a -> b -> c) -> b -> a -> c\n  //.\n  //. Takes a curried binary function and two values, and returns the\n  //. result of applying the function to the values in reverse order.\n  //.\n  //. This is the C combinator from combinatory logic.\n  //.\n  //. ```javascript\n  //. > S.flip(S.concat, 'foo', 'bar')\n  //. 'barfoo'\n  //. ```\n  function flip(f, x, y) {\n    return f(y)(x);\n  }\n  S.flip = def('flip', {}, [Fn(a, Fn(b, c)), b, a, c], flip);\n\n  //. ### Composition\n\n  //# compose :: Semigroupoid s => s b c -> s a b -> s a c\n  //.\n  //. Curried version of [`Z.compose`][].\n  //.\n  //. When specialized to Function, `compose` composes two unary functions,\n  //. from right to left (this is the B combinator from combinatory logic).\n  //.\n  //. The generalized type signature indicates that `compose` is compatible\n  //. with any [Semigroupoid][].\n  //.\n  //. See also [`pipe`](#pipe).\n  //.\n  //. ```javascript\n  //. > S.compose(Math.sqrt, S.add(1))(99)\n  //. 10\n  //. ```\n  S.compose =\n  def('compose',\n      {s: [Z.Semigroupoid]},\n      [s(b, c), s(a, b), s(a, c)],\n      Z.compose);\n\n  //# pipe :: [(a -> b), (b -> c), ..., (m -> n)] -> a -> n\n  //.\n  //. Takes an array of functions assumed to be unary and a value of any type,\n  //. and returns the result of applying the sequence of transformations to\n  //. the initial value.\n  //.\n  //. In general terms, `pipe` performs left-to-right composition of an array\n  //. of functions. `pipe([f, g, h], x)` is equivalent to `h(g(f(x)))`.\n  //.\n  //. ```javascript\n  //. > S.pipe([S.add(1), Math.sqrt, S.sub(1)], 99)\n  //. 9\n  //. ```\n  function pipe(fs, x) {\n    return Z.reduce(function(x, f) { return f(x); }, x, fs);\n  }\n  S.pipe = def('pipe', {}, [$.Array($.AnyFunction), a, b], pipe);\n\n  //# on :: (b -> b -> c) -> (a -> b) -> a -> a -> c\n  //.\n  //. Takes a binary function `f`, a unary function `g`, and two\n  //. values `x` and `y`. Returns `f(g(x))(g(y))`.\n  //.\n  //. This is the P combinator from combinatory logic.\n  //.\n  //. ```javascript\n  //. > S.on(S.concat, S.reverse, [1, 2, 3], [4, 5, 6])\n  //. [3, 2, 1, 6, 5, 4]\n  //. ```\n  function on(f, g, x, y) {\n    return f(g(x))(g(y));\n  }\n  S.on = def('on', {}, [Fn(b, Fn(b, c)), Fn(a, b), a, a, c], on);\n\n  //. ### Maybe type\n  //.\n  //. The Maybe type represents optional values: a value of type `Maybe a` is\n  //. either a Just whose value is of type `a` or Nothing (with no value).\n  //.\n  //. The Maybe type satisfies the [Ord][], [Monoid][], [Monad][],\n  //. [Alternative][], [Traversable][], and [Extend][] specifications.\n\n  //# MaybeType :: Type -> Type\n  //.\n  //. A [`UnaryType`][UnaryType] for use with [sanctuary-def][].\n  S.MaybeType = $Maybe;\n\n  //# Maybe :: TypeRep Maybe\n  //.\n  //. The [type representative](#type-representatives) for the Maybe type.\n  var Maybe = S.Maybe = {prototype: _Maybe.prototype};\n\n  Maybe.prototype.constructor = Maybe;\n\n  function _Maybe(tag, value) {\n    this.isNothing = tag === 'Nothing';\n    this.isJust = tag === 'Just';\n    if (this.isJust) this.value = value;\n\n    //  Add \"fantasy-land/concat\" method conditionally so that Just('abc')\n    //  satisfies the requirements of Semigroup but Just(123) does not.\n    if (this.isNothing || Z.Semigroup.test(this.value)) {\n      this['fantasy-land/concat'] = Maybe$prototype$concat;\n    }\n\n    if (this.isNothing || Z.Setoid.test(this.value)) {\n      this['fantasy-land/equals'] = Maybe$prototype$equals;\n    }\n\n    if (this.isNothing || Z.Ord.test(this.value)) {\n      this['fantasy-land/lte'] = Maybe$prototype$lte;\n    }\n  }\n\n  //# Nothing :: Maybe a\n  //.\n  //. Nothing.\n  //.\n  //. ```javascript\n  //. > S.Nothing\n  //. Nothing\n  //. ```\n  var Nothing = S.Nothing = new _Maybe('Nothing');\n\n  //# Just :: a -> Maybe a\n  //.\n  //. Takes a value of any type and returns a Just with the given value.\n  //.\n  //. ```javascript\n  //. > S.Just(42)\n  //. Just(42)\n  //. ```\n  function Just(x) {\n    return new _Maybe('Just', x);\n  }\n  S.Just = def('Just', {}, [a, $Maybe(a)], Just);\n\n  //# Maybe.@@type :: String\n  //.\n  //. Maybe type identifier, `'sanctuary/Maybe'`.\n  Maybe['@@type'] = maybeTypeIdent;\n\n  //# Maybe.fantasy-land/empty :: () -> Maybe a\n  //.\n  //. Returns Nothing.\n  //.\n  //. It is idiomatic to use [`empty`](#empty) rather than use this function\n  //. directly.\n  //.\n  //. ```javascript\n  //. > S.empty(S.Maybe)\n  //. Nothing\n  //. ```\n  Maybe['fantasy-land/empty'] = function() { return Nothing; };\n\n  //# Maybe.fantasy-land/of :: a -> Maybe a\n  //.\n  //. Takes a value of any type and returns a Just with the given value.\n  //.\n  //. It is idiomatic to use [`of`](#of) rather than use this function\n  //. directly.\n  //.\n  //. ```javascript\n  //. > S.of(S.Maybe, 42)\n  //. Just(42)\n  //. ```\n  Maybe['fantasy-land/of'] = Just;\n\n  //# Maybe.fantasy-land/zero :: () -> Maybe a\n  //.\n  //. Returns Nothing.\n  //.\n  //. It is idiomatic to use [`zero`](#zero) rather than use this function\n  //. directly.\n  //.\n  //. ```javascript\n  //. > S.zero(S.Maybe)\n  //. Nothing\n  //. ```\n  Maybe['fantasy-land/zero'] = function() { return Nothing; };\n\n  //# Maybe#isNothing :: Maybe a ~> Boolean\n  //.\n  //. `true` if `this` is Nothing; `false` if `this` is a Just.\n  //.\n  //. ```javascript\n  //. > S.Nothing.isNothing\n  //. true\n  //.\n  //. > S.Just(42).isNothing\n  //. false\n  //. ```\n\n  //# Maybe#isJust :: Maybe a ~> Boolean\n  //.\n  //. `true` if `this` is a Just; `false` if `this` is Nothing.\n  //.\n  //. ```javascript\n  //. > S.Just(42).isJust\n  //. true\n  //.\n  //. > S.Nothing.isJust\n  //. false\n  //. ```\n\n  //# Maybe#toString :: Maybe a ~> () -> String\n  //.\n  //. Returns the string representation of the Maybe.\n  //.\n  //. ```javascript\n  //. > S.toString(S.Nothing)\n  //. 'Nothing'\n  //.\n  //. > S.toString(S.Just([1, 2, 3]))\n  //. 'Just([1, 2, 3])'\n  //. ```\n  Maybe.prototype.toString = function() {\n    return this.isJust ? 'Just(' + Z.toString(this.value) + ')' : 'Nothing';\n  };\n\n  //# Maybe#inspect :: Maybe a ~> () -> String\n  //.\n  //. Returns the string representation of the Maybe. This method is used by\n  //. `util.inspect` and the REPL to format a Maybe for display.\n  //.\n  //. See also [`Maybe#toString`][].\n  //.\n  //. ```javascript\n  //. > S.Nothing.inspect()\n  //. 'Nothing'\n  //.\n  //. > S.Just([1, 2, 3]).inspect()\n  //. 'Just([1, 2, 3])'\n  //. ```\n  Maybe.prototype.inspect = function() { return this.toString(); };\n\n  //# Maybe#fantasy-land/equals :: Setoid a => Maybe a ~> Maybe a -> Boolean\n  //.\n  //. Takes a value `m` of the same type and returns `true` if:\n  //.\n  //.   - `this` and `m` are both Nothing; or\n  //.\n  //.   - `this` and `m` are both Justs, and their values are equal according\n  //.     to [`Z.equals`][].\n  //.\n  //. It is idiomatic to use [`equals`](#equals) rather than use this method\n  //. directly.\n  //.\n  //. ```javascript\n  //. > S.equals(S.Nothing, S.Nothing)\n  //. true\n  //.\n  //. > S.equals(S.Just([1, 2, 3]), S.Just([1, 2, 3]))\n  //. true\n  //.\n  //. > S.equals(S.Just([1, 2, 3]), S.Just([3, 2, 1]))\n  //. false\n  //.\n  //. > S.equals(S.Just([1, 2, 3]), S.Nothing)\n  //. false\n  //. ```\n  function Maybe$prototype$equals(other) {\n    return this.isNothing ? other.isNothing\n                          : other.isJust && Z.equals(this.value, other.value);\n  }\n\n  //# Maybe#fantasy-land/lte :: Ord a => Maybe a ~> Maybe a -> Boolean\n  //.\n  //. Takes a value `m` of the same type and returns `true` if:\n  //.\n  //.   - `this` is Nothing; or\n  //.\n  //.   - `this` and `m` are both Justs and the value of `this` is less than\n  //.     or equal to the value of `m` according to [`Z.lte`][].\n  //.\n  //. It is idiomatic to use [`lte`](#lte) or [`lte_`](#lte_) rather than use\n  //. this method directly.\n  //.\n  //. ```javascript\n  //. > S.lte_(S.Nothing, S.Nothing)\n  //. true\n  //.\n  //. > S.lte_(S.Nothing, S.Just(0))\n  //. true\n  //.\n  //. > S.lte_(S.Just(0), S.Nothing)\n  //. false\n  //.\n  //. > S.lte_(S.Just(0), S.Just(1))\n  //. true\n  //.\n  //. > S.lte_(S.Just(1), S.Just(0))\n  //. false\n  //. ```\n  function Maybe$prototype$lte(other) {\n    return this.isNothing || other.isJust && Z.lte(this.value, other.value);\n  }\n\n  //# Maybe#fantasy-land/concat :: Semigroup a => Maybe a ~> Maybe a -> Maybe a\n  //.\n  //. Returns the result of concatenating two Maybe values of the same type.\n  //. `a` must have a [Semigroup][].\n  //.\n  //. If `this` is Nothing and the argument is Nothing, this method returns\n  //. Nothing.\n  //.\n  //. If `this` is a Just and the argument is a Just, this method returns a\n  //. Just whose value is the result of concatenating this Just's value and\n  //. the given Just's value.\n  //.\n  //. Otherwise, this method returns the Just.\n  //.\n  //. It is idiomatic to use [`concat`](#concat) rather than use this method\n  //. directly.\n  //.\n  //. ```javascript\n  //. > S.concat(S.Nothing, S.Nothing)\n  //. Nothing\n  //.\n  //. > S.concat(S.Just([1, 2, 3]), S.Just([4, 5, 6]))\n  //. Just([1, 2, 3, 4, 5, 6])\n  //.\n  //. > S.concat(S.Nothing, S.Just([1, 2, 3]))\n  //. Just([1, 2, 3])\n  //.\n  //. > S.concat(S.Just([1, 2, 3]), S.Nothing)\n  //. Just([1, 2, 3])\n  //. ```\n  function Maybe$prototype$concat(other) {\n    return this.isNothing ?\n      other :\n      other.isNothing ? this : Just(Z.concat(this.value, other.value));\n  }\n\n  //# Maybe#fantasy-land/map :: Maybe a ~> (a -> b) -> Maybe b\n  //.\n  //. Takes a function and returns `this` if `this` is Nothing; otherwise\n  //. it returns a Just whose value is the result of applying the function\n  //. to this Just's value.\n  //.\n  //. It is idiomatic to use [`map`](#map) rather than use this method\n  //. directly.\n  //.\n  //. ```javascript\n  //. > S.map(Math.sqrt, S.Nothing)\n  //. Nothing\n  //.\n  //. > S.map(Math.sqrt, S.Just(9))\n  //. Just(3)\n  //. ```\n  Maybe.prototype['fantasy-land/map'] = function(f) {\n    return this.isJust ? Just(f(this.value)) : this;\n  };\n\n  //# Maybe#fantasy-land/ap :: Maybe a ~> Maybe (a -> b) -> Maybe b\n  //.\n  //. Takes a Maybe and returns Nothing unless `this` is a Just *and* the\n  //. argument is a Just, in which case it returns a Just whose value is\n  //. the result of applying the given Just's value to this Just's value.\n  //.\n  //. It is idiomatic to use [`ap`](#ap) rather than use this method directly.\n  //.\n  //. ```javascript\n  //. > S.ap(S.Nothing, S.Nothing)\n  //. Nothing\n  //.\n  //. > S.ap(S.Nothing, S.Just(9))\n  //. Nothing\n  //.\n  //. > S.ap(S.Just(Math.sqrt), S.Nothing)\n  //. Nothing\n  //.\n  //. > S.ap(S.Just(Math.sqrt), S.Just(9))\n  //. Just(3)\n  //. ```\n  Maybe.prototype['fantasy-land/ap'] = function(other) {\n    return other.isJust ? Z.map(other.value, this) : other;\n  };\n\n  //# Maybe#fantasy-land/chain :: Maybe a ~> (a -> Maybe b) -> Maybe b\n  //.\n  //. Takes a function and returns `this` if `this` is Nothing; otherwise\n  //. it returns the result of applying the function to this Just's value.\n  //.\n  //. It is idiomatic to use [`chain`](#chain) rather than use this method\n  //. directly.\n  //.\n  //. ```javascript\n  //. > S.chain(S.parseFloat, S.Nothing)\n  //. Nothing\n  //.\n  //. > S.chain(S.parseFloat, S.Just('xxx'))\n  //. Nothing\n  //.\n  //. > S.chain(S.parseFloat, S.Just('12.34'))\n  //. Just(12.34)\n  //. ```\n  Maybe.prototype['fantasy-land/chain'] = function(f) {\n    return this.isJust ? f(this.value) : this;\n  };\n\n  //# Maybe#fantasy-land/alt :: Maybe a ~> Maybe a -> Maybe a\n  //.\n  //. Chooses between `this` and the other Maybe provided as an argument.\n  //. Returns `this` if `this` is a Just; the other Maybe otherwise.\n  //.\n  //. It is idiomatic to use [`alt`](#alt) rather than use this method\n  //. directly.\n  //.\n  //. ```javascript\n  //. > S.alt(S.Nothing, S.Nothing)\n  //. Nothing\n  //.\n  //. > S.alt(S.Nothing, S.Just(1))\n  //. Just(1)\n  //.\n  //. > S.alt(S.Just(2), S.Nothing)\n  //. Just(2)\n  //.\n  //. > S.alt(S.Just(3), S.Just(4))\n  //. Just(3)\n  //. ```\n  Maybe.prototype['fantasy-land/alt'] = function(other) {\n    return this.isJust ? this : other;\n  };\n\n  //# Maybe#fantasy-land/reduce :: Maybe a ~> ((b, a) -> b, b) -> b\n  //.\n  //. Takes a function and an initial value of any type, and returns:\n  //.\n  //.   - the initial value if `this` is Nothing; otherwise\n  //.\n  //.   - the result of applying the function to the initial value and this\n  //.     Just's value.\n  //.\n  //. It is idiomatic to use [`reduce`](#reduce) rather than use this method\n  //. directly.\n  //.\n  //. ```javascript\n  //. > S.reduce(S.curry2(Math.pow), 10, S.Nothing)\n  //. 10\n  //.\n  //. > S.reduce(S.curry2(Math.pow), 10, S.Just(3))\n  //. 1000\n  //. ```\n  Maybe.prototype['fantasy-land/reduce'] = function(f, x) {\n    return this.isJust ? f(x, this.value) : x;\n  };\n\n  //# Maybe#fantasy-land/traverse :: Applicative f => Maybe a ~> (TypeRep f, a -> f b) -> f (Maybe b)\n  //.\n  //. Takes the type representative of some [Applicative][] and a function\n  //. which returns a value of that Applicative, and returns:\n  //.\n  //.   - the result of applying the type representative's [`of`][] function to\n  //.     `this` if `this` is Nothing; otherwise\n  //.\n  //.   - the result of mapping [`Just`](#Just) over the result of applying the\n  //.     first function to this Just's value.\n  //.\n  //. It is idiomatic to use [`traverse`](#traverse) rather than use this\n  //. method directly.\n  //.\n  //. ```javascript\n  //. > S.traverse(Array, S.words, S.Nothing)\n  //. [Nothing]\n  //.\n  //. > S.traverse(Array, S.words, S.Just('foo bar baz'))\n  //. [Just('foo'), Just('bar'), Just('baz')]\n  //. ```\n  Maybe.prototype['fantasy-land/traverse'] = function(typeRep, f) {\n    return this.isJust ? Z.map(Just, f(this.value)) : Z.of(typeRep, this);\n  };\n\n  //# Maybe#fantasy-land/extend :: Maybe a ~> (Maybe a -> b) -> Maybe b\n  //.\n  //. Takes a function and returns `this` if `this` is Nothing; otherwise\n  //. it returns a Just whose value is the result of applying the function\n  //. to `this`.\n  //.\n  //. It is idiomatic to use [`extend`](#extend) rather than use this method\n  //. directly.\n  //.\n  //. ```javascript\n  //. > S.extend(x => x.value + 1, S.Nothing)\n  //. Nothing\n  //.\n  //. > S.extend(x => x.value + 1, S.Just(42))\n  //. Just(43)\n  //. ```\n  Maybe.prototype['fantasy-land/extend'] = function(f) {\n    return this.isJust ? Just(f(this)) : this;\n  };\n\n  //# isNothing :: Maybe a -> Boolean\n  //.\n  //. Returns `true` if the given Maybe is Nothing; `false` if it is a Just.\n  //.\n  //. ```javascript\n  //. > S.isNothing(S.Nothing)\n  //. true\n  //.\n  //. > S.isNothing(S.Just(42))\n  //. false\n  //. ```\n  function isNothing(maybe) {\n    return maybe.isNothing;\n  }\n  S.isNothing = def('isNothing', {}, [$Maybe(a), $.Boolean], isNothing);\n\n  //# isJust :: Maybe a -> Boolean\n  //.\n  //. Returns `true` if the given Maybe is a Just; `false` if it is Nothing.\n  //.\n  //. ```javascript\n  //. > S.isJust(S.Just(42))\n  //. true\n  //.\n  //. > S.isJust(S.Nothing)\n  //. false\n  //. ```\n  function isJust(maybe) {\n    return maybe.isJust;\n  }\n  S.isJust = def('isJust', {}, [$Maybe(a), $.Boolean], isJust);\n\n  //# fromMaybe :: a -> Maybe a -> a\n  //.\n  //. Takes a default value and a Maybe, and returns the Maybe's value\n  //. if the Maybe is a Just; the default value otherwise.\n  //.\n  //. See also [`fromMaybe_`](#fromMaybe_) and\n  //. [`maybeToNullable`](#maybeToNullable).\n  //.\n  //. ```javascript\n  //. > S.fromMaybe(0, S.Just(42))\n  //. 42\n  //.\n  //. > S.fromMaybe(0, S.Nothing)\n  //. 0\n  //. ```\n  function fromMaybe(x, maybe) {\n    return maybe.isJust ? maybe.value : x;\n  }\n  S.fromMaybe = def('fromMaybe', {}, [a, $Maybe(a), a], fromMaybe);\n\n  //# fromMaybe_ :: (() -> a) -> Maybe a -> a\n  //.\n  //. Variant of [`fromMaybe`](#fromMaybe) which takes a thunk so the default\n  //. value is only computed if required.\n  //.\n  //. ```javascript\n  //. > function fib(n) { return n <= 1 ? n : fib(n - 2) + fib(n - 1); }\n  //.\n  //. > S.fromMaybe_(() => fib(30), S.Just(1000000))\n  //. 1000000\n  //.\n  //. > S.fromMaybe_(() => fib(30), S.Nothing)\n  //. 832040\n  //. ```\n  function fromMaybe_(thunk, maybe) {\n    return maybe.isJust ? maybe.value : thunk();\n  }\n  S.fromMaybe_ = def('fromMaybe_', {}, [$.Thunk(a), $Maybe(a), a], fromMaybe_);\n\n  //# maybeToNullable :: Maybe a -> Nullable a\n  //.\n  //. Returns the given Maybe's value if the Maybe is a Just; `null` otherwise.\n  //. [Nullable][] is defined in [sanctuary-def][].\n  //.\n  //. See also [`fromMaybe`](#fromMaybe).\n  //.\n  //. ```javascript\n  //. > S.maybeToNullable(S.Just(42))\n  //. 42\n  //.\n  //. > S.maybeToNullable(S.Nothing)\n  //. null\n  //. ```\n  function maybeToNullable(maybe) {\n    return maybe.isJust ? maybe.value : null;\n  }\n  S.maybeToNullable =\n  def('maybeToNullable', {}, [$Maybe(a), $.Nullable(a)], maybeToNullable);\n\n  //# toMaybe :: a? -> Maybe a\n  //.\n  //. Takes a value and returns Nothing if the value is `null` or `undefined`;\n  //. Just the value otherwise.\n  //.\n  //. ```javascript\n  //. > S.toMaybe(null)\n  //. Nothing\n  //.\n  //. > S.toMaybe(42)\n  //. Just(42)\n  //. ```\n  function toMaybe(x) {\n    return x == null ? Nothing : Just(x);\n  }\n  S.toMaybe = def('toMaybe', {}, [a, $Maybe(a)], toMaybe);\n\n  //# maybe :: b -> (a -> b) -> Maybe a -> b\n  //.\n  //. Takes a value of any type, a function, and a Maybe. If the Maybe is\n  //. a Just, the return value is the result of applying the function to\n  //. the Just's value. Otherwise, the first argument is returned.\n  //.\n  //. See also [`maybe_`](#maybe_).\n  //.\n  //. ```javascript\n  //. > S.maybe(0, S.prop('length'), S.Just('refuge'))\n  //. 6\n  //.\n  //. > S.maybe(0, S.prop('length'), S.Nothing)\n  //. 0\n  //. ```\n  function maybe(x, f, maybe) {\n    return fromMaybe(x, Z.map(f, maybe));\n  }\n  S.maybe = def('maybe', {}, [b, Fn(a, b), $Maybe(a), b], maybe);\n\n  //# maybe_ :: (() -> b) -> (a -> b) -> Maybe a -> b\n  //.\n  //. Variant of [`maybe`](#maybe) which takes a thunk so the default value\n  //. is only computed if required.\n  //.\n  //. ```javascript\n  //. > function fib(n) { return n <= 1 ? n : fib(n - 2) + fib(n - 1); }\n  //.\n  //. > S.maybe_(() => fib(30), Math.sqrt, S.Just(1000000))\n  //. 1000\n  //.\n  //. > S.maybe_(() => fib(30), Math.sqrt, S.Nothing)\n  //. 832040\n  //. ```\n  function maybe_(thunk, f, maybe) {\n    return maybe.isJust ? f(maybe.value) : thunk();\n  }\n  S.maybe_ = def('maybe_', {}, [$.Thunk(b), Fn(a, b), $Maybe(a), b], maybe_);\n\n  //# justs :: Array (Maybe a) -> Array a\n  //.\n  //. Takes an array of Maybes and returns an array containing each Just's\n  //. value. Equivalent to Haskell's `catMaybes` function.\n  //.\n  //. See also [`lefts`](#lefts) and [`rights`](#rights).\n  //.\n  //. ```javascript\n  //. > S.justs([S.Just('foo'), S.Nothing, S.Just('baz')])\n  //. ['foo', 'baz']\n  //. ```\n  function justs(maybes) {\n    return Z.reduce(function(xs, maybe) {\n      if (maybe.isJust) xs.push(maybe.value);\n      return xs;\n    }, [], maybes);\n  }\n  S.justs = def('justs', {}, [$.Array($Maybe(a)), $.Array(a)], justs);\n\n  //# mapMaybe :: (a -> Maybe b) -> Array a -> Array b\n  //.\n  //. Takes a function and an array, applies the function to each element of\n  //. the array, and returns an array of \"successful\" results. If the result of\n  //. applying the function to an element of the array is Nothing, the result\n  //. is discarded; if the result is a Just, the Just's value is included in\n  //. the output array.\n  //.\n  //. In general terms, `mapMaybe` filters an array while mapping over it.\n  //.\n  //. ```javascript\n  //. > S.mapMaybe(S.head, [[], [1, 2, 3], [], [4, 5, 6], []])\n  //. [1, 4]\n  //. ```\n  function mapMaybe(f, xs) {\n    return justs(Z.map(f, xs));\n  }\n  S.mapMaybe =\n  def('mapMaybe', {}, [Fn(a, $Maybe(b)), $.Array(a), $.Array(b)], mapMaybe);\n\n  //# encase :: (a -> b) -> a -> Maybe b\n  //.\n  //. Takes a unary function `f` which may throw and a value `x` of any type,\n  //. and applies `f` to `x` inside a `try` block. If an exception is caught,\n  //. the return value is Nothing; otherwise the return value is Just the\n  //. result of applying `f` to `x`.\n  //.\n  //. See also [`encaseEither`](#encaseEither).\n  //.\n  //. ```javascript\n  //. > S.encase(eval, '1 + 1')\n  //. Just(2)\n  //.\n  //. > S.encase(eval, '1 +')\n  //. Nothing\n  //. ```\n  function encase(f, x) {\n    try {\n      return Just(f(x));\n    } catch (err) {\n      return Nothing;\n    }\n  }\n  S.encase = def('encase', {}, [Fn(a, b), a, $Maybe(b)], encase);\n\n  //# encase2 :: (a -> b -> c) -> a -> b -> Maybe c\n  //.\n  //. Binary version of [`encase`](#encase).\n  function encase2(f, x, y) {\n    try {\n      return Just(f(x)(y));\n    } catch (err) {\n      return Nothing;\n    }\n  }\n  S.encase2 = def('encase2', {}, [Fn(a, Fn(b, c)), a, b, $Maybe(c)], encase2);\n\n  //# encase3 :: (a -> b -> c -> d) -> a -> b -> c -> Maybe d\n  //.\n  //. Ternary version of [`encase`](#encase).\n  function encase3(f, x, y, z) {\n    try {\n      return Just(f(x)(y)(z));\n    } catch (err) {\n      return Nothing;\n    }\n  }\n  S.encase3 =\n  def('encase3', {}, [Fn(a, Fn(b, Fn(c, d))), a, b, c, $Maybe(d)], encase3);\n\n  //# maybeToEither :: a -> Maybe b -> Either a b\n  //.\n  //. Converts a Maybe to an Either. Nothing becomes a Left (containing the\n  //. first argument); a Just becomes a Right.\n  //.\n  //. See also [`eitherToMaybe`](#eitherToMaybe).\n  //.\n  //. ```javascript\n  //. > S.maybeToEither('Expecting an integer', S.parseInt(10, 'xyz'))\n  //. Left('Expecting an integer')\n  //.\n  //. > S.maybeToEither('Expecting an integer', S.parseInt(10, '42'))\n  //. Right(42)\n  //. ```\n  function maybeToEither(x, maybe) {\n    return maybe.isNothing ? Left(x) : Right(maybe.value);\n  }\n  S.maybeToEither =\n  def('maybeToEither', {}, [a, $Maybe(b), $Either(a, b)], maybeToEither);\n\n  //. ### Either type\n  //.\n  //. The Either type represents values with two possibilities: a value of type\n  //. `Either a b` is either a Left whose value is of type `a` or a Right whose\n  //. value is of type `b`.\n  //.\n  //. The Either type satisfies the [Ord][], [Semigroup][], [Monad][],\n  //. [Alt][], [Traversable][], [Extend][], and [Bifunctor][] specifications.\n\n  //# EitherType :: Type -> Type -> Type\n  //.\n  //. A [`BinaryType`][BinaryType] for use with [sanctuary-def][].\n  S.EitherType = $Either;\n\n  //# Either :: TypeRep Either\n  //.\n  //. The [type representative](#type-representatives) for the Either type.\n  var Either = S.Either = {prototype: _Either.prototype};\n\n  Either.prototype.constructor = Either;\n\n  function _Either(tag, value) {\n    this.isLeft = tag === 'Left';\n    this.isRight = tag === 'Right';\n    this.value = value;\n\n    //  Add \"fantasy-land/concat\" method conditionally so that Left('abc')\n    //  and Right('abc') satisfy the requirements of Semigroup but Left(123)\n    //  and Right(123) do not.\n    if (Z.Semigroup.test(this.value)) {\n      this['fantasy-land/concat'] = Either$prototype$concat;\n    }\n\n    if (Z.Setoid.test(this.value)) {\n      this['fantasy-land/equals'] = Either$prototype$equals;\n    }\n\n    if (Z.Ord.test(this.value)) {\n      this['fantasy-land/lte'] = Either$prototype$lte;\n    }\n  }\n\n  //# Left :: a -> Either a b\n  //.\n  //. Takes a value of any type and returns a Left with the given value.\n  //.\n  //. ```javascript\n  //. > S.Left('Cannot divide by zero')\n  //. Left('Cannot divide by zero')\n  //. ```\n  function Left(x) {\n    return new _Either('Left', x);\n  }\n  S.Left = def('Left', {}, [a, $Either(a, b)], Left);\n\n  //# Right :: b -> Either a b\n  //.\n  //. Takes a value of any type and returns a Right with the given value.\n  //.\n  //. ```javascript\n  //. > S.Right(42)\n  //. Right(42)\n  //. ```\n  function Right(x) {\n    return new _Either('Right', x);\n  }\n  S.Right = def('Right', {}, [b, $Either(a, b)], Right);\n\n  //# Either.@@type :: String\n  //.\n  //. Either type identifier, `'sanctuary/Either'`.\n  Either['@@type'] = eitherTypeIdent;\n\n  //# Either.fantasy-land/of :: b -> Either a b\n  //.\n  //. Takes a value of any type and returns a Right with the given value.\n  //.\n  //. It is idiomatic to use [`of`](#of) rather than use this function\n  //. directly.\n  //.\n  //. ```javascript\n  //. > S.of(S.Either, 42)\n  //. Right(42)\n  //. ```\n  Either['fantasy-land/of'] = Right;\n\n  //# Either#isLeft :: Either a b ~> Boolean\n  //.\n  //. `true` if `this` is a Left; `false` if `this` is a Right.\n  //.\n  //. ```javascript\n  //. > S.Left('Cannot divide by zero').isLeft\n  //. true\n  //.\n  //. > S.Right(42).isLeft\n  //. false\n  //. ```\n\n  //# Either#isRight :: Either a b ~> Boolean\n  //.\n  //. `true` if `this` is a Right; `false` if `this` is a Left.\n  //.\n  //. ```javascript\n  //. > S.Right(42).isRight\n  //. true\n  //.\n  //. > S.Left('Cannot divide by zero').isRight\n  //. false\n  //. ```\n\n  //# Either#toString :: Either a b ~> () -> String\n  //.\n  //. Returns the string representation of the Either.\n  //.\n  //. ```javascript\n  //. > S.toString(S.Left('Cannot divide by zero'))\n  //. 'Left(\"Cannot divide by zero\")'\n  //.\n  //. > S.toString(S.Right([1, 2, 3]))\n  //. 'Right([1, 2, 3])'\n  //. ```\n  Either.prototype.toString = function() {\n    return (this.isLeft ? 'Left' : 'Right') +\n           '(' + Z.toString(this.value) + ')';\n  };\n\n  //# Either#inspect :: Either a b ~> () -> String\n  //.\n  //. Returns the string representation of the Either. This method is used by\n  //. `util.inspect` and the REPL to format a Either for display.\n  //.\n  //. See also [`Either#toString`][].\n  //.\n  //. ```javascript\n  //. > S.Left('Cannot divide by zero').inspect()\n  //. 'Left(\"Cannot divide by zero\")'\n  //.\n  //. > S.Right([1, 2, 3]).inspect()\n  //. 'Right([1, 2, 3])'\n  //. ```\n  Either.prototype.inspect = function() { return this.toString(); };\n\n  //# Either#fantasy-land/equals :: (Setoid a, Setoid b) => Either a b ~> Either a b -> Boolean\n  //.\n  //. Takes a value `e` of the same type and returns `true` if:\n  //.\n  //.   - `this` and `e` are both Lefts or both Rights, and their values are\n  //.     equal according to [`Z.equals`][].\n  //.\n  //. It is idiomatic to use [`equals`](#equals) rather than use this method\n  //. directly.\n  //.\n  //. ```javascript\n  //. > S.equals(S.Right([1, 2, 3]), S.Right([1, 2, 3]))\n  //. true\n  //.\n  //. > S.equals(S.Right([1, 2, 3]), S.Left([1, 2, 3]))\n  //. false\n  //. ```\n  function Either$prototype$equals(other) {\n    return this.isLeft === other.isLeft && Z.equals(this.value, other.value);\n  }\n\n  //# Either#fantasy-land/lte :: (Ord a, Ord b) => Either a b ~> Either a b -> Boolean\n  //.\n  //. Takes a value `e` of the same type and returns `true` if:\n  //.\n  //.   - `this` is a Left and `e` is a Right; or\n  //.\n  //.   - `this` and `e` are both Lefts or both Rights, and the value of `this`\n  //.     is less than or equal to the value of `e` according to [`Z.lte`][].\n  //.\n  //. It is idiomatic to use [`lte`](#lte) or [`lte_`](#lte_) rather than use\n  //. this method directly.\n  //.\n  //. ```javascript\n  //. > S.lte_(S.Left(10), S.Right(0))\n  //. true\n  //.\n  //. > S.lte_(S.Right(0), S.Left(10))\n  //. false\n  //.\n  //. > S.lte_(S.Right(0), S.Right(1))\n  //. true\n  //.\n  //. > S.lte_(S.Right(1), S.Right(0))\n  //. false\n  //. ```\n  function Either$prototype$lte(other) {\n    return this.isLeft === other.isLeft ?\n      Z.lte(this.value, other.value) :\n      this.isLeft;\n  }\n\n  //# Either#fantasy-land/concat :: (Semigroup a, Semigroup b) => Either a b ~> Either a b -> Either a b\n  //.\n  //. Returns the result of concatenating two Either values of the same type.\n  //. `a` must have a [Semigroup][], as must `b`.\n  //.\n  //. If `this` is a Left and the argument is a Left, this method returns a\n  //. Left whose value is the result of concatenating this Left's value and\n  //. the given Left's value.\n  //.\n  //. If `this` is a Right and the argument is a Right, this method returns a\n  //. Right whose value is the result of concatenating this Right's value and\n  //. the given Right's value.\n  //.\n  //. Otherwise, this method returns the Right.\n  //.\n  //. It is idiomatic to use [`concat`](#concat) rather than use this method\n  //. directly.\n  //.\n  //. ```javascript\n  //. > S.concat(S.Left('abc'), S.Left('def'))\n  //. Left('abcdef')\n  //.\n  //. > S.concat(S.Right([1, 2, 3]), S.Right([4, 5, 6]))\n  //. Right([1, 2, 3, 4, 5, 6])\n  //.\n  //. > S.concat(S.Left('abc'), S.Right([1, 2, 3]))\n  //. Right([1, 2, 3])\n  //.\n  //. > S.concat(S.Right([1, 2, 3]), S.Left('abc'))\n  //. Right([1, 2, 3])\n  //. ```\n  function Either$prototype$concat(other) {\n    return this.isLeft ?\n      other.isLeft ? Left(Z.concat(this.value, other.value)) : other :\n      other.isLeft ? this : Right(Z.concat(this.value, other.value));\n  }\n\n  //# Either#fantasy-land/map :: Either a b ~> (b -> c) -> Either a c\n  //.\n  //. Takes a function and returns `this` if `this` is a Left; otherwise it\n  //. returns a Right whose value is the result of applying the function to\n  //. this Right's value.\n  //.\n  //. It is idiomatic to use [`map`](#map) rather than use this method\n  //. directly.\n  //.\n  //. See also [`Either#fantasy-land/bimap`][].\n  //.\n  //. ```javascript\n  //. > S.map(Math.sqrt, S.Left('Cannot divide by zero'))\n  //. Left('Cannot divide by zero')\n  //.\n  //. > S.map(Math.sqrt, S.Right(9))\n  //. Right(3)\n  //. ```\n  Either.prototype['fantasy-land/map'] = function(f) {\n    return this.isRight ? Right(f(this.value)) : this;\n  };\n\n  //# Either#fantasy-land/bimap :: Either a b ~> (a -> c, b -> d) -> Either c d\n  //.\n  //. Takes two functions and returns:\n  //.\n  //.   - a Left whose value is the result of applying the first function\n  //.     to this Left's value if `this` is a Left; otherwise\n  //.\n  //.   - a Right whose value is the result of applying the second function\n  //.     to this Right's value.\n  //.\n  //. Similar to [`Either#fantasy-land/map`][], but supports mapping over the\n  //. left side as well as the right side.\n  //.\n  //. It is idiomatic to use [`bimap`](#bimap) rather than use this method\n  //. directly.\n  //.\n  //. ```javascript\n  //. > S.bimap(S.toUpper, S.add(1), S.Left('abc'))\n  //. Left('ABC')\n  //.\n  //. > S.bimap(S.toUpper, S.add(1), S.Right(42))\n  //. Right(43)\n  //. ```\n  Either.prototype['fantasy-land/bimap'] = function(f, g) {\n    return this.isLeft ? Left(f(this.value)) : Right(g(this.value));\n  };\n\n  //# Either#fantasy-land/ap :: Either a b ~> Either a (b -> c) -> Either a c\n  //.\n  //. Takes an Either and returns a Left unless `this` is a Right *and* the\n  //. argument is a Right, in which case it returns a Right whose value is\n  //. the result of applying the given Right's value to this Right's value.\n  //.\n  //. It is idiomatic to use [`ap`](#ap) rather than use this method directly.\n  //.\n  //. ```javascript\n  //. > S.ap(S.Left('No such function'), S.Left('Cannot divide by zero'))\n  //. Left('No such function')\n  //.\n  //. > S.ap(S.Left('No such function'), S.Right(9))\n  //. Left('No such function')\n  //.\n  //. > S.ap(S.Right(Math.sqrt), S.Left('Cannot divide by zero'))\n  //. Left('Cannot divide by zero')\n  //.\n  //. > S.ap(S.Right(Math.sqrt), S.Right(9))\n  //. Right(3)\n  //. ```\n  Either.prototype['fantasy-land/ap'] = function(other) {\n    return other.isRight ? Z.map(other.value, this) : other;\n  };\n\n  //# Either#fantasy-land/chain :: Either a b ~> (b -> Either a c) -> Either a c\n  //.\n  //. Takes a function and returns `this` if `this` is a Left; otherwise\n  //. it returns the result of applying the function to this Right's value.\n  //.\n  //. It is idiomatic to use [`chain`](#chain) rather than use this method\n  //. directly.\n  //.\n  //. ```javascript\n  //. > global.sqrt = n =>\n  //. .   n < 0 ? S.Left('Cannot represent square root of negative number')\n  //. .         : S.Right(Math.sqrt(n))\n  //. sqrt\n  //.\n  //. > S.chain(sqrt, S.Left('Cannot divide by zero'))\n  //. Left('Cannot divide by zero')\n  //.\n  //. > S.chain(sqrt, S.Right(-1))\n  //. Left('Cannot represent square root of negative number')\n  //.\n  //. > S.chain(sqrt, S.Right(25))\n  //. Right(5)\n  //. ```\n  Either.prototype['fantasy-land/chain'] = function(f) {\n    return this.isRight ? f(this.value) : this;\n  };\n\n  //# Either#fantasy-land/alt :: Either a b ~> Either a b -> Either a b\n  //.\n  //. Chooses between `this` and the other Either provided as an argument.\n  //. Returns `this` if `this` is a Right; the other Either otherwise.\n  //.\n  //. It is idiomatic to use [`alt`](#alt) rather than use this method\n  //. directly.\n  //.\n  //. ```javascript\n  //. > S.alt(S.Left('A'), S.Left('B'))\n  //. Left('B')\n  //.\n  //. > S.alt(S.Left('C'), S.Right(1))\n  //. Right(1)\n  //.\n  //. > S.alt(S.Right(2), S.Left('D'))\n  //. Right(2)\n  //.\n  //. > S.alt(S.Right(3), S.Right(4))\n  //. Right(3)\n  //. ```\n  Either.prototype['fantasy-land/alt'] = function(other) {\n    return this.isRight ? this : other;\n  };\n\n  //# Either#fantasy-land/reduce :: Either a b ~> ((c, b) -> c, c) -> c\n  //.\n  //. Takes a function and an initial value of any type, and returns:\n  //.\n  //.   - the initial value if `this` is a Left; otherwise\n  //.\n  //.   - the result of applying the function to the initial value and this\n  //.     Right's value.\n  //.\n  //. It is idiomatic to use [`reduce`](#reduce) rather than use this method\n  //. directly.\n  //.\n  //. ```javascript\n  //. > S.reduce(S.curry2(Math.pow), 10, S.Left('Cannot divide by zero'))\n  //. 10\n  //.\n  //. > S.reduce(S.curry2(Math.pow), 10, S.Right(3))\n  //. 1000\n  //. ```\n  Either.prototype['fantasy-land/reduce'] = function(f, x) {\n    return this.isRight ? f(x, this.value) : x;\n  };\n\n  //# Either#fantasy-land/traverse :: Applicative f => Either a b ~> (TypeRep f, b -> f c) -> f (Either a c)\n  //.\n  //. Takes the type representative of some [Applicative][] and a function\n  //. which returns a value of that Applicative, and returns:\n  //.\n  //.   - the result of applying the type representative's [`of`][] function to\n  //.     `this` if `this` is a Left; otherwise\n  //.\n  //.   - the result of mapping [`Right`](#Right) over the result of applying\n  //.     the first function to this Right's value.\n  //.\n  //. It is idiomatic to use [`traverse`](#traverse) rather than use this\n  //. method directly.\n  //.\n  //. ```javascript\n  //. > S.traverse(Array, S.words, S.Left('Request failed'))\n  //. [Left('Request failed')]\n  //.\n  //. > S.traverse(Array, S.words, S.Right('foo bar baz'))\n  //. [Right('foo'), Right('bar'), Right('baz')]\n  //. ```\n  Either.prototype['fantasy-land/traverse'] = function(typeRep, f) {\n    return this.isRight ? Z.map(Right, f(this.value)) : Z.of(typeRep, this);\n  };\n\n  //# Either#fantasy-land/extend :: Either a b ~> (Either a b -> c) -> Either a c\n  //.\n  //. Takes a function and returns `this` if `this` is a Left; otherwise it\n  //. returns a Right whose value is the result of applying the function to\n  //. `this`.\n  //.\n  //. It is idiomatic to use [`extend`](#extend) rather than use this method\n  //. directly.\n  //.\n  //. ```javascript\n  //. > S.extend(x => x.value + 1, S.Left('Cannot divide by zero'))\n  //. Left('Cannot divide by zero')\n  //.\n  //. > S.extend(x => x.value + 1, S.Right(42))\n  //. Right(43)\n  //. ```\n  Either.prototype['fantasy-land/extend'] = function(f) {\n    return this.isLeft ? this : Right(f(this));\n  };\n\n  //# isLeft :: Either a b -> Boolean\n  //.\n  //. Returns `true` if the given Either is a Left; `false` if it is a Right.\n  //.\n  //. ```javascript\n  //. > S.isLeft(S.Left('Cannot divide by zero'))\n  //. true\n  //.\n  //. > S.isLeft(S.Right(42))\n  //. false\n  //. ```\n  function isLeft(either) {\n    return either.isLeft;\n  }\n  S.isLeft = def('isLeft', {}, [$Either(a, b), $.Boolean], isLeft);\n\n  //# isRight :: Either a b -> Boolean\n  //.\n  //. Returns `true` if the given Either is a Right; `false` if it is a Left.\n  //.\n  //. ```javascript\n  //. > S.isRight(S.Right(42))\n  //. true\n  //.\n  //. > S.isRight(S.Left('Cannot divide by zero'))\n  //. false\n  //. ```\n  function isRight(either) {\n    return either.isRight;\n  }\n  S.isRight = def('isRight', {}, [$Either(a, b), $.Boolean], isRight);\n\n  //# fromEither :: b -> Either a b -> b\n  //.\n  //. Takes a default value and an Either, and returns the Right value\n  //. if the Either is a Right; the default value otherwise.\n  //.\n  //. ```javascript\n  //. > S.fromEither(0, S.Right(42))\n  //. 42\n  //.\n  //. > S.fromEither(0, S.Left(42))\n  //. 0\n  //. ```\n  function fromEither(x, either) {\n    return either.isRight ? either.value : x;\n  }\n  S.fromEither = def('fromEither', {}, [b, $Either(a, b), b], fromEither);\n\n  //# toEither :: a -> b? -> Either a b\n  //.\n  //. Converts an arbitrary value to an Either: a Left if the value is `null`\n  //. or `undefined`; a Right otherwise. The first argument specifies the\n  //. value of the Left in the \"failure\" case.\n  //.\n  //. ```javascript\n  //. > S.toEither('XYZ', null)\n  //. Left('XYZ')\n  //.\n  //. > S.toEither('XYZ', 'ABC')\n  //. Right('ABC')\n  //.\n  //. > S.map(S.prop('0'), S.toEither('Invalid protocol', 'ftp://example.com/'.match(/^https?:/)))\n  //. Left('Invalid protocol')\n  //.\n  //. > S.map(S.prop('0'), S.toEither('Invalid protocol', 'https://example.com/'.match(/^https?:/)))\n  //. Right('https:')\n  //. ```\n  function toEither(x, y) {\n    return y == null ? Left(x) : Right(y);\n  }\n  S.toEither = def('toEither', {}, [a, b, $Either(a, b)], toEither);\n\n  //# either :: (a -> c) -> (b -> c) -> Either a b -> c\n  //.\n  //. Takes two functions and an Either, and returns the result of\n  //. applying the first function to the Left's value, if the Either\n  //. is a Left, or the result of applying the second function to the\n  //. Right's value, if the Either is a Right.\n  //.\n  //. ```javascript\n  //. > S.either(S.toUpper, S.toString, S.Left('Cannot divide by zero'))\n  //. 'CANNOT DIVIDE BY ZERO'\n  //.\n  //. > S.either(S.toUpper, S.toString, S.Right(42))\n  //. '42'\n  //. ```\n  function either(l, r, either) {\n    return either.isLeft ? l(either.value) : r(either.value);\n  }\n  S.either = def('either', {}, [Fn(a, c), Fn(b, c), $Either(a, b), c], either);\n\n  //# lefts :: Array (Either a b) -> Array a\n  //.\n  //. Takes an array of Eithers and returns an array containing each Left's\n  //. value.\n  //.\n  //. See also [`rights`](#rights).\n  //.\n  //. ```javascript\n  //. > S.lefts([S.Right(20), S.Left('foo'), S.Right(10), S.Left('bar')])\n  //. ['foo', 'bar']\n  //. ```\n  function lefts(eithers) {\n    return Z.reduce(function(xs, either) {\n      if (either.isLeft) xs.push(either.value);\n      return xs;\n    }, [], eithers);\n  }\n  S.lefts = def('lefts', {}, [$.Array($Either(a, b)), $.Array(a)], lefts);\n\n  //# rights :: Array (Either a b) -> Array b\n  //.\n  //. Takes an array of Eithers and returns an array containing each Right's\n  //. value.\n  //.\n  //. See also [`lefts`](#lefts).\n  //.\n  //. ```javascript\n  //. > S.rights([S.Right(20), S.Left('foo'), S.Right(10), S.Left('bar')])\n  //. [20, 10]\n  //. ```\n  function rights(eithers) {\n    return Z.reduce(function(xs, either) {\n      if (either.isRight) xs.push(either.value);\n      return xs;\n    }, [], eithers);\n  }\n  S.rights = def('rights', {}, [$.Array($Either(a, b)), $.Array(b)], rights);\n\n  //# tagBy :: (a -> Boolean) -> a -> Either a a\n  //.\n  //. Takes a predicate and a value, and returns a Right of the value if it\n  //. satisfies the predicate; a Left of the value otherwise.\n  //.\n  //. ```javascript\n  //. > S.tagBy(S.odd, 0)\n  //. Left(0)\n  //\n  //. > S.tagBy(S.odd, 1)\n  //. Right(1)\n  //. ```\n  function tagBy(pred, a) {\n    return pred(a) ? Right(a) : Left(a);\n  }\n  S.tagBy = def('tagBy', {}, [$.Predicate(a), a, $Either(a, a)], tagBy);\n\n  //# encaseEither :: (Error -> l) -> (a -> r) -> a -> Either l r\n  //.\n  //. Takes two unary functions, `f` and `g`, the second of which may throw,\n  //. and a value `x` of any type. Applies `g` to `x` inside a `try` block.\n  //. If an exception is caught, the return value is a Left containing the\n  //. result of applying `f` to the caught Error object; otherwise the return\n  //. value is a Right containing the result of applying `g` to `x`.\n  //.\n  //. See also [`encase`](#encase).\n  //.\n  //. ```javascript\n  //. > S.encaseEither(S.I, JSON.parse, '[\"foo\",\"bar\",\"baz\"]')\n  //. Right(['foo', 'bar', 'baz'])\n  //.\n  //. > S.encaseEither(S.I, JSON.parse, '[')\n  //. Left(new SyntaxError('Unexpected end of JSON input'))\n  //.\n  //. > S.encaseEither(S.prop('message'), JSON.parse, '[')\n  //. Left('Unexpected end of JSON input')\n  //. ```\n  function encaseEither(f, g, x) {\n    try {\n      return Right(g(x));\n    } catch (err) {\n      return Left(f(err));\n    }\n  }\n  S.encaseEither =\n  def('encaseEither',\n      {},\n      [Fn($.Error, l), Fn(a, r), a, $Either(l, r)],\n      encaseEither);\n\n  //# encaseEither2 :: (Error -> l) -> (a -> b -> r) -> a -> b -> Either l r\n  //.\n  //. Binary version of [`encaseEither`](#encaseEither).\n  function encaseEither2(f, g, x, y) {\n    try {\n      return Right(g(x)(y));\n    } catch (err) {\n      return Left(f(err));\n    }\n  }\n  S.encaseEither2 =\n  def('encaseEither2',\n      {},\n      [Fn($.Error, l), Fn(a, Fn(b, r)), a, b, $Either(l, r)],\n      encaseEither2);\n\n  //# encaseEither3 :: (Error -> l) -> (a -> b -> c -> r) -> a -> b -> c -> Either l r\n  //.\n  //. Ternary version of [`encaseEither`](#encaseEither).\n  function encaseEither3(f, g, x, y, z) {\n    try {\n      return Right(g(x)(y)(z));\n    } catch (err) {\n      return Left(f(err));\n    }\n  }\n  S.encaseEither3 =\n  def('encaseEither3',\n      {},\n      [Fn($.Error, l), Fn(a, Fn(b, Fn(c, r))), a, b, c, $Either(l, r)],\n      encaseEither3);\n\n  //# eitherToMaybe :: Either a b -> Maybe b\n  //.\n  //. Converts an Either to a Maybe. A Left becomes Nothing; a Right becomes\n  //. a Just.\n  //.\n  //. See also [`maybeToEither`](#maybeToEither).\n  //.\n  //. ```javascript\n  //. > S.eitherToMaybe(S.Left('Cannot divide by zero'))\n  //. Nothing\n  //.\n  //. > S.eitherToMaybe(S.Right(42))\n  //. Just(42)\n  //. ```\n  function eitherToMaybe(either) {\n    return either.isLeft ? Nothing : Just(either.value);\n  }\n  S.eitherToMaybe =\n  def('eitherToMaybe', {}, [$Either(a, b), $Maybe(b)], eitherToMaybe);\n\n  //. ### Logic\n\n  //# and :: Boolean -> Boolean -> Boolean\n  //.\n  //. Boolean \"and\".\n  //.\n  //. ```javascript\n  //. > S.and(false, false)\n  //. false\n  //.\n  //. > S.and(false, true)\n  //. false\n  //.\n  //. > S.and(true, false)\n  //. false\n  //.\n  //. > S.and(true, true)\n  //. true\n  //. ```\n  function and(x, y) {\n    return x.valueOf() && y.valueOf();\n  }\n  S.and = def('and', {}, [$.Boolean, $.Boolean, $.Boolean], and);\n\n  //# or :: Boolean -> Boolean -> Boolean\n  //.\n  //. Boolean \"or\".\n  //.\n  //. ```javascript\n  //. > S.or(false, false)\n  //. false\n  //.\n  //. > S.or(false, true)\n  //. true\n  //.\n  //. > S.or(true, false)\n  //. true\n  //.\n  //. > S.or(true, true)\n  //. true\n  //. ```\n  function or(x, y) {\n    return x.valueOf() || y.valueOf();\n  }\n  S.or = def('or', {}, [$.Boolean, $.Boolean, $.Boolean], or);\n\n  //# not :: Boolean -> Boolean\n  //.\n  //. Boolean \"not\".\n  //.\n  //. See also [`complement`](#complement).\n  //.\n  //. ```javascript\n  //. > S.not(false)\n  //. true\n  //.\n  //. > S.not(true)\n  //. false\n  //. ```\n  function not(x) {\n    return !x.valueOf();\n  }\n  S.not = def('not', {}, [$.Boolean, $.Boolean], not);\n\n  //# complement :: (a -> Boolean) -> a -> Boolean\n  //.\n  //. Takes a unary predicate and a value of any type, and returns the logical\n  //. negation of applying the predicate to the value.\n  //.\n  //. See also [`not`](#not).\n  //.\n  //. ```javascript\n  //. > Number.isInteger(42)\n  //. true\n  //.\n  //. > S.complement(Number.isInteger, 42)\n  //. false\n  //. ```\n  function complement(pred, x) {\n    return !pred(x);\n  }\n  S.complement =\n  def('complement', {}, [$.Predicate(a), a, $.Boolean], complement);\n\n  //# ifElse :: (a -> Boolean) -> (a -> b) -> (a -> b) -> a -> b\n  //.\n  //. Takes a unary predicate, a unary \"if\" function, a unary \"else\"\n  //. function, and a value of any type, and returns the result of\n  //. applying the \"if\" function to the value if the value satisfies\n  //. the predicate; the result of applying the \"else\" function to the\n  //. value otherwise.\n  //.\n  //. See also [`when`](#when) and [`unless`](#unless).\n  //.\n  //. ```javascript\n  //. > S.ifElse(x => x < 0, Math.abs, Math.sqrt, -1)\n  //. 1\n  //.\n  //. > S.ifElse(x => x < 0, Math.abs, Math.sqrt, 16)\n  //. 4\n  //. ```\n  function ifElse(pred, f, g, x) {\n    return pred(x) ? f(x) : g(x);\n  }\n  S.ifElse =\n  def('ifElse', {}, [$.Predicate(a), Fn(a, b), Fn(a, b), a, b], ifElse);\n\n  //# when :: (a -> Boolean) -> (a -> a) -> a -> a\n  //.\n  //. Takes a unary predicate, a unary function, and a value of any type, and\n  //. returns the result of applying the function to the value if the value\n  //. satisfies the predicate; the value otherwise.\n  //.\n  //. See also [`unless`](#unless) and [`ifElse`](#ifElse).\n  //.\n  //. ```javascript\n  //. > S.when(x => x >= 0, Math.sqrt, 16)\n  //. 4\n  //.\n  //. > S.when(x => x >= 0, Math.sqrt, -1)\n  //. -1\n  //. ```\n  function when(pred, f, x) {\n    return ifElse(pred, f, I, x);\n  }\n  S.when = def('when', {}, [$.Predicate(a), Fn(a, a), a, a], when);\n\n  //# unless :: (a -> Boolean) -> (a -> a) -> a -> a\n  //.\n  //. Takes a unary predicate, a unary function, and a value of any type, and\n  //. returns the result of applying the function to the value if the value\n  //. does not satisfy the predicate; the value otherwise.\n  //.\n  //. See also [`when`](#when) and [`ifElse`](#ifElse).\n  //.\n  //. ```javascript\n  //. > S.unless(x => x < 0, Math.sqrt, 16)\n  //. 4\n  //.\n  //. > S.unless(x => x < 0, Math.sqrt, -1)\n  //. -1\n  //. ```\n  function unless(pred, f, x) {\n    return ifElse(pred, I, f, x);\n  }\n  S.unless = def('unless', {}, [$.Predicate(a), Fn(a, a), a, a], unless);\n\n  //# allPass :: Foldable f => f (a -> Boolean) -> a -> Boolean\n  //.\n  //. Takes a structure containing zero or more predicates, and a value\n  //. of any type. Returns `true` [iff][] the value satisfies all of the\n  //. predicates. None of the subsequent predicates will be applied after\n  //. the first predicate not satisfied.\n  //.\n  //. ```javascript\n  //. > S.allPass([S.test(/q/), S.test(/u/), S.test(/i/)], 'quiessence')\n  //. true\n  //.\n  //. > S.allPass([S.test(/q/), S.test(/u/), S.test(/i/)], 'fissiparous')\n  //. false\n  //. ```\n  function allPass(preds, x) {\n    return Z.reduce(function(b, p) { return b && p(x); }, true, preds);\n  }\n  S.allPass =\n  def('allPass',\n      {f: [Z.Foldable]},\n      [f($.Predicate(a)), a, $.Boolean],\n      allPass);\n\n  //# anyPass :: Foldable f => f (a -> Boolean) -> a -> Boolean\n  //.\n  //. Takes a structure containing zero or more predicates, and a value\n  //. of any type. Returns `true` [iff][] the value satisfies any of the\n  //. predicates. None of the subsequent predicates will be applied after\n  //. the first predicate satisfied.\n  //.\n  //. ```javascript\n  //. > S.anyPass([S.test(/q/), S.test(/u/), S.test(/i/)], 'incandescent')\n  //. true\n  //.\n  //. > S.anyPass([S.test(/q/), S.test(/u/), S.test(/i/)], 'empathy')\n  //. false\n  //. ```\n  function anyPass(preds, x) {\n    return Z.reduce(function(b, p) { return b || p(x); }, false, preds);\n  }\n  S.anyPass =\n  def('anyPass',\n      {f: [Z.Foldable]},\n      [f($.Predicate(a)), a, $.Boolean],\n      anyPass);\n\n  //. ### List\n  //.\n  //. The List type constructor enables type signatures to describe ad hoc\n  //. polymorphic functions which operate on either [`Array`][$.Array] or\n  //. [`String`][$.String] values.\n  //.\n  //. Mental gymnastics are required to treat arrays and strings similarly.\n  //. `[1, 2, 3]` is a list containing `1`, `2`, and `3`. `'abc'` is a list\n  //. containing `'a'`, `'b'`, and `'c'`. But what is the type of `'a'`?\n  //. `String`, since JavaScript has no Char type! Thus:\n  //.\n  //.     'abc' :: String, List String, List (List String), ...\n  //.\n  //. Every member of `String` is also a member of `List String`!\n\n  //# slice :: Integer -> Integer -> List a -> Maybe (List a)\n  //.\n  //. Returns Just a list containing the elements from the supplied list\n  //. from a beginning index (inclusive) to an end index (exclusive).\n  //. Returns Nothing unless the start interval is less than or equal to\n  //. the end interval, and the list contains both (half-open) intervals.\n  //. Accepts negative indices, which indicate an offset from the end of\n  //. the list.\n  //.\n  //. See also [`take`](#take), [`drop`](#drop), [`takeLast`](#takeLast),\n  //. and [`dropLast`](#dropLast).\n  //.\n  //. ```javascript\n  //. > S.slice(1, 3, ['a', 'b', 'c', 'd', 'e'])\n  //. Just(['b', 'c'])\n  //.\n  //. > S.slice(-3, -1, ['a', 'b', 'c', 'd', 'e'])\n  //. Just(['c', 'd'])\n  //.\n  //. > S.slice(1, 6, ['a', 'b', 'c', 'd', 'e'])\n  //. Nothing\n  //.\n  //. > S.slice(2, 6, 'banana')\n  //. Just('nana')\n  //. ```\n  function slice(start, end, xs) {\n    var len = xs.length;\n    var fromIdx = start < 0 ? start + len : start;\n    var toIdx = end < 0 ? end + len : end;\n\n    return Math.abs(start) <= len && Math.abs(end) <= len && fromIdx <= toIdx ?\n      Just(xs.slice(fromIdx, toIdx)) :\n      Nothing;\n  }\n  S.slice =\n  def('slice', {}, [$.Integer, $.Integer, List(a), $Maybe(List(a))], slice);\n\n  //# at :: Integer -> List a -> Maybe a\n  //.\n  //. Takes an index and a list and returns Just the element of the list at\n  //. the index if the index is within the list's bounds; Nothing otherwise.\n  //. A negative index represents an offset from the length of the list.\n  //.\n  //. ```javascript\n  //. > S.at(2, ['a', 'b', 'c', 'd', 'e'])\n  //. Just('c')\n  //.\n  //. > S.at(5, ['a', 'b', 'c', 'd', 'e'])\n  //. Nothing\n  //.\n  //. > S.at(-2, ['a', 'b', 'c', 'd', 'e'])\n  //. Just('d')\n  //. ```\n  function at(n, xs) {\n    var idx = n < 0 ? xs.length + n : n;\n    return idx < 0 || idx >= xs.length ? Nothing : Just(xs[idx]);\n  }\n  S.at = def('at', {}, [$.Integer, List(a), $Maybe(a)], at);\n\n  //# head :: List a -> Maybe a\n  //.\n  //. Takes a list and returns Just the first element of the list if the\n  //. list contains at least one element; Nothing if the list is empty.\n  //.\n  //. ```javascript\n  //. > S.head([1, 2, 3])\n  //. Just(1)\n  //.\n  //. > S.head([])\n  //. Nothing\n  //. ```\n  function head(xs) {\n    return at(0, xs);\n  }\n  S.head = def('head', {}, [List(a), $Maybe(a)], head);\n\n  //# last :: List a -> Maybe a\n  //.\n  //. Takes a list and returns Just the last element of the list if the\n  //. list contains at least one element; Nothing if the list is empty.\n  //.\n  //. ```javascript\n  //. > S.last([1, 2, 3])\n  //. Just(3)\n  //.\n  //. > S.last([])\n  //. Nothing\n  //. ```\n  function last(xs) {\n    return at(-1, xs);\n  }\n  S.last = def('last', {}, [List(a), $Maybe(a)], last);\n\n  //# tail :: List a -> Maybe (List a)\n  //.\n  //. Takes a list and returns Just a list containing all but the first\n  //. of the list's elements if the list contains at least one element;\n  //. Nothing if the list is empty.\n  //.\n  //. ```javascript\n  //. > S.tail([1, 2, 3])\n  //. Just([2, 3])\n  //.\n  //. > S.tail([])\n  //. Nothing\n  //. ```\n  function tail(xs) {\n    return xs.length > 0 ? Just(xs.slice(1)) : Nothing;\n  }\n  S.tail = def('tail', {}, [List(a), $Maybe(List(a))], tail);\n\n  //# init :: List a -> Maybe (List a)\n  //.\n  //. Takes a list and returns Just a list containing all but the last\n  //. of the list's elements if the list contains at least one element;\n  //. Nothing if the list is empty.\n  //.\n  //. ```javascript\n  //. > S.init([1, 2, 3])\n  //. Just([1, 2])\n  //.\n  //. > S.init([])\n  //. Nothing\n  //. ```\n  function init(xs) {\n    return xs.length > 0 ? Just(xs.slice(0, -1)) : Nothing;\n  }\n  S.init = def('init', {}, [List(a), $Maybe(List(a))], init);\n\n  //# take :: Integer -> List a -> Maybe (List a)\n  //.\n  //. Returns Just the first N elements of the given collection if N is\n  //. greater than or equal to zero and less than or equal to the length\n  //. of the collection; Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.take(2, ['a', 'b', 'c', 'd', 'e'])\n  //. Just(['a', 'b'])\n  //.\n  //. > S.take(4, 'abcdefg')\n  //. Just('abcd')\n  //.\n  //. > S.take(4, ['a', 'b', 'c'])\n  //. Nothing\n  //. ```\n  function take(n, xs) {\n    return n < 0 || n > xs.length ? Nothing : Just(xs.slice(0, n));\n  }\n  S.take = def('take', {}, [$.Integer, List(a), $Maybe(List(a))], take);\n\n  //# takeLast :: Integer -> List a -> Maybe (List a)\n  //.\n  //. Returns Just the last N elements of the given collection if N is\n  //. greater than or equal to zero and less than or equal to the length\n  //. of the collection; Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.takeLast(2, ['a', 'b', 'c', 'd', 'e'])\n  //. Just(['d', 'e'])\n  //.\n  //. > S.takeLast(4, 'abcdefg')\n  //. Just('defg')\n  //.\n  //. > S.takeLast(4, ['a', 'b', 'c'])\n  //. Nothing\n  //. ```\n  function takeLast(n, xs) {\n    return n < 0 || n > xs.length ? Nothing : Just(xs.slice(xs.length - n));\n  }\n  S.takeLast =\n  def('takeLast', {}, [$.Integer, List(a), $Maybe(List(a))], takeLast);\n\n  //# drop :: Integer -> List a -> Maybe (List a)\n  //.\n  //. Returns Just all but the first N elements of the given collection\n  //. if N is greater than or equal to zero and less than or equal to the\n  //. length of the collection; Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.drop(2, ['a', 'b', 'c', 'd', 'e'])\n  //. Just(['c', 'd', 'e'])\n  //.\n  //. > S.drop(4, 'abcdefg')\n  //. Just('efg')\n  //.\n  //. > S.drop(4, 'abc')\n  //. Nothing\n  //. ```\n  function drop(n, xs) {\n    return n < 0 || n > xs.length ? Nothing : Just(xs.slice(n));\n  }\n  S.drop = def('drop', {}, [$.Integer, List(a), $Maybe(List(a))], drop);\n\n  //# dropLast :: Integer -> List a -> Maybe (List a)\n  //.\n  //. Returns Just all but the last N elements of the given collection\n  //. if N is greater than or equal to zero and less than or equal to the\n  //. length of the collection; Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.dropLast(2, ['a', 'b', 'c', 'd', 'e'])\n  //. Just(['a', 'b', 'c'])\n  //.\n  //. > S.dropLast(4, 'abcdefg')\n  //. Just('abc')\n  //.\n  //. > S.dropLast(4, 'abc')\n  //. Nothing\n  //. ```\n  function dropLast(n, xs) {\n    return n < 0 || n > xs.length ? Nothing : Just(xs.slice(0, xs.length - n));\n  }\n  S.dropLast =\n  def('dropLast', {}, [$.Integer, List(a), $Maybe(List(a))], dropLast);\n\n  //. ### Array\n\n  //# size :: Foldable f => f a -> Integer\n  //.\n  //. Returns the number of elements of the given structure.\n  //.\n  //. ```javascript\n  //. > S.size([])\n  //. 0\n  //.\n  //. > S.size(['foo', 'bar', 'baz'])\n  //. 3\n  //.\n  //. > S.size(Nil)\n  //. 0\n  //.\n  //. > S.size(Cons('foo', Cons('bar', Cons('baz', Nil))))\n  //. 3\n  //.\n  //. > S.size(S.Nothing)\n  //. 0\n  //.\n  //. > S.size(S.Just('quux'))\n  //. 1\n  //. ```\n  S.size = def('size', {f: [Z.Foldable]}, [f(a), $.Integer], Z.size);\n\n  //# append :: (Applicative f, Semigroup (f a)) => a -> f a -> f a\n  //.\n  //. Returns the result of appending the first argument to the second.\n  //.\n  //. See also [`prepend`](#prepend).\n  //.\n  //. ```javascript\n  //. > S.append(3, [1, 2])\n  //. [1, 2, 3]\n  //.\n  //. > S.append(3, Cons(1, Cons(2, Nil)))\n  //. Cons(1, Cons(2, Cons(3, Nil)))\n  //.\n  //. > S.append([1], S.Nothing)\n  //. Just([1])\n  //.\n  //. > S.append([3], S.Just([1, 2]))\n  //. Just([1, 2, 3])\n  //. ```\n  S.append =\n  def('append',\n      {f: [Z.Applicative, Z.Semigroup]},\n      [a, f(a), f(a)],\n      Z.append);\n\n  //# prepend :: (Applicative f, Semigroup (f a)) => a -> f a -> f a\n  //.\n  //. Returns the result of prepending the first argument to the second.\n  //.\n  //. See also [`append`](#append).\n  //.\n  //. ```javascript\n  //. > S.prepend(1, [2, 3])\n  //. [1, 2, 3]\n  //.\n  //. > S.prepend(1, Cons(2, Cons(3, Nil)))\n  //. Cons(1, Cons(2, Cons(3, Nil)))\n  //.\n  //. > S.prepend([1], S.Nothing)\n  //. Just([1])\n  //.\n  //. > S.prepend([1], S.Just([2, 3]))\n  //. Just([1, 2, 3])\n  //. ```\n  S.prepend =\n  def('prepend',\n      {f: [Z.Applicative, Z.Semigroup]},\n      [a, f(a), f(a)],\n      Z.prepend);\n\n  //# joinWith :: String -> Array String -> String\n  //.\n  //. Joins the strings of the second argument separated by the first argument.\n  //.\n  //. Properties:\n  //.\n  //.   - `forall s :: String, t :: String. S.joinWith(s, S.splitOn(s, t)) = t`\n  //.\n  //. See also [`splitOn`](#splitOn).\n  //.\n  //. ```javascript\n  //. > S.joinWith(':', ['foo', 'bar', 'baz'])\n  //. 'foo:bar:baz'\n  //. ```\n  function joinWith(separator, ss) {\n    return ss.join(separator);\n  }\n  S.joinWith =\n  def('joinWith', {}, [$.String, $.Array($.String), $.String], joinWith);\n\n  //# elem :: (Setoid a, Foldable f) => a -> f a -> Boolean\n  //.\n  //. Takes a value and a structure and returns `true` [iff][] the value is an\n  //. element of the structure.\n  //.\n  //. See also [`find`](#find).\n  //.\n  //. ```javascript\n  //. > S.elem('c', ['a', 'b', 'c'])\n  //. true\n  //.\n  //. > S.elem('x', ['a', 'b', 'c'])\n  //. false\n  //.\n  //. > S.elem(3, {x: 1, y: 2, z: 3})\n  //. true\n  //.\n  //. > S.elem(8, {x: 1, y: 2, z: 3})\n  //. false\n  //.\n  //. > S.elem(0, S.Just(0))\n  //. true\n  //.\n  //. > S.elem(0, S.Just(1))\n  //. false\n  //.\n  //. > S.elem(0, S.Nothing)\n  //. false\n  //. ```\n  S.elem =\n  def('elem', {a: [Z.Setoid], f: [Z.Foldable]}, [a, f(a), $.Boolean], Z.elem);\n\n  //# find :: Foldable f => (a -> Boolean) -> f a -> Maybe a\n  //.\n  //. Takes a predicate and a structure and returns Just the leftmost element\n  //. of the structure which satisfies the predicate; Nothing if there is no\n  //. such element.\n  //.\n  //. See also [`elem`](#elem).\n  //.\n  //. ```javascript\n  //. > S.find(n => n < 0, [1, -2, 3, -4, 5])\n  //. Just(-2)\n  //.\n  //. > S.find(n => n < 0, [1, 2, 3, 4, 5])\n  //. Nothing\n  //. ```\n  function find(pred, xs) {\n    return Z.reduce(\n      function(m, x) { return m.isJust ? m : pred(x) ? Just(x) : Nothing; },\n      Nothing,\n      xs\n    );\n  }\n  S.find =\n  def('find', {f: [Z.Foldable]}, [$.Predicate(a), f(a), $Maybe(a)], find);\n\n  //# pluck :: Functor f => String -> f a -> f b\n  //.\n  //. Combines [`map`](#map) and [`prop`](#prop). `pluck(k, xs)` is equivalent\n  //. to `map(prop(k), xs)`.\n  //.\n  //. ```javascript\n  //. > S.pluck('x', [{x: 1}, {x: 2}, {x: 3}])\n  //. [1, 2, 3]\n  //.\n  //. > S.pluck('x', S.Just({x: 1, y: 2, z: 3}))\n  //. Just(1)\n  //. ```\n  function pluck(key, xs) {\n    return Z.map(function(x) {\n      var obj = toObject(x);\n      if (key in obj) return obj[key];\n      throw new TypeError('pluck expected object to have a property named ' +\n                          '' + key + '; ' + Z.toString(x) + ' does not');\n    }, xs);\n  }\n  S.pluck = def('pluck', {f: [Z.Functor]}, [$.String, f(a), f(b)], pluck);\n\n  //# unfoldr :: (b -> Maybe (Pair a b)) -> b -> Array a\n  //.\n  //. Takes a function and a seed value, and returns an array generated by\n  //. applying the function repeatedly. The array is initially empty. The\n  //. function is initially applied to the seed value. Each application\n  //. of the function should result in either:\n  //.\n  //.   - Nothing, in which case the array is returned; or\n  //.\n  //.   - Just a pair, in which case the first element is appended to\n  //.     the array and the function is applied to the second element.\n  //.\n  //. ```javascript\n  //. > S.unfoldr(n => n < 5 ? S.Just([n, n + 1]) : S.Nothing, 1)\n  //. [1, 2, 3, 4]\n  //. ```\n  function unfoldr(f, x) {\n    var result = [];\n    for (var m = f(x); m.isJust; m = f(m.value[1])) result.push(m.value[0]);\n    return result;\n  }\n  S.unfoldr =\n  def('unfoldr', {}, [Fn(b, $Maybe($.Pair(a, b))), b, $.Array(a)], unfoldr);\n\n  //# range :: Integer -> Integer -> Array Integer\n  //.\n  //. Returns an array of consecutive integers starting with the first argument\n  //. and ending with the second argument minus one. Returns `[]` if the second\n  //. argument is less than or equal to the first argument.\n  //.\n  //. ```javascript\n  //. > S.range(0, 10)\n  //. [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n  //.\n  //. > S.range(-5, 0)\n  //. [-5, -4, -3, -2, -1]\n  //.\n  //. > S.range(0, -5)\n  //. []\n  //. ```\n  function range(from, to) {\n    var result = [];\n    for (var n = from; n < to; n += 1) result.push(n);\n    return result;\n  }\n  S.range =\n  def('range', {}, [$.Integer, $.Integer, $.Array($.Integer)], range);\n\n  //# groupBy :: (a -> a -> Boolean) -> Array a -> Array (Array a)\n  //.\n  //. Splits its array argument into an array of arrays of equal,\n  //. adjacent elements. Equality is determined by the function\n  //. provided as the first argument. Its behaviour can be surprising\n  //. for functions that aren't reflexive, transitive, and symmetric\n  //. (see [equivalence][] relation).\n  //.\n  //. Properties:\n  //.\n  //.   - `forall f :: a -> a -> Boolean, xs :: Array a.\n  //.      S.join(S.groupBy(f, xs)) = xs`\n  //.\n  //. ```javascript\n  //. > S.groupBy(S.equals, [1, 1, 2, 1, 1])\n  //. [[1, 1], [2], [1, 1]]\n  //.\n  //. > S.groupBy(x => y => x + y === 0, [2, -3, 3, 3, 3, 4, -4, 4])\n  //. [[2], [-3, 3, 3, 3], [4, -4], [4]]\n  //. ```\n  function groupBy(f, xs) {\n    if (xs.length === 0) return [];\n    var x0 = xs[0];         // :: a\n    var active = [x0];      // :: Array a\n    var result = [active];  // :: Array (Array a)\n    for (var idx = 1; idx < xs.length; idx += 1) {\n      var x = xs[idx];\n      if (f(x0)(x)) active.push(x); else result.push(active = [x0 = x]);\n    }\n    return result;\n  }\n  S.groupBy =\n  def('groupBy',\n      {},\n      [Fn(a, $.Predicate(a)), $.Array(a), $.Array($.Array(a))],\n      groupBy);\n\n  //# reverse :: (Applicative f, Foldable f, Monoid (f a)) => f a -> f a\n  //.\n  //. Reverses the elements of the given structure.\n  //.\n  //. ```javascript\n  //. > S.reverse([1, 2, 3])\n  //. [3, 2, 1]\n  //.\n  //. > S.reverse(Cons(1, Cons(2, Cons(3, Nil))))\n  //. Cons(3, Cons(2, Cons(1, Nil)))\n  //.\n  //. > S.pipe([S.splitOn(''), S.reverse, S.joinWith('')], 'abc')\n  //. 'cba'\n  //. ```\n  S.reverse =\n  def('reverse',\n      {f: [Z.Applicative, Z.Foldable, Z.Monoid]},\n      [f(a), f(a)],\n      Z.reverse);\n\n  //# sort :: (Ord a, Applicative m, Foldable m, Monoid (m a)) => m a -> m a\n  //.\n  //. Performs a [stable sort][] of the elements of the given structure, using\n  //. [`Z.lte`][] for comparisons.\n  //.\n  //. Properties:\n  //.\n  //.   - `S.sort(S.sort(m)) = S.sort(m)` (idempotence)\n  //.\n  //. See also [`sortBy`](#sortBy).\n  //.\n  //. ```javascript\n  //. > S.sort(['foo', 'bar', 'baz'])\n  //. ['bar', 'baz', 'foo']\n  //.\n  //. > S.sort([S.Left(4), S.Right(3), S.Left(2), S.Right(1)])\n  //. [Left(2), Left(4), Right(1), Right(3)]\n  //. ```\n  S.sort =\n  def('sort',\n      {a: [Z.Ord], m: [Z.Applicative, Z.Foldable, Z.Monoid]},\n      [m(a), m(a)],\n      Z.sort);\n\n  //# sortBy :: (Ord b, Applicative m, Foldable m, Monoid (m a)) => (a -> b) -> m a -> m a\n  //.\n  //. Performs a [stable sort][] of the elements of the given structure, using\n  //. [`Z.lte`][] to compare the values produced by applying the given function\n  //. to each element of the structure.\n  //.\n  //. Properties:\n  //.\n  //.   - `S.sortBy(f, S.sortBy(f, m)) = S.sortBy(f, m)` (idempotence)\n  //.\n  //. See also [`sort`](#sort).\n  //.\n  //. ```javascript\n  //. > S.sortBy(S.prop('rank'), [\n  //. .   {rank: 7, suit: 'spades'},\n  //. .   {rank: 5, suit: 'hearts'},\n  //. .   {rank: 2, suit: 'hearts'},\n  //. .   {rank: 5, suit: 'spades'},\n  //. . ])\n  //. [ {rank: 2, suit: 'hearts'},\n  //. . {rank: 5, suit: 'hearts'},\n  //. . {rank: 5, suit: 'spades'},\n  //. . {rank: 7, suit: 'spades'} ]\n  //.\n  //. > S.sortBy(S.prop('suit'), [\n  //. .   {rank: 7, suit: 'spades'},\n  //. .   {rank: 5, suit: 'hearts'},\n  //. .   {rank: 2, suit: 'hearts'},\n  //. .   {rank: 5, suit: 'spades'},\n  //. . ])\n  //. [ {rank: 5, suit: 'hearts'},\n  //. . {rank: 2, suit: 'hearts'},\n  //. . {rank: 7, suit: 'spades'},\n  //. . {rank: 5, suit: 'spades'} ]\n  //. ```\n  S.sortBy =\n  def('sortBy',\n      {b: [Z.Ord], m: [Z.Applicative, Z.Foldable, Z.Monoid]},\n      [Fn(a, b), m(a), m(a)],\n      Z.sortBy);\n\n  //. ### Object\n\n  //# prop :: String -> a -> b\n  //.\n  //. Takes a property name and an object with known properties and returns\n  //. the value of the specified property. If for some reason the object\n  //. lacks the specified property, a type error is thrown.\n  //.\n  //. For accessing properties of uncertain objects, use [`get`](#get) instead.\n  //.\n  //. See also [`pluck`](#pluck).\n  //.\n  //. ```javascript\n  //. > S.prop('a', {a: 1, b: 2})\n  //. 1\n  //. ```\n  function prop(key, x) {\n    var obj = toObject(x);\n    if (key in obj) return obj[key];\n    throw new TypeError('prop expected object to have a property named ' +\n                        key + '; ' + Z.toString(x) + ' does not');\n  }\n  S.prop = def('prop', {}, [$.String, a, b], prop);\n\n  //# props :: Array String -> a -> b\n  //.\n  //. Takes a property path (an array of property names) and an object with\n  //. known structure and returns the value at the given path. If for some\n  //. reason the path does not exist, a type error is thrown.\n  //.\n  //. For accessing property paths of uncertain objects, use [`gets`](#gets)\n  //. instead.\n  //.\n  //. ```javascript\n  //. > S.props(['a', 'b', 'c'], {a: {b: {c: 1}}})\n  //. 1\n  //. ```\n  function props(path, x) {\n    return path.reduce(function(x, key) {\n      var obj = toObject(x);\n      if (key in obj) return obj[key];\n      throw new TypeError('props expected object to have a property at ' +\n                          Z.toString(path) + '; ' +\n                          Z.toString(x) + ' does not');\n    }, x);\n  }\n  S.props = def('props', {}, [$.Array($.String), a, b], props);\n\n  //# get :: (Any -> Boolean) -> String -> a -> Maybe b\n  //.\n  //. Takes a predicate, a property name, and an object and returns Just the\n  //. value of the specified object property if it exists and the value\n  //. satisfies the given predicate; Nothing otherwise.\n  //.\n  //. See also [`gets`](#gets) and [`prop`](#prop).\n  //.\n  //. ```javascript\n  //. > S.get(S.is(Number), 'x', {x: 1, y: 2})\n  //. Just(1)\n  //.\n  //. > S.get(S.is(Number), 'x', {x: '1', y: '2'})\n  //. Nothing\n  //.\n  //. > S.get(S.is(Number), 'x', {})\n  //. Nothing\n  //.\n  //. > S.get($.test([], $.Array($.Number)), 'x', {x: [1, 2, 3]})\n  //. Just([1, 2, 3])\n  //.\n  //. > S.get($.test([], $.Array($.Number)), 'x', {x: [1, 2, 3, null]})\n  //. Nothing\n  //. ```\n  function get(pred, key, x) {\n    var obj = toObject(x);\n    if (key in obj) {\n      var val = obj[key];\n      if (pred(val)) return Just(val);\n    }\n    return Nothing;\n  }\n  S.get = def('get', {}, [$.Predicate($.Any), $.String, a, $Maybe(b)], get);\n\n  //# gets :: (Any -> Boolean) -> Array String -> a -> Maybe b\n  //.\n  //. Takes a predicate, a property path (an array of property names), and\n  //. an object and returns Just the value at the given path if such a path\n  //. exists and the value satisfies the given predicate; Nothing otherwise.\n  //.\n  //. See also [`get`](#get).\n  //.\n  //. ```javascript\n  //. > S.gets(S.is(Number), ['a', 'b', 'c'], {a: {b: {c: 42}}})\n  //. Just(42)\n  //.\n  //. > S.gets(S.is(Number), ['a', 'b', 'c'], {a: {b: {c: '42'}}})\n  //. Nothing\n  //.\n  //. > S.gets(S.is(Number), ['a', 'b', 'c'], {})\n  //. Nothing\n  //. ```\n  function gets(pred, keys, x) {\n    return Z.filter(pred, Z.reduce(function(m, key) {\n      return Z.chain(function(x) {\n        var obj = toObject(x);\n        return key in obj ? Just(obj[key]) : Nothing;\n      }, m);\n    }, Just(x), keys));\n  }\n  S.gets =\n  def('gets', {}, [$.Predicate($.Any), $.Array($.String), a, $Maybe(b)], gets);\n\n  //. ### StrMap\n  //.\n  //. StrMap is an abbreviation of _string map_. A string map is an object,\n  //. such as `{foo: 1, bar: 2, baz: 3}`, whose values are all members of\n  //. the same type. Formally, a value is a member of type `StrMap a` if its\n  //. [type identifier][] is `'Object'` and the values of its enumerable own\n  //. properties are all members of type `a`.\n\n  //# singleton :: String -> a -> StrMap a\n  //.\n  //. Takes a string and a value of any type, and returns a string map with\n  //. a single entry (mapping the key to the value).\n  //.\n  //. ```javascript\n  //. > S.singleton('foo', 42)\n  //. {foo: 42}\n  //. ```\n  function singleton(key, val) {\n    var strMap = {};\n    strMap[key] = val;\n    return strMap;\n  }\n  S.singleton = def('singleton', {}, [$.String, a, $.StrMap(a)], singleton);\n\n  //# insert :: String -> a -> StrMap a -> StrMap a\n  //.\n  //. Takes a string, a value of any type, and a string map, and returns a\n  //. string map comprising all the entries of the given string map plus the\n  //. entry specified by the first two arguments (which takes precedence).\n  //.\n  //. Equivalent to Haskell's `insert` function. Similar to Clojure's `assoc`\n  //. function.\n  //.\n  //. ```javascript\n  //. > S.insert('c', 3, {a: 1, b: 2})\n  //. {a: 1, b: 2, c: 3}\n  //.\n  //. > S.insert('a', 4, {a: 1, b: 2})\n  //. {a: 4, b: 2}\n  //. ```\n  function insert(key, val, strMap) {\n    return Z.concat(strMap, singleton(key, val));\n  }\n  S.insert =\n  def('insert', {}, [$.String, a, $.StrMap(a), $.StrMap(a)], insert);\n\n  //# remove :: String -> StrMap a -> StrMap a\n  //.\n  //. Takes a string and a string map, and returns a string map comprising all\n  //. the entries of the given string map except the one whose key matches the\n  //. given string (if such a key exists).\n  //.\n  //. Equivalent to Haskell's `delete` function. Similar to Clojure's `dissoc`\n  //. function.\n  //.\n  //. ```javascript\n  //. > S.remove('c', {a: 1, b: 2, c: 3})\n  //. {a: 1, b: 2}\n  //.\n  //. > S.remove('c', {})\n  //. {}\n  //. ```\n  function remove(key, strMap) {\n    var result = Z.concat(strMap, {});\n    delete result[key];\n    return result;\n  }\n  S.remove = def('remove', {}, [$.String, $.StrMap(a), $.StrMap(a)], remove);\n\n  //# keys :: StrMap a -> Array String\n  //.\n  //. Returns the keys of the given string map, in arbitrary order.\n  //.\n  //. ```javascript\n  //. > S.keys({b: 2, c: 3, a: 1}).sort()\n  //. ['a', 'b', 'c']\n  //. ```\n  S.keys = def('keys', {}, [$.StrMap(a), $.Array($.String)], Object.keys);\n\n  //# values :: StrMap a -> Array a\n  //.\n  //. Returns the values of the given string map, in arbitrary order.\n  //.\n  //. ```javascript\n  //. > S.values({a: 1, c: 3, b: 2}).sort()\n  //. [1, 2, 3]\n  //. ```\n  function values(strMap) {\n    return Z.map(function(k) { return strMap[k]; }, Object.keys(strMap));\n  }\n  S.values = def('values', {}, [$.StrMap(a), $.Array(a)], values);\n\n  //# pairs :: StrMap a -> Array (Pair String a)\n  //.\n  //. Returns the keyvalue pairs of the given string map, in arbitrary order.\n  //.\n  //. ```javascript\n  //. > S.pairs({b: 2, a: 1, c: 3}).sort()\n  //. [['a', 1], ['b', 2], ['c', 3]]\n  //. ```\n  function pairs(strMap) {\n    return Z.map(function(k) { return [k, strMap[k]]; }, Object.keys(strMap));\n  }\n  S.pairs =\n  def('pairs', {}, [$.StrMap(a), $.Array($.Pair($.String, a))], pairs);\n\n  //# fromPairs :: Foldable f => f (Pair String a) -> StrMap a\n  //.\n  //. Returns a string map containing the keyvalue pairs specified by the\n  //. given [Foldable][]. If a key appears in multiple pairs, the rightmost\n  //. pair takes precedence.\n  //.\n  //. ```javascript\n  //. > S.fromPairs([['a', 1], ['b', 2], ['c', 3]])\n  //. {a: 1, b: 2, c: 3}\n  //.\n  //. > S.fromPairs([['x', 1], ['x', 2]])\n  //. {x: 2}\n  //. ```\n  function fromPairs(pairs) {\n    return Z.reduce(function(strMap, pair) {\n      strMap[pair[0]] = pair[1];\n      return strMap;\n    }, {}, pairs);\n  }\n  S.fromPairs =\n  def('fromPairs',\n      {f: [Z.Foldable]},\n      [f($.Pair($.String, a)), $.StrMap(a)],\n      fromPairs);\n\n  //. ### Number\n\n  //# negate :: ValidNumber -> ValidNumber\n  //.\n  //. Negates its argument.\n  //.\n  //. ```javascript\n  //. > S.negate(12.5)\n  //. -12.5\n  //.\n  //. > S.negate(-42)\n  //. 42\n  //. ```\n  function negate(n) {\n    return -n;\n  }\n  S.negate = def('negate', {}, [$.ValidNumber, $.ValidNumber], negate);\n\n  //# add :: FiniteNumber -> FiniteNumber -> FiniteNumber\n  //.\n  //. Returns the sum of two (finite) numbers.\n  //.\n  //. ```javascript\n  //. > S.add(1, 1)\n  //. 2\n  //. ```\n  function add(x, y) {\n    return x + y;\n  }\n  S.add =\n  def('add', {}, [$.FiniteNumber, $.FiniteNumber, $.FiniteNumber], add);\n\n  //# sum :: Foldable f => f FiniteNumber -> FiniteNumber\n  //.\n  //. Returns the sum of the given array of (finite) numbers.\n  //.\n  //. ```javascript\n  //. > S.sum([1, 2, 3, 4, 5])\n  //. 15\n  //.\n  //. > S.sum([])\n  //. 0\n  //.\n  //. > S.sum(S.Just(42))\n  //. 42\n  //.\n  //. > S.sum(S.Nothing)\n  //. 0\n  //. ```\n  function sum(foldable) {\n    return Z.reduce(add, 0, foldable);\n  }\n  S.sum =\n  def('sum', {f: [Z.Foldable]}, [f($.FiniteNumber), $.FiniteNumber], sum);\n\n  //# sub :: FiniteNumber -> (FiniteNumber -> FiniteNumber)\n  //.\n  //. Takes a finite number `n` and returns the _subtract `n`_ function.\n  //.\n  //. See also [`sub_`](#sub_).\n  //.\n  //. ```javascript\n  //. > S.map(S.sub(1), [1, 2, 3])\n  //. [0, 1, 2]\n  //. ```\n  S.sub =\n  def('sub',\n      {},\n      [$.FiniteNumber, Fn($.FiniteNumber, $.FiniteNumber)],\n      flip$(sub_));\n\n  //# sub_ :: FiniteNumber -> FiniteNumber -> FiniteNumber\n  //.\n  //. Returns the difference between two (finite) numbers.\n  //.\n  //. See also [`sub`](#sub).\n  //.\n  //. ```javascript\n  //. > S.sub_(4, 2)\n  //. 2\n  //. ```\n  function sub_(x, y) {\n    return x - y;\n  }\n  S.sub_ =\n  def('sub_', {}, [$.FiniteNumber, $.FiniteNumber, $.FiniteNumber], sub_);\n\n  //# mult :: FiniteNumber -> FiniteNumber -> FiniteNumber\n  //.\n  //. Returns the product of two (finite) numbers.\n  //.\n  //. ```javascript\n  //. > S.mult(4, 2)\n  //. 8\n  //. ```\n  function mult(x, y) {\n    return x * y;\n  }\n  S.mult =\n  def('mult', {}, [$.FiniteNumber, $.FiniteNumber, $.FiniteNumber], mult);\n\n  //# product :: Foldable f => f FiniteNumber -> FiniteNumber\n  //.\n  //. Returns the product of the given array of (finite) numbers.\n  //.\n  //. ```javascript\n  //. > S.product([1, 2, 3, 4, 5])\n  //. 120\n  //.\n  //. > S.product([])\n  //. 1\n  //.\n  //. > S.product(S.Just(42))\n  //. 42\n  //.\n  //. > S.product(S.Nothing)\n  //. 1\n  //. ```\n  function product(foldable) {\n    return Z.reduce(mult, 1, foldable);\n  }\n  S.product =\n  def('product',\n      {f: [Z.Foldable]},\n      [f($.FiniteNumber), $.FiniteNumber],\n      product);\n\n  //# div :: NonZeroFiniteNumber -> (FiniteNumber -> FiniteNumber)\n  //.\n  //. Takes a non-zero finite number `n` and returns the _divide by `n`_\n  //. function.\n  //.\n  //. See also [`div_`](#div_).\n  //.\n  //. ```javascript\n  //. > S.map(S.div(2), [0, 1, 2, 3])\n  //. [0, 0.5, 1, 1.5]\n  //. ```\n  S.div =\n  def('div',\n      {},\n      [$.NonZeroFiniteNumber, Fn($.FiniteNumber, $.FiniteNumber)],\n      flip$(div_));\n\n  //# div_ :: FiniteNumber -> NonZeroFiniteNumber -> FiniteNumber\n  //.\n  //. Returns the result of dividing its first argument (a finite number) by\n  //. its second argument (a non-zero finite number).\n  //.\n  //. See also [`div`](#div).\n  //.\n  //. ```javascript\n  //. > S.div_(7, 2)\n  //. 3.5\n  //.\n  //. > S.map(S.div_(24), [1, 2, 3, 4])\n  //. [24, 12, 8, 6]\n  //. ```\n  function div_(x, y) {\n    return x / y;\n  }\n  S.div_ =\n  def('div_',\n      {},\n      [$.FiniteNumber, $.NonZeroFiniteNumber, $.FiniteNumber],\n      div_);\n\n  //# pow :: FiniteNumber -> (FiniteNumber -> FiniteNumber)\n  //.\n  //. Takes a finite number `n` and returns the _power of `n`_ function.\n  //.\n  //. See also [`pow_`](#pow_).\n  //.\n  //. ```javascript\n  //. > S.map(S.pow(2), [-3, -2, -1, 0, 1, 2, 3])\n  //. [9, 4, 1, 0, 1, 4, 9]\n  //.\n  //. > S.map(S.pow(0.5), [1, 4, 9, 16, 25])\n  //. [1, 2, 3, 4, 5]\n  //. ```\n  S.pow =\n  def('pow',\n      {},\n      [$.FiniteNumber, Fn($.FiniteNumber, $.FiniteNumber)],\n      flip$(Math.pow));\n\n  //# pow_ :: FiniteNumber -> FiniteNumber -> FiniteNumber\n  //.\n  //. Curried version of [`Math.pow`][].\n  //.\n  //. See also [`pow`](#pow).\n  //.\n  //. ```javascript\n  //. > S.map(S.pow_(10), [-3, -2, -1, 0, 1, 2, 3])\n  //. [0.001, 0.01, 0.1, 1, 10, 100, 1000]\n  //. ```\n  S.pow_ =\n  def('pow_', {}, [$.FiniteNumber, $.FiniteNumber, $.FiniteNumber], Math.pow);\n\n  //# mean :: Foldable f => f FiniteNumber -> Maybe FiniteNumber\n  //.\n  //. Returns the mean of the given array of (finite) numbers.\n  //.\n  //. ```javascript\n  //. > S.mean([1, 2, 3, 4, 5])\n  //. Just(3)\n  //.\n  //. > S.mean([])\n  //. Nothing\n  //.\n  //. > S.mean(S.Just(42))\n  //. Just(42)\n  //.\n  //. > S.mean(S.Nothing)\n  //. Nothing\n  //. ```\n  function mean(foldable) {\n    var result = Z.reduce(\n      function(acc, n) {\n        acc.total += n;\n        acc.count += 1;\n        return acc;\n      },\n      {total: 0, count: 0},\n      foldable\n    );\n    return result.count > 0 ? Just(result.total / result.count) : Nothing;\n  }\n  S.mean =\n  def('mean',\n      {f: [Z.Foldable]},\n      [f($.FiniteNumber), $Maybe($.FiniteNumber)],\n      mean);\n\n  //. ### Integer\n\n  //# even :: Integer -> Boolean\n  //.\n  //. Returns `true` if the given integer is even; `false` if it is odd.\n  //.\n  //. ```javascript\n  //. > S.even(42)\n  //. true\n  //.\n  //. > S.even(99)\n  //. false\n  //. ```\n  function even(n) {\n    return n % 2 === 0;\n  }\n  S.even = def('even', {}, [$.Integer, $.Boolean], even);\n\n  //# odd :: Integer -> Boolean\n  //.\n  //. Returns `true` if the given integer is odd; `false` if it is even.\n  //.\n  //. ```javascript\n  //. > S.odd(99)\n  //. true\n  //.\n  //. > S.odd(42)\n  //. false\n  //. ```\n  function odd(n) {\n    return n % 2 !== 0;\n  }\n  S.odd = def('odd', {}, [$.Integer, $.Boolean], odd);\n\n  //. ### Parse\n\n  //# parseDate :: String -> Maybe ValidDate\n  //.\n  //. Takes a string and returns Just the date represented by the string\n  //. if it does in fact represent a date; Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.parseDate('2011-01-19T17:40:00Z')\n  //. Just(new Date('2011-01-19T17:40:00.000Z'))\n  //.\n  //. > S.parseDate('today')\n  //. Nothing\n  //. ```\n  function parseDate(s) {\n    var date = new Date(s);\n    return isNaN(date.valueOf()) ? Nothing : Just(date);\n  }\n  S.parseDate =\n  def('parseDate', {}, [$.String, $Maybe($.ValidDate)], parseDate);\n\n  //  requiredNonCapturingGroup :: Array String -> String\n  function requiredNonCapturingGroup(xs) {\n    return '(?:' + xs.join('|') + ')';\n  }\n\n  //  optionalNonCapturingGroup :: Array String -> String\n  function optionalNonCapturingGroup(xs) {\n    return requiredNonCapturingGroup(xs) + '?';\n  }\n\n  //  validFloatRepr :: RegExp\n  var validFloatRepr = new RegExp(\n    '^' +                     // start-of-string anchor\n    '\\\\s*' +                  // any number of leading whitespace characters\n    '[+-]?' +                 // optional sign\n    requiredNonCapturingGroup([\n      'Infinity',             // \"Infinity\"\n      'NaN',                  // \"NaN\"\n      requiredNonCapturingGroup([\n        '[0-9]+',             // number\n        '[0-9]+[.][0-9]+',    // number with interior decimal point\n        '[0-9]+[.]',          // number with trailing decimal point\n        '[.][0-9]+'           // number with leading decimal point\n      ]) +\n      optionalNonCapturingGroup([\n        '[Ee]' +              // \"E\" or \"e\"\n        '[+-]?' +             // optional sign\n        '[0-9]+'              // exponent\n      ])\n    ]) +\n    '\\\\s*' +                  // any number of trailing whitespace characters\n    '$'                       // end-of-string anchor\n  );\n\n  //# parseFloat :: String -> Maybe Number\n  //.\n  //. Takes a string and returns Just the number represented by the string\n  //. if it does in fact represent a number; Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.parseFloat('-123.45')\n  //. Just(-123.45)\n  //.\n  //. > S.parseFloat('foo.bar')\n  //. Nothing\n  //. ```\n  function parseFloat_(s) {\n    return validFloatRepr.test(s) ? Just(parseFloat(s)) : Nothing;\n  }\n  S.parseFloat =\n  def('parseFloat', {}, [$.String, $Maybe($.Number)], parseFloat_);\n\n  //  Radix :: Type\n  var Radix = $.NullaryType(\n    'sanctuary/Radix',\n    '',\n    function(x) { return $.Integer._test(x) && x >= 2 && x <= 36; }\n  );\n\n  //# parseInt :: Radix -> String -> Maybe Integer\n  //.\n  //. Takes a radix (an integer between 2 and 36 inclusive) and a string,\n  //. and returns Just the number represented by the string if it does in\n  //. fact represent a number in the base specified by the radix; Nothing\n  //. otherwise.\n  //.\n  //. This function is stricter than [`parseInt`][parseInt]: a string\n  //. is considered to represent an integer only if all its non-prefix\n  //. characters are members of the character set specified by the radix.\n  //.\n  //. ```javascript\n  //. > S.parseInt(10, '-42')\n  //. Just(-42)\n  //.\n  //. > S.parseInt(16, '0xFF')\n  //. Just(255)\n  //.\n  //. > S.parseInt(16, '0xGG')\n  //. Nothing\n  //. ```\n  function parseInt_(radix, s) {\n    var charset = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'.slice(0, radix);\n    var pattern = new RegExp('^[' + charset + ']+$', 'i');\n\n    var t = s.replace(/^[+-]/, '');\n    if (pattern.test(radix === 16 ? t.replace(/^0x/i, '') : t)) {\n      var n = parseInt(s, radix);\n      if ($.Integer._test(n)) return Just(n);\n    }\n    return Nothing;\n  }\n  S.parseInt =\n  def('parseInt', {}, [Radix, $.String, $Maybe($.Integer)], parseInt_);\n\n  //# parseJson :: (Any -> Boolean) -> String -> Maybe a\n  //.\n  //. Takes a predicate and a string which may or may not be valid JSON, and\n  //. returns Just the result of applying `JSON.parse` to the string *if* the\n  //. result satisfies the predicate; Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.parseJson($.test([], $.Array($.Integer)), '[')\n  //. Nothing\n  //.\n  //. > S.parseJson($.test([], $.Array($.Integer)), '[\"1\",\"2\",\"3\"]')\n  //. Nothing\n  //.\n  //. > S.parseJson($.test([], $.Array($.Integer)), '[0,1.5,3,4.5]')\n  //. Nothing\n  //.\n  //. > S.parseJson($.test([], $.Array($.Integer)), '[1,2,3]')\n  //. Just([1, 2, 3])\n  //. ```\n  function parseJson(pred, s) {\n    return Z.filter(pred, encase(JSON.parse, s));\n  }\n  S.parseJson =\n  def('parseJson', {}, [$.Predicate($.Any), $.String, $Maybe(a)], parseJson);\n\n  //. ### RegExp\n\n  //  Match :: Type\n  var Match = $.RecordType({\n    match: $.String,\n    groups: $.Array($Maybe($.String))\n  });\n\n  //  toMatch :: Array String? -> Match\n  function toMatch(ss) {\n    return {match: ss[0], groups: ss.slice(1).map(toMaybe)};\n  }\n\n  //  withRegex :: (RegExp, () -> a) -> a\n  function withRegex(pattern, thunk) {\n    var lastIndex = pattern.lastIndex;\n    var result = thunk();\n    pattern.lastIndex = lastIndex;\n    return result;\n  }\n\n  //# regex :: RegexFlags -> String -> RegExp\n  //.\n  //. Takes a [RegexFlags][] and a pattern, and returns a RegExp.\n  //.\n  //. ```javascript\n  //. > S.regex('g', ':\\\\d+:')\n  //. /:\\d+:/g\n  //. ```\n  function regex(flags, source) {\n    return new RegExp(source, flags);\n  }\n  S.regex = def('regex', {}, [$.RegexFlags, $.String, $.RegExp], regex);\n\n  //# regexEscape :: String -> String\n  //.\n  //. Takes a string which may contain regular expression metacharacters,\n  //. and returns a string with those metacharacters escaped.\n  //.\n  //. Properties:\n  //.\n  //.   - `forall s :: String. S.test(S.regex('', S.regexEscape(s)), s) = true`\n  //.\n  //. ```javascript\n  //. > S.regexEscape('-=*{XYZ}*=-')\n  //. '\\\\-=\\\\*\\\\{XYZ\\\\}\\\\*=\\\\-'\n  //. ```\n  function regexEscape(s) {\n    return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n  }\n  S.regexEscape = def('regexEscape', {}, [$.String, $.String], regexEscape);\n\n  //# test :: RegExp -> String -> Boolean\n  //.\n  //. Takes a pattern and a string, and returns `true` [iff][] the pattern\n  //. matches the string.\n  //.\n  //. ```javascript\n  //. > S.test(/^a/, 'abacus')\n  //. true\n  //.\n  //. > S.test(/^a/, 'banana')\n  //. false\n  //. ```\n  function test(pattern, s) {\n    return withRegex(pattern, function() { return pattern.test(s); });\n  }\n  S.test = def('test', {}, [$.RegExp, $.String, $.Boolean], test);\n\n  //# match :: NonGlobalRegExp -> String -> Maybe { match :: String, groups :: Array (Maybe String) }\n  //.\n  //. Takes a pattern and a string, and returns Just a match record if the\n  //. pattern matches the string; Nothing otherwise.\n  //.\n  //. `groups :: Array (Maybe String)` acknowledges the existence of optional\n  //. capturing groups.\n  //.\n  //. Properties:\n  //.\n  //.   - `forall p :: Pattern, s :: String.\n  //.      S.head(S.matchAll(S.regex('g', p), s)) = S.match(S.regex('', p), s)`\n  //.\n  //. See also [`matchAll`](#matchAll).\n  //.\n  //. ```javascript\n  //. > S.match(/(good)?bye/, 'goodbye')\n  //. Just({match: 'goodbye', groups: [Just('good')]})\n  //.\n  //. > S.match(/(good)?bye/, 'bye')\n  //. Just({match: 'bye', groups: [Nothing]})\n  //. ```\n  function match(pattern, s) {\n    return Z.map(toMatch, toMaybe(s.match(pattern)));\n  }\n  S.match =\n  def('match', {}, [$.NonGlobalRegExp, $.String, $Maybe(Match)], match);\n\n  //# matchAll :: GlobalRegExp -> String -> Array { match :: String, groups :: Array (Maybe String) }\n  //.\n  //. Takes a pattern and a string, and returns an array of match records.\n  //.\n  //. `groups :: Array (Maybe String)` acknowledges the existence of optional\n  //. capturing groups.\n  //.\n  //. See also [`match`](#match).\n  //.\n  //. ```javascript\n  //. > S.matchAll(/@([a-z]+)/g, 'Hello, world!')\n  //. []\n  //.\n  //. > S.matchAll(/@([a-z]+)/g, 'Hello, @foo! Hello, @bar! Hello, @baz!')\n  //. [ {match: '@foo', groups: [Just('foo')]},\n  //. . {match: '@bar', groups: [Just('bar')]},\n  //. . {match: '@baz', groups: [Just('baz')]} ]\n  //. ```\n  function matchAll(pattern, s) {\n    return withRegex(pattern, function() {\n      return unfoldr(function(_) {\n        return Z.map(function(ss) {\n          return [toMatch(ss), null];\n        }, toMaybe(pattern.exec(s)));\n      }, []);\n    });\n  }\n  S.matchAll =\n  def('matchAll', {}, [$.GlobalRegExp, $.String, $.Array(Match)], matchAll);\n\n  //. ### String\n\n  //# toUpper :: String -> String\n  //.\n  //. Returns the upper-case equivalent of its argument.\n  //.\n  //. See also [`toLower`](#toLower).\n  //.\n  //. ```javascript\n  //. > S.toUpper('ABC def 123')\n  //. 'ABC DEF 123'\n  //. ```\n  function toUpper(s) {\n    return s.toUpperCase();\n  }\n  S.toUpper = def('toUpper', {}, [$.String, $.String], toUpper);\n\n  //# toLower :: String -> String\n  //.\n  //. Returns the lower-case equivalent of its argument.\n  //.\n  //. See also [`toUpper`](#toUpper).\n  //.\n  //. ```javascript\n  //. > S.toLower('ABC def 123')\n  //. 'abc def 123'\n  //. ```\n  function toLower(s) {\n    return s.toLowerCase();\n  }\n  S.toLower = def('toLower', {}, [$.String, $.String], toLower);\n\n  //# trim :: String -> String\n  //.\n  //. Strips leading and trailing whitespace characters.\n  //.\n  //. ```javascript\n  //. > S.trim('\\t\\t foo bar \\n')\n  //. 'foo bar'\n  //. ```\n  function trim(s) {\n    return s.trim();\n  }\n  S.trim = def('trim', {}, [$.String, $.String], trim);\n\n  //# stripPrefix :: String -> String -> Maybe String\n  //.\n  //. Returns Just the portion of the given string (the second argument) left\n  //. after removing the given prefix (the first argument) if the string starts\n  //. with the prefix; Nothing otherwise.\n  //.\n  //. See also [`stripSuffix`](#stripSuffix).\n  //.\n  //. ```javascript\n  //. > S.stripPrefix('https://', 'https://sanctuary.js.org')\n  //. Just('sanctuary.js.org')\n  //.\n  //. > S.stripPrefix('https://', 'http://sanctuary.js.org')\n  //. Nothing\n  //. ```\n  function stripPrefix(prefix, s) {\n    var idx = prefix.length;\n    return s.slice(0, idx) === prefix ? Just(s.slice(idx)) : Nothing;\n  }\n  S.stripPrefix =\n  def('stripPrefix', {}, [$.String, $.String, $Maybe($.String)], stripPrefix);\n\n  //# stripSuffix :: String -> String -> Maybe String\n  //.\n  //. Returns Just the portion of the given string (the second argument) left\n  //. after removing the given suffix (the first argument) if the string ends\n  //. with the suffix; Nothing otherwise.\n  //.\n  //. See also [`stripPrefix`](#stripPrefix).\n  //.\n  //. ```javascript\n  //. > S.stripSuffix('.md', 'README.md')\n  //. Just('README')\n  //.\n  //. > S.stripSuffix('.md', 'README')\n  //. Nothing\n  //. ```\n  function stripSuffix(suffix, s) {\n    var idx = s.length - suffix.length;  // value may be negative\n    return s.slice(idx) === suffix ? Just(s.slice(0, idx)) : Nothing;\n  }\n  S.stripSuffix =\n  def('stripSuffix', {}, [$.String, $.String, $Maybe($.String)], stripSuffix);\n\n  //# words :: String -> Array String\n  //.\n  //. Takes a string and returns the array of words the string contains\n  //. (words are delimited by whitespace characters).\n  //.\n  //. See also [`unwords`](#unwords).\n  //.\n  //. ```javascript\n  //. > S.words(' foo bar baz ')\n  //. ['foo', 'bar', 'baz']\n  //. ```\n  function words(s) {\n    var words = s.split(/\\s+/);\n    return words.slice(words[0] === '' ? 1 : 0,\n                       words[words.length - 1] === '' ? -1 : Infinity);\n  }\n  S.words = def('words', {}, [$.String, $.Array($.String)], words);\n\n  //# unwords :: Array String -> String\n  //.\n  //. Takes an array of words and returns the result of joining the words\n  //. with separating spaces.\n  //.\n  //. See also [`words`](#words).\n  //.\n  //. ```javascript\n  //. > S.unwords(['foo', 'bar', 'baz'])\n  //. 'foo bar baz'\n  //. ```\n  function unwords(xs) {\n    return xs.join(' ');\n  }\n  S.unwords = def('unwords', {}, [$.Array($.String), $.String], unwords);\n\n  //# lines :: String -> Array String\n  //.\n  //. Takes a string and returns the array of lines the string contains\n  //. (lines are delimited by newlines: `'\\n'` or `'\\r\\n'` or `'\\r'`).\n  //. The resulting strings do not contain newlines.\n  //.\n  //. See also [`unlines`](#unlines).\n  //.\n  //. ```javascript\n  //. > S.lines('foo\\nbar\\nbaz\\n')\n  //. ['foo', 'bar', 'baz']\n  //. ```\n  function lines(s) {\n    var match = s.replace(/\\r\\n?/g, '\\n').match(/^(?=[\\s\\S]).*/gm);\n    return match == null ? [] : match;\n  }\n  S.lines = def('lines', {}, [$.String, $.Array($.String)], lines);\n\n  //# unlines :: Array String -> String\n  //.\n  //. Takes an array of lines and returns the result of joining the lines\n  //. after appending a terminating line feed (`'\\n'`) to each.\n  //.\n  //. See also [`lines`](#lines).\n  //.\n  //. ```javascript\n  //. > S.unlines(['foo', 'bar', 'baz'])\n  //. 'foo\\nbar\\nbaz\\n'\n  //. ```\n  function unlines(xs) {\n    return Z.reduce(function(s, x) { return s + x + '\\n'; }, '', xs);\n  }\n  S.unlines = def('unlines', {}, [$.Array($.String), $.String], unlines);\n\n  //# splitOn :: String -> String -> Array String\n  //.\n  //. Returns the substrings of its second argument separated by occurrences\n  //. of its first argument.\n  //.\n  //. See also [`joinWith`](#joinWith) and [`splitOnRegex`](#splitOnRegex).\n  //.\n  //. ```javascript\n  //. > S.splitOn('::', 'foo::bar::baz')\n  //. ['foo', 'bar', 'baz']\n  //. ```\n  function splitOn(separator, s) {\n    return s.split(separator);\n  }\n  S.splitOn =\n  def('splitOn', {}, [$.String, $.String, $.Array($.String)], splitOn);\n\n  //# splitOnRegex :: GlobalRegExp -> String -> Array String\n  //.\n  //. Takes a pattern and a string, and returns the result of splitting the\n  //. string at every non-overlapping occurrence of the pattern.\n  //.\n  //. Properties:\n  //.\n  //.   - `forall s :: String, t :: String.\n  //.      S.joinWith(s, S.splitOnRegex(S.regex('g', S.regexEscape(s)), t))\n  //.      = t`\n  //.\n  //. See also [`splitOn`](#splitOn).\n  //.\n  //. ```javascript\n  //. > S.splitOnRegex(/[,;][ ]*/g, 'foo, bar, baz')\n  //. ['foo', 'bar', 'baz']\n  //.\n  //. > S.splitOnRegex(/[,;][ ]*/g, 'foo;bar;baz')\n  //. ['foo', 'bar', 'baz']\n  //. ```\n  function splitOnRegex(pattern, s) {\n    return withRegex(pattern, function() {\n      var result = [];\n      var lastIndex = 0;\n      var match;\n      while ((match = pattern.exec(s)) != null) {\n        if (pattern.lastIndex === lastIndex && match[0] === '') {\n          if (pattern.lastIndex === s.length) return result;\n          pattern.lastIndex += 1;\n        } else {\n          result.push(s.slice(lastIndex, match.index));\n          lastIndex = match.index + match[0].length;\n        }\n      }\n      result.push(s.slice(lastIndex));\n      return result;\n    });\n  }\n  S.splitOnRegex =\n  def('splitOnRegex',\n      {},\n      [$.GlobalRegExp, $.String, $.Array($.String)],\n      splitOnRegex);\n\n  return S;\n\n  /* eslint-enable indent */\n\n  }\n\n  return createSanctuary({checkTypes: true, env: defaultEnv});\n\n}));\n\n//. [$.Array]:          v:sanctuary-js/sanctuary-def#Array\n//. [$.String]:         v:sanctuary-js/sanctuary-def#String\n//. [Alt]:              v:fantasyland/fantasy-land#alt\n//. [Alternative]:      v:fantasyland/fantasy-land#alternative\n//. [Applicative]:      v:fantasyland/fantasy-land#applicative\n//. [Apply]:            v:fantasyland/fantasy-land#apply\n//. [Bifunctor]:        v:fantasyland/fantasy-land#bifunctor\n//. [BinaryType]:       v:sanctuary-js/sanctuary-def#BinaryType\n//. [Either]:           #either-type\n//. [Extend]:           v:fantasyland/fantasy-land#extend\n//. [Fantasy Land]:     v:fantasyland/fantasy-land\n//. [Foldable]:         v:fantasyland/fantasy-land#foldable\n//. [Haskell]:          https://www.haskell.org/\n//. [Maybe]:            #maybe-type\n//. [Monad]:            v:fantasyland/fantasy-land#monad\n//. [Monoid]:           v:fantasyland/fantasy-land#monoid\n//. [Nullable]:         v:sanctuary-js/sanctuary-def#Nullable\n//. [Ord]:              v:fantasyland/fantasy-land#ord\n//. [PureScript]:       http://www.purescript.org/\n//. [Ramda]:            http://ramdajs.com/\n//. [RegexFlags]:       v:sanctuary-js/sanctuary-def#RegexFlags\n//. [Semigroup]:        v:fantasyland/fantasy-land#semigroup\n//. [Semigroupoid]:     v:fantasyland/fantasy-land#semigroupoid\n//. [Traversable]:      v:fantasyland/fantasy-land#traversable\n//. [UnaryType]:        v:sanctuary-js/sanctuary-def#UnaryType\n//. [`Math.pow`]:       https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/pow\n//. [`Z.alt`]:          v:sanctuary-js/sanctuary-type-classes#alt\n//. [`Z.ap`]:           v:sanctuary-js/sanctuary-type-classes#ap\n//. [`Z.apFirst`]:      v:sanctuary-js/sanctuary-type-classes#apFirst\n//. [`Z.apSecond`]:     v:sanctuary-js/sanctuary-type-classes#apSecond\n//. [`Z.bimap`]:        v:sanctuary-js/sanctuary-type-classes#bimap\n//. [`Z.chain`]:        v:sanctuary-js/sanctuary-type-classes#chain\n//. [`Z.chainRec`]:     v:sanctuary-js/sanctuary-type-classes#chainRec\n//. [`Z.compose`]:      v:sanctuary-js/sanctuary-type-classes#compose\n//. [`Z.concat`]:       v:sanctuary-js/sanctuary-type-classes#concat\n//. [`Z.contramap`]:    v:sanctuary-js/sanctuary-type-classes#contramap\n//. [`Z.empty`]:        v:sanctuary-js/sanctuary-type-classes#empty\n//. [`Z.equals`]:       v:sanctuary-js/sanctuary-type-classes#equals\n//. [`Z.extend`]:       v:sanctuary-js/sanctuary-type-classes#extend\n//. [`Z.extract`]:      v:sanctuary-js/sanctuary-type-classes#extract\n//. [`Z.filter`]:       v:sanctuary-js/sanctuary-type-classes#filter\n//. [`Z.filterM`]:      v:sanctuary-js/sanctuary-type-classes#filterM\n//. [`Z.gt`]:           v:sanctuary-js/sanctuary-type-classes#gt\n//. [`Z.gte`]:          v:sanctuary-js/sanctuary-type-classes#gte\n//. [`Z.id`]:           v:sanctuary-js/sanctuary-type-classes#id\n//. [`Z.invert`]:       v:sanctuary-js/sanctuary-type-classes#invert\n//. [`Z.join`]:         v:sanctuary-js/sanctuary-type-classes#join\n//. [`Z.lt`]:           v:sanctuary-js/sanctuary-type-classes#lt\n//. [`Z.lte`]:          v:sanctuary-js/sanctuary-type-classes#lte\n//. [`Z.map`]:          v:sanctuary-js/sanctuary-type-classes#map\n//. [`Z.of`]:           v:sanctuary-js/sanctuary-type-classes#of\n//. [`Z.promap`]:       v:sanctuary-js/sanctuary-type-classes#promap\n//. [`Z.sequence`]:     v:sanctuary-js/sanctuary-type-classes#sequence\n//. [`Z.toString`]:     v:sanctuary-js/sanctuary-type-classes#toString\n//. [`Z.traverse`]:     v:sanctuary-js/sanctuary-type-classes#traverse\n//. [`Z.zero`]:         v:sanctuary-js/sanctuary-type-classes#zero\n//. [`of`]:             v:fantasyland/fantasy-land#of-method\n//. [equivalence]:      https://en.wikipedia.org/wiki/Equivalence_relation\n//. [iff]:              https://en.wikipedia.org/wiki/If_and_only_if\n//. [parseInt]:         https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt\n//. [sanctuary-def]:    v:sanctuary-js/sanctuary-def\n//. [stable sort]:      https://en.wikipedia.org/wiki/Sorting_algorithm#Stability\n//. [thrush]:           https://github.com/raganwald-deprecated/homoiconic/blob/master/2008-10-30/thrush.markdown\n//. [type identifier]:  v:sanctuary-js/sanctuary-type-identifiers\n//.\n//. [`Either#fantasy-land/bimap`]:      #Either.prototype.fantasy-land/bimap\n//. [`Either#fantasy-land/map`]:        #Either.prototype.fantasy-land/map\n//. [`Either#toString`]:                #Either.prototype.toString\n//. [`Maybe#toString`]:                 #Maybe.prototype.toString\n","'use strict';\n\nconst { map, toLower, prop, joinWith, pipe, concat, __ } = require('sanctuary');\n\nconst runtime = {\n    JSON: ''\n    , String: ''\n    , Integer: ''\n};\n\nconst declare = ({ name }) => `const ${name} = `\nconst extract = ({ path }) => ` process.env['${path}'] `\nconst templateStr = varName => `\\${${varName}}`\n// const assign = base => x => Object.assign({}, base, x )\n// const getWords = str => tail( str.match(/[a-z_]*/ig) )\nconst templateExports = (names) => `module.exports = { ${ names.join(', ') } }`\nconst processString = seen => ({ raw, val }) => {\n    if (raw) {\n        return `'${val}'`\n    }\n    return '`' + seen.reduce((acc, x) => acc.replace(x, templateStr(x)), val) + '`'\n\n    \n}\nconst processDefault = seen => {\n    const str = processString(seen);\n    return def => {\n        switch (def.type) {\n            case 'string':\n                return str(def)\n            case 'integer':\n            case 'boolean':\n            default:\n                return def.val\n        }\n    }\n}\nconst processDefaults = seen => x => '|| ' + map(processDefault(seen), x).join(' ||')\n\nconst compile = (trees) => {\n\n    const symbols = (map(prop('name'), trees)); // Hoist symbols\n\n    const compileExpression =\n        tree => {\n\n            const { body, coerceTo } = tree;\n            const type = toLower(coerceTo);\n            const defaults = map(({ val }) => ({ type, val }), body.defaults);\n            console.log(defaults)\n            return [\n                declare(tree)\n                , extract(body)\n                , processDefaults(symbols)(defaults)\n            ]\n        }\n\n\n    return pipe\n    ([\n          map(compileExpression)\n          , map(joinWith(''))\n          , joinWith(';\\n')\n          , concat(__, `\\n${templateExports(symbols)};\\n`)\n          , concat(`'use strict;'\\n`)\n    ])(trees)\n}\n\n\nmodule.exports = compile;","const logDeep = x => console.dir(x, {depth: 6, colors: true })\n\nmodule.exports= {logDeep}","'use strict';\n\nconst nearley = require(\"nearley\");\nconst grammar = require(\"./grammar.js\");\nconst compiler = require('./compiler');\nconst { logDeep } = require('../util');\n\n// Create a Parser object from our grammar.\nconst parser = new nearley.Parser(nearley.Grammar.fromCompiled(grammar));\n\n// Parse something!\nmodule.exports = (content) => {\n\n    parser.feed(content);\n    // parser.results is an array of possible parsings.\n    logDeep(parser.results); // [[[[ \"foo\" ],\"\\n\" ]]]\n    return compiler(parser.results[0]);\n};\n","'use strict';\n/**\n * READY FOR BE COMPILED WITH PARCEL\n */\n\nconst compile = require('../nearley/index');\nconst example = `PORT       = PORT      | 3000                   :: Int                                \nHOST       = HOST      | 'satan.com'            :: String   \nDB_URL     = URL       | 'http://HOST:PORT'     :: String   \n`;\nconsole.log(compile(example));"]}